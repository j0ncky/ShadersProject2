#line 1 "__UE_FILENAME_SENTINEL__"
SamplerState D3DStaticPointClampedSampler       : register(s1, space1000);
SamplerState D3DStaticBilinearClampedSampler    : register(s3, space1000);
precise float MakePrecise(in precise float v) { precise float pv = v; return pv; }
precise float2 MakePrecise(in precise float2 v) { precise float2 pv = v; return pv; }
precise float3 MakePrecise(in precise float3 v) { precise float3 pv = v; return pv; }
precise float4 MakePrecise(in precise float4 v) { precise float4 pv = v; return pv; }
float min3(float a, float b, float c)
{
	return min(a, min(b, c));
}
int min3(int a, int b, int c)
{
	return min(a, min(b, c));
}
uint min3(uint a, uint b, uint c)
{
	return min(a, min(b, c));
}
float2 min3 ( float2 a, float2 b, float2 c) { return float2( min3 (a.x , b.x , c.x ), min3 (a.y , b.y , c.y )); }
float3 min3 ( float3 a, float3 b, float3 c) { return float3( min3 (a.xy, b.xy, c.xy), min3 (a.z , b.z , c.z )); }
float4 min3 ( float4 a, float4 b, float4 c) { return float4( min3 (a.xy, b.xy, c.xy), min3 (a.zw, b.zw, c.zw)); }
int2 min3 ( int2 a, int2 b, int2 c) { return int2( min3 (a.x , b.x , c.x ), min3 (a.y , b.y , c.y )); }
int3 min3 ( int3 a, int3 b, int3 c) { return int3( min3 (a.xy, b.xy, c.xy), min3 (a.z , b.z , c.z )); }
int4 min3 ( int4 a, int4 b, int4 c) { return int4( min3 (a.xy, b.xy, c.xy), min3 (a.zw, b.zw, c.zw)); }
uint2 min3 ( uint2 a, uint2 b, uint2 c) { return uint2( min3 (a.x , b.x , c.x ), min3 (a.y , b.y , c.y )); }
uint3 min3 ( uint3 a, uint3 b, uint3 c) { return uint3( min3 (a.xy, b.xy, c.xy), min3 (a.z , b.z , c.z )); }
uint4 min3 ( uint4 a, uint4 b, uint4 c) { return uint4( min3 (a.xy, b.xy, c.xy), min3 (a.zw, b.zw, c.zw)); }
float max3(float a, float b, float c)
{
	return max(a, max(b, c));
}
int max3(int a, int b, int c)
{
	return max(a, max(b, c));
}
uint max3(uint a, uint b, uint c)
{
	return max(a, max(b, c));
}
float2 max3 ( float2 a, float2 b, float2 c) { return float2( max3 (a.x , b.x , c.x ), max3 (a.y , b.y , c.y )); }
float3 max3 ( float3 a, float3 b, float3 c) { return float3( max3 (a.xy, b.xy, c.xy), max3 (a.z , b.z , c.z )); }
float4 max3 ( float4 a, float4 b, float4 c) { return float4( max3 (a.xy, b.xy, c.xy), max3 (a.zw, b.zw, c.zw)); }
int2 max3 ( int2 a, int2 b, int2 c) { return int2( max3 (a.x , b.x , c.x ), max3 (a.y , b.y , c.y )); }
int3 max3 ( int3 a, int3 b, int3 c) { return int3( max3 (a.xy, b.xy, c.xy), max3 (a.z , b.z , c.z )); }
int4 max3 ( int4 a, int4 b, int4 c) { return int4( max3 (a.xy, b.xy, c.xy), max3 (a.zw, b.zw, c.zw)); }
uint2 max3 ( uint2 a, uint2 b, uint2 c) { return uint2( max3 (a.x , b.x , c.x ), max3 (a.y , b.y , c.y )); }
uint3 max3 ( uint3 a, uint3 b, uint3 c) { return uint3( max3 (a.xy, b.xy, c.xy), max3 (a.z , b.z , c.z )); }
uint4 max3 ( uint4 a, uint4 b, uint4 c) { return uint4( max3 (a.xy, b.xy, c.xy), max3 (a.zw, b.zw, c.zw)); }
bool select_internal(bool    c, bool a, bool b) { return bool (c   ? a.x : b.x); }
bool2 select_internal(bool    c, bool a, bool2 b) { return bool2(c   ? a   : b.x, c   ? a   : b.y); }
bool2 select_internal(bool    c, bool2 a, bool b) { return bool2(c   ? a.x : b  , c   ? a.y : b  ); }
bool2 select_internal(bool    c, bool2 a, bool2 b) { return bool2(c   ? a.x : b.x, c   ? a.y : b.y); }
bool2 select_internal(bool2   c, bool a, bool b) { return bool2(c.x ? a   : b  , c.y ? a   : b  ); }
bool2 select_internal(bool2   c, bool a, bool2 b) { return bool2(c.x ? a   : b.x, c.y ? a   : b.y); }
bool2 select_internal(bool2   c, bool2 a, bool b) { return bool2(c.x ? a.x : b  , c.y ? a.y : b  ); }
bool2 select_internal(bool2   c, bool2 a, bool2 b) { return bool2(c.x ? a.x : b.x, c.y ? a.y : b.y); }
bool3 select_internal(bool    c, bool a, bool3 b) { return bool3(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z); }
bool3 select_internal(bool    c, bool3 a, bool b) { return bool3(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  ); }
bool3 select_internal(bool    c, bool3 a, bool3 b) { return bool3(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z); }
bool3 select_internal(bool3   c, bool a, bool b) { return bool3(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  ); }
bool3 select_internal(bool3   c, bool a, bool3 b) { return bool3(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z); }
bool3 select_internal(bool3   c, bool3 a, bool b) { return bool3(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  ); }
bool3 select_internal(bool3   c, bool3 a, bool3 b) { return bool3(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); }
bool4 select_internal(bool    c, bool a, bool4 b) { return bool4(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z, c   ? a   : b.w); }
bool4 select_internal(bool    c, bool4 a, bool b) { return bool4(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  , c   ? a.w : b  ); }
bool4 select_internal(bool    c, bool4 a, bool4 b) { return bool4(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z, c   ? a.w : b.w); }
bool4 select_internal(bool4   c, bool a, bool b) { return bool4(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  , c.w ? a   : b  ); }
bool4 select_internal(bool4   c, bool a, bool4 b) { return bool4(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z, c.w ? a   : b.w); }
bool4 select_internal(bool4   c, bool4 a, bool b) { return bool4(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  , c.w ? a.w : b  ); }
bool4 select_internal(bool4   c, bool4 a, bool4 b) { return bool4(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
int select_internal(bool    c, int a, int b) { return int (c   ? a.x : b.x); }
int2 select_internal(bool    c, int a, int2 b) { return int2(c   ? a   : b.x, c   ? a   : b.y); }
int2 select_internal(bool    c, int2 a, int b) { return int2(c   ? a.x : b  , c   ? a.y : b  ); }
int2 select_internal(bool    c, int2 a, int2 b) { return int2(c   ? a.x : b.x, c   ? a.y : b.y); }
int2 select_internal(bool2   c, int a, int b) { return int2(c.x ? a   : b  , c.y ? a   : b  ); }
int2 select_internal(bool2   c, int a, int2 b) { return int2(c.x ? a   : b.x, c.y ? a   : b.y); }
int2 select_internal(bool2   c, int2 a, int b) { return int2(c.x ? a.x : b  , c.y ? a.y : b  ); }
int2 select_internal(bool2   c, int2 a, int2 b) { return int2(c.x ? a.x : b.x, c.y ? a.y : b.y); }
int3 select_internal(bool    c, int a, int3 b) { return int3(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z); }
int3 select_internal(bool    c, int3 a, int b) { return int3(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  ); }
int3 select_internal(bool    c, int3 a, int3 b) { return int3(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z); }
int3 select_internal(bool3   c, int a, int b) { return int3(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  ); }
int3 select_internal(bool3   c, int a, int3 b) { return int3(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z); }
int3 select_internal(bool3   c, int3 a, int b) { return int3(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  ); }
int3 select_internal(bool3   c, int3 a, int3 b) { return int3(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); }
int4 select_internal(bool    c, int a, int4 b) { return int4(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z, c   ? a   : b.w); }
int4 select_internal(bool    c, int4 a, int b) { return int4(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  , c   ? a.w : b  ); }
int4 select_internal(bool    c, int4 a, int4 b) { return int4(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z, c   ? a.w : b.w); }
int4 select_internal(bool4   c, int a, int b) { return int4(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  , c.w ? a   : b  ); }
int4 select_internal(bool4   c, int a, int4 b) { return int4(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z, c.w ? a   : b.w); }
int4 select_internal(bool4   c, int4 a, int b) { return int4(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  , c.w ? a.w : b  ); }
int4 select_internal(bool4   c, int4 a, int4 b) { return int4(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
float select_internal(bool    c, float a, float b) { return float (c   ? a.x : b.x); }
float2 select_internal(bool    c, float a, float2 b) { return float2(c   ? a   : b.x, c   ? a   : b.y); }
float2 select_internal(bool    c, float2 a, float b) { return float2(c   ? a.x : b  , c   ? a.y : b  ); }
float2 select_internal(bool    c, float2 a, float2 b) { return float2(c   ? a.x : b.x, c   ? a.y : b.y); }
float2 select_internal(bool2   c, float a, float b) { return float2(c.x ? a   : b  , c.y ? a   : b  ); }
float2 select_internal(bool2   c, float a, float2 b) { return float2(c.x ? a   : b.x, c.y ? a   : b.y); }
float2 select_internal(bool2   c, float2 a, float b) { return float2(c.x ? a.x : b  , c.y ? a.y : b  ); }
float2 select_internal(bool2   c, float2 a, float2 b) { return float2(c.x ? a.x : b.x, c.y ? a.y : b.y); }
float3 select_internal(bool    c, float a, float3 b) { return float3(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z); }
float3 select_internal(bool    c, float3 a, float b) { return float3(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  ); }
float3 select_internal(bool    c, float3 a, float3 b) { return float3(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z); }
float3 select_internal(bool3   c, float a, float b) { return float3(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  ); }
float3 select_internal(bool3   c, float a, float3 b) { return float3(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z); }
float3 select_internal(bool3   c, float3 a, float b) { return float3(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  ); }
float3 select_internal(bool3   c, float3 a, float3 b) { return float3(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); }
float4 select_internal(bool    c, float a, float4 b) { return float4(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z, c   ? a   : b.w); }
float4 select_internal(bool    c, float4 a, float b) { return float4(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  , c   ? a.w : b  ); }
float4 select_internal(bool    c, float4 a, float4 b) { return float4(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z, c   ? a.w : b.w); }
float4 select_internal(bool4   c, float a, float b) { return float4(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  , c.w ? a   : b  ); }
float4 select_internal(bool4   c, float a, float4 b) { return float4(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z, c.w ? a   : b.w); }
float4 select_internal(bool4   c, float4 a, float b) { return float4(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  , c.w ? a.w : b  ); }
float4 select_internal(bool4   c, float4 a, float4 b) { return float4(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
bool  and_internal(bool  a, bool  b) { return bool(a && b); }
bool2 and_internal(bool2 a, bool2 b) { return bool2(a.x && b.x, a.y && b.y); }
bool3 and_internal(bool3 a, bool3 b) { return bool3(a.x && b.x, a.y && b.y, a.z && b.z); }
bool4 and_internal(bool4 a, bool4 b) { return bool4(a.x && b.x, a.y && b.y, a.z && b.z, a.w && b.w); }
float  CondMask(bool Cond, float  Src0, float  Src1) { return Cond ? Src0 : Src1; }
float2 CondMask(bool Cond, float2 Src0, float2 Src1) { return Cond ? Src0 : Src1; }
float3 CondMask(bool Cond, float3 Src0, float3 Src1) { return Cond ? Src0 : Src1; }
float4 CondMask(bool Cond, float4 Src0, float4 Src1) { return Cond ? Src0 : Src1; }
int  CondMask(bool Cond, int  Src0, int  Src1) { return Cond ? Src0 : Src1; }
int2 CondMask(bool Cond, int2 Src0, int2 Src1) { return Cond ? Src0 : Src1; }
int3 CondMask(bool Cond, int3 Src0, int3 Src1) { return Cond ? Src0 : Src1; }
int4 CondMask(bool Cond, int4 Src0, int4 Src1) { return Cond ? Src0 : Src1; }
uint  CondMask(bool Cond, uint  Src0, uint  Src1) { return Cond ? Src0 : Src1; }
uint2 CondMask(bool Cond, uint2 Src0, uint2 Src1) { return Cond ? Src0 : Src1; }
uint3 CondMask(bool Cond, uint3 Src0, uint3 Src1) { return Cond ? Src0 : Src1; }
uint4 CondMask(bool Cond, uint4 Src0, uint4 Src1) { return Cond ? Src0 : Src1; }
uint Padding(uint Value, uint Pow2)
{
	return (Value + Pow2 - 1u) & ~(Pow2 - 1u);
}
float UnpackUnorm10(uint In)
{
	return float(In & 0x3FF) * (1.0f / 1023.0f);
}
const static float PI = 3.1415926535897932f;
const static float Max10BitsFloat = 64512.0f;
struct FDFScalar
{
	float High;
	float Low;
};
FDFScalar MakeDFScalar(float High, float Low)
{
	FDFScalar Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFScalar DFPromote(FDFScalar Value) { return Value; }
FDFScalar DFPromote(float Value) { return MakeDFScalar(Value, (float)0); }
float DFDemote(FDFScalar Value) { return Value.High + Value.Low; }
float DFDemote(float Value) { return Value; }
FDFScalar DFNegate(FDFScalar Value)
{
	return MakeDFScalar(-Value.High, -Value.Low);
}
FDFScalar DFTwoSum(float Lhs, float Rhs)
{
	const float S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float V =   MakePrecise( ( S ) - ( Lhs ) );
	const float Q =   MakePrecise( ( S ) - ( V ) );
	const float R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float T =   MakePrecise( ( Rhs ) - ( V ) );
	const float Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFScalar(S, Y);
}
FDFScalar DFFastTwoSum(float Lhs, float Rhs)
{
	const float S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float T =   MakePrecise( ( S ) - ( Lhs ) );
	const float E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFScalar(S, E);
}
float DFAddDemote(FDFScalar Lhs, FDFScalar Rhs)
{
	FDFScalar S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFScalar T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	return S.High + S.Low;
}
float DFAddDemote(FDFScalar Lhs, float Rhs)
{
	const FDFScalar S = DFTwoSum(Lhs.High, Rhs);
	const float T = Lhs.Low + S.Low;
	return S.High + T;
}
float DFAddDemote(float Lhs, FDFScalar Rhs) { return DFAddDemote(Rhs, Lhs); }
float DFAddDemote(float Lhs, float Rhs) { return Lhs + Rhs; }
float DFFastAddDemote(FDFScalar Lhs, FDFScalar Rhs)
{
	FDFScalar S = DFTwoSum(Lhs.High, Rhs.High);
	S.Low += Lhs.Low + Rhs.Low;
	return S.High + S.Low;
}
float DFFastAddDemote(FDFScalar Lhs, float Rhs) { return DFAddDemote(Lhs, Rhs); }
float DFFastAddDemote(float Lhs, FDFScalar Rhs) { return DFFastAddDemote(Rhs, Lhs); }
float DFFastAddDemote(float Lhs, float Rhs) { return Rhs + Lhs; }
float DFFastSubtractDemote(float Lhs, float Rhs) { return Lhs - Rhs; }
float DFFastSubtractDemote(FDFScalar Lhs, FDFScalar Rhs) { return DFFastAddDemote(Lhs, DFNegate(Rhs)); }
float DFFastSubtractDemote(FDFScalar Lhs, float Rhs) { return DFFastAddDemote(Lhs, -Rhs); }
float DFFastSubtractDemote(float Lhs, FDFScalar Rhs) { return DFFastAddDemote(Lhs, DFNegate(Rhs)); }
float DFFastLocalSubtractDemote(FDFScalar Lhs, FDFScalar Rhs)
{
	const float High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float DFFastLocalSubtractDemote(FDFScalar Lhs, float Rhs)
{
	const float High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float DFFastLocalSubtractDemote(float Lhs, FDFScalar Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFScalar DFTwoProduct(float Lhs, float Rhs)
{
	const float P = Lhs * Rhs;
	const float E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFScalar(P, E);
}
FDFScalar DFMultiply(float Lhs, float Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFScalar DFMultiply(FDFScalar Lhs, FDFScalar Rhs)
{
	const FDFScalar P = DFTwoProduct(Lhs.High, Rhs.High);
	float T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFScalar DFMultiply(FDFScalar Lhs, float Rhs)
{
	FDFScalar P = DFTwoProduct(Lhs.High, Rhs);
	float T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFScalar DFMultiply(float Lhs, FDFScalar Rhs) { return DFMultiply(Rhs, Lhs); }
float DFMultiplyDemote(FDFScalar Lhs, FDFScalar Rhs)
{
	const FDFScalar P = DFTwoProduct(Lhs.High, Rhs.High);
	float T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	const float S =   MakePrecise( ( P.High ) + ( T ) );
	return S;
}
float DFMultiplyDemote(FDFScalar Lhs, float Rhs)
{
	FDFScalar P = DFTwoProduct(Lhs.High, Rhs);
	P.Low =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	const float S =   MakePrecise( ( P.High ) + ( P.Low ) );
	return S;
}
float DFMultiplyDemote(float Lhs, FDFScalar Rhs) { return DFMultiplyDemote(Rhs, Lhs); }
float DFMultiplyDemote(float Lhs, float Rhs) { return Lhs * Rhs; }
FDFScalar DFFastDivide(FDFScalar Lhs, FDFScalar Rhs);
FDFScalar DFFastDivide(FDFScalar Lhs, FDFScalar Rhs)
{
	const float Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFScalar R = DFMultiply(Rhs, Th);
	const float Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFScalar DFFastDivide(FDFScalar Lhs, float Rhs)
{
	const float Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFScalar R = DFTwoProduct(Rhs, Th);
	const float Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFScalar DFFastDivide(float Lhs, FDFScalar Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFScalar DFFastDivide(float Lhs, float Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFScalar DFDivideByPow2(FDFScalar Lhs, float Rhs)
{
	return MakeDFScalar(Lhs.High / Rhs, Lhs.Low / Rhs);
}
float DFFracDemote(FDFScalar V)
{
	return frac(frac(V.High) + frac(V.Low));
}
float DFFmodByPow2Demote(FDFScalar Lhs, float Rhs)
{
	return DFFracDemote(DFDivideByPow2(Lhs, Rhs)) * Rhs;
}
FDFScalar MakeDFVector(FDFScalar X) { return X; }
struct FDFVector2
{
	float2 High;
	float2 Low;
};
FDFVector2 MakeDFVector2(float2 High, float2 Low)
{
	FDFVector2 Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFVector2 DFPromote(FDFVector2 Value) { return Value; }
FDFVector2 DFPromote(float2 Value) { return MakeDFVector2(Value, (float2)0); }
float2 DFDemote(FDFVector2 Value) { return Value.High + Value.Low; }
float2 DFDemote(float2 Value) { return Value; }
FDFVector2 DFNegate(FDFVector2 Value)
{
	return MakeDFVector2(-Value.High, -Value.Low);
}
FDFVector2 DFTwoSum(float2 Lhs, float2 Rhs)
{
	const float2 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float2 V =   MakePrecise( ( S ) - ( Lhs ) );
	const float2 Q =   MakePrecise( ( S ) - ( V ) );
	const float2 R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float2 T =   MakePrecise( ( Rhs ) - ( V ) );
	const float2 Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFVector2(S, Y);
}
FDFVector2 DFFastTwoSum(float2 Lhs, float2 Rhs)
{
	const float2 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float2 T =   MakePrecise( ( S ) - ( Lhs ) );
	const float2 E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFVector2(S, E);
}
float2 DFAddDemote(FDFVector2 Lhs, FDFVector2 Rhs)
{
	FDFVector2 S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFVector2 T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	return S.High + S.Low;
}
float2 DFAddDemote(FDFVector2 Lhs, float2 Rhs)
{
	const FDFVector2 S = DFTwoSum(Lhs.High, Rhs);
	const float2 T = Lhs.Low + S.Low;
	return S.High + T;
}
float2 DFAddDemote(float2 Lhs, FDFVector2 Rhs) { return DFAddDemote(Rhs, Lhs); }
float2 DFAddDemote(float2 Lhs, float2 Rhs) { return Lhs + Rhs; }
float2 DFFastAddDemote(FDFVector2 Lhs, FDFVector2 Rhs)
{
	FDFVector2 S = DFTwoSum(Lhs.High, Rhs.High);
	S.Low += Lhs.Low + Rhs.Low;
	return S.High + S.Low;
}
float2 DFFastAddDemote(FDFVector2 Lhs, float2 Rhs) { return DFAddDemote(Lhs, Rhs); }
float2 DFFastAddDemote(float2 Lhs, FDFVector2 Rhs) { return DFFastAddDemote(Rhs, Lhs); }
float2 DFFastAddDemote(float2 Lhs, float2 Rhs) { return Rhs + Lhs; }
float2 DFFastSubtractDemote(float2 Lhs, float2 Rhs) { return Lhs - Rhs; }
float2 DFFastSubtractDemote(FDFVector2 Lhs, FDFVector2 Rhs) { return DFFastAddDemote(Lhs, DFNegate(Rhs)); }
float2 DFFastSubtractDemote(FDFVector2 Lhs, float2 Rhs) { return DFFastAddDemote(Lhs, -Rhs); }
float2 DFFastSubtractDemote(float2 Lhs, FDFVector2 Rhs) { return DFFastAddDemote(Lhs, DFNegate(Rhs)); }
float2 DFFastLocalSubtractDemote(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const float2 High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float2 Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float2 Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float2 DFFastLocalSubtractDemote(FDFVector2 Lhs, float2 Rhs)
{
	const float2 High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float2 Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float2 DFFastLocalSubtractDemote(float2 Lhs, FDFVector2 Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFVector2 DFTwoProduct(float2 Lhs, float2 Rhs)
{
	const float2 P = Lhs * Rhs;
	const float2 E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFVector2(P, E);
}
FDFVector2 DFMultiply(float2 Lhs, float2 Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFVector2 DFMultiply(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const FDFVector2 P = DFTwoProduct(Lhs.High, Rhs.High);
	float2 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector2 DFMultiply(FDFVector2 Lhs, float2 Rhs)
{
	FDFVector2 P = DFTwoProduct(Lhs.High, Rhs);
	float2 T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector2 DFMultiply(float2 Lhs, FDFVector2 Rhs) { return DFMultiply(Rhs, Lhs); }
float2 DFMultiplyDemote(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const FDFVector2 P = DFTwoProduct(Lhs.High, Rhs.High);
	float2 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	const float2 S =   MakePrecise( ( P.High ) + ( T ) );
	return S;
}
float2 DFMultiplyDemote(FDFVector2 Lhs, float2 Rhs)
{
	FDFVector2 P = DFTwoProduct(Lhs.High, Rhs);
	P.Low =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	const float2 S =   MakePrecise( ( P.High ) + ( P.Low ) );
	return S;
}
float2 DFMultiplyDemote(float2 Lhs, FDFVector2 Rhs) { return DFMultiplyDemote(Rhs, Lhs); }
float2 DFMultiplyDemote(float2 Lhs, float2 Rhs) { return Lhs * Rhs; }
FDFVector2 DFFastDivide(FDFVector2 Lhs, FDFVector2 Rhs);
FDFVector2 DFFastDivide(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const float2 Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFVector2 R = DFMultiply(Rhs, Th);
	const float2 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float2 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float2 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float2 Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector2 DFFastDivide(FDFVector2 Lhs, float2 Rhs)
{
	const float2 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector2 R = DFTwoProduct(Rhs, Th);
	const float2 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float2 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float2 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float2 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector2 DFFastDivide(float2 Lhs, FDFVector2 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector2 DFFastDivide(float2 Lhs, float2 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector2 DFDivideByPow2(FDFVector2 Lhs, float2 Rhs)
{
	return MakeDFVector2(Lhs.High / Rhs, Lhs.Low / Rhs);
}
float2 DFFracDemote(FDFVector2 V)
{
	return frac(frac(V.High) + frac(V.Low));
}
float2 DFFmodByPow2Demote(FDFVector2 Lhs, float2 Rhs)
{
	return DFFracDemote(DFDivideByPow2(Lhs, Rhs)) * Rhs;
}
FDFVector2 DFBroadcast2(FDFScalar V)
{
	const float2 High = V.High;
	const float2 Low = V.Low;
	return MakeDFVector2(High, Low);
}
float2 DFBroadcast2(float V)
{
	const float2 Single = V;
	return Single;
}
float2  DFAddDemote (FDFScalar Lhs, FDFVector2 Rhs) { return DFAddDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFAddDemote (float Lhs, FDFVector2 Rhs) { return DFAddDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFAddDemote (FDFScalar Lhs, float2 Rhs) { return DFAddDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFAddDemote (float Lhs, float2 Rhs) { return DFAddDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFAddDemote (FDFVector2 Lhs, FDFScalar Rhs) { return DFAddDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFAddDemote (FDFVector2 Lhs, float Rhs)     { return DFAddDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFAddDemote (float2 Lhs, FDFScalar Rhs) { return DFAddDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFAddDemote (float2 Lhs, float Rhs) { return DFAddDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFFastAddDemote (FDFScalar Lhs, FDFVector2 Rhs) { return DFFastAddDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFFastAddDemote (float Lhs, FDFVector2 Rhs) { return DFFastAddDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFFastAddDemote (FDFScalar Lhs, float2 Rhs) { return DFFastAddDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFFastAddDemote (float Lhs, float2 Rhs) { return DFFastAddDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFFastAddDemote (FDFVector2 Lhs, FDFScalar Rhs) { return DFFastAddDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFFastAddDemote (FDFVector2 Lhs, float Rhs)     { return DFFastAddDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFFastAddDemote (float2 Lhs, FDFScalar Rhs) { return DFFastAddDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFFastAddDemote (float2 Lhs, float Rhs) { return DFFastAddDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFFastSubtractDemote (FDFScalar Lhs, FDFVector2 Rhs) { return DFFastSubtractDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFFastSubtractDemote (float Lhs, FDFVector2 Rhs) { return DFFastSubtractDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFFastSubtractDemote (FDFScalar Lhs, float2 Rhs) { return DFFastSubtractDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFFastSubtractDemote (float Lhs, float2 Rhs) { return DFFastSubtractDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFFastSubtractDemote (FDFVector2 Lhs, FDFScalar Rhs) { return DFFastSubtractDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFFastSubtractDemote (FDFVector2 Lhs, float Rhs)     { return DFFastSubtractDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFFastSubtractDemote (float2 Lhs, FDFScalar Rhs) { return DFFastSubtractDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFFastSubtractDemote (float2 Lhs, float Rhs) { return DFFastSubtractDemote (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (FDFScalar Lhs, FDFVector2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (float Lhs, FDFVector2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (FDFScalar Lhs, float2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (float Lhs, float2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (FDFVector2 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (FDFVector2 Lhs, float Rhs)     { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (float2 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (float2 Lhs, float Rhs) { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
float2  DFMultiplyDemote (FDFScalar Lhs, FDFVector2 Rhs) { return DFMultiplyDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFMultiplyDemote (float Lhs, FDFVector2 Rhs) { return DFMultiplyDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFMultiplyDemote (FDFScalar Lhs, float2 Rhs) { return DFMultiplyDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFMultiplyDemote (float Lhs, float2 Rhs) { return DFMultiplyDemote (DFBroadcast2(Lhs), Rhs); }
float2  DFMultiplyDemote (FDFVector2 Lhs, FDFScalar Rhs) { return DFMultiplyDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFMultiplyDemote (FDFVector2 Lhs, float Rhs)     { return DFMultiplyDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFMultiplyDemote (float2 Lhs, FDFScalar Rhs) { return DFMultiplyDemote (Lhs, DFBroadcast2(Rhs)); }
float2  DFMultiplyDemote (float2 Lhs, float Rhs) { return DFMultiplyDemote (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (FDFScalar Lhs, FDFVector2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (float Lhs, FDFVector2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (FDFScalar Lhs, float2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (float Lhs, float2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (FDFVector2 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (FDFVector2 Lhs, float Rhs)     { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (float2 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (float2 Lhs, float Rhs) { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2 DFDivideByPow2(FDFVector2 Lhs, float Rhs)
{
	float2 RhsVect = Rhs;
	return DFDivideByPow2(Lhs, RhsVect);
}
FDFVector2 MakeDFVector(FDFScalar X, FDFScalar Y) { return MakeDFVector2(float2(X.High, Y.High), float2(X.Low, Y.Low)); }
struct FDFVector3
{
	float3 High;
	float3 Low;
};
FDFVector3 MakeDFVector3(float3 High, float3 Low)
{
	FDFVector3 Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFVector3 DFPromote(FDFVector3 Value) { return Value; }
FDFVector3 DFPromote(float3 Value) { return MakeDFVector3(Value, (float3)0); }
float3 DFDemote(FDFVector3 Value) { return Value.High + Value.Low; }
float3 DFDemote(float3 Value) { return Value; }
FDFVector3 DFNegate(FDFVector3 Value)
{
	return MakeDFVector3(-Value.High, -Value.Low);
}
FDFVector3 DFTwoSum(float3 Lhs, float3 Rhs)
{
	const float3 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float3 V =   MakePrecise( ( S ) - ( Lhs ) );
	const float3 Q =   MakePrecise( ( S ) - ( V ) );
	const float3 R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float3 T =   MakePrecise( ( Rhs ) - ( V ) );
	const float3 Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFVector3(S, Y);
}
FDFVector3 DFFastTwoSum(float3 Lhs, float3 Rhs)
{
	const float3 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float3 T =   MakePrecise( ( S ) - ( Lhs ) );
	const float3 E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFVector3(S, E);
}
float3 DFAddDemote(FDFVector3 Lhs, FDFVector3 Rhs)
{
	FDFVector3 S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFVector3 T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	return S.High + S.Low;
}
float3 DFAddDemote(FDFVector3 Lhs, float3 Rhs)
{
	const FDFVector3 S = DFTwoSum(Lhs.High, Rhs);
	const float3 T = Lhs.Low + S.Low;
	return S.High + T;
}
float3 DFAddDemote(float3 Lhs, FDFVector3 Rhs) { return DFAddDemote(Rhs, Lhs); }
float3 DFAddDemote(float3 Lhs, float3 Rhs) { return Lhs + Rhs; }
float3 DFFastAddDemote(FDFVector3 Lhs, FDFVector3 Rhs)
{
	FDFVector3 S = DFTwoSum(Lhs.High, Rhs.High);
	S.Low += Lhs.Low + Rhs.Low;
	return S.High + S.Low;
}
float3 DFFastAddDemote(FDFVector3 Lhs, float3 Rhs) { return DFAddDemote(Lhs, Rhs); }
float3 DFFastAddDemote(float3 Lhs, FDFVector3 Rhs) { return DFFastAddDemote(Rhs, Lhs); }
float3 DFFastAddDemote(float3 Lhs, float3 Rhs) { return Rhs + Lhs; }
float3 DFFastSubtractDemote(float3 Lhs, float3 Rhs) { return Lhs - Rhs; }
float3 DFFastSubtractDemote(FDFVector3 Lhs, FDFVector3 Rhs) { return DFFastAddDemote(Lhs, DFNegate(Rhs)); }
float3 DFFastSubtractDemote(FDFVector3 Lhs, float3 Rhs) { return DFFastAddDemote(Lhs, -Rhs); }
float3 DFFastSubtractDemote(float3 Lhs, FDFVector3 Rhs) { return DFFastAddDemote(Lhs, DFNegate(Rhs)); }
float3 DFFastLocalSubtractDemote(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const float3 High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float3 Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float3 Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float3 DFFastLocalSubtractDemote(FDFVector3 Lhs, float3 Rhs)
{
	const float3 High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float3 Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float3 DFFastLocalSubtractDemote(float3 Lhs, FDFVector3 Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFVector3 DFTwoProduct(float3 Lhs, float3 Rhs)
{
	const float3 P = Lhs * Rhs;
	const float3 E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFVector3(P, E);
}
FDFVector3 DFMultiply(float3 Lhs, float3 Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFVector3 DFMultiply(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const FDFVector3 P = DFTwoProduct(Lhs.High, Rhs.High);
	float3 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector3 DFMultiply(FDFVector3 Lhs, float3 Rhs)
{
	FDFVector3 P = DFTwoProduct(Lhs.High, Rhs);
	float3 T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector3 DFMultiply(float3 Lhs, FDFVector3 Rhs) { return DFMultiply(Rhs, Lhs); }
float3 DFMultiplyDemote(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const FDFVector3 P = DFTwoProduct(Lhs.High, Rhs.High);
	float3 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	const float3 S =   MakePrecise( ( P.High ) + ( T ) );
	return S;
}
float3 DFMultiplyDemote(FDFVector3 Lhs, float3 Rhs)
{
	FDFVector3 P = DFTwoProduct(Lhs.High, Rhs);
	P.Low =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	const float3 S =   MakePrecise( ( P.High ) + ( P.Low ) );
	return S;
}
float3 DFMultiplyDemote(float3 Lhs, FDFVector3 Rhs) { return DFMultiplyDemote(Rhs, Lhs); }
float3 DFMultiplyDemote(float3 Lhs, float3 Rhs) { return Lhs * Rhs; }
FDFVector3 DFFastDivide(FDFVector3 Lhs, FDFVector3 Rhs);
FDFVector3 DFFastDivide(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const float3 Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFVector3 R = DFMultiply(Rhs, Th);
	const float3 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float3 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float3 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float3 Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector3 DFFastDivide(FDFVector3 Lhs, float3 Rhs)
{
	const float3 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector3 R = DFTwoProduct(Rhs, Th);
	const float3 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float3 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float3 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float3 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector3 DFFastDivide(float3 Lhs, FDFVector3 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector3 DFFastDivide(float3 Lhs, float3 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector3 DFDivideByPow2(FDFVector3 Lhs, float3 Rhs)
{
	return MakeDFVector3(Lhs.High / Rhs, Lhs.Low / Rhs);
}
float3 DFFracDemote(FDFVector3 V)
{
	return frac(frac(V.High) + frac(V.Low));
}
float3 DFFmodByPow2Demote(FDFVector3 Lhs, float3 Rhs)
{
	return DFFracDemote(DFDivideByPow2(Lhs, Rhs)) * Rhs;
}
FDFVector3 DFBroadcast3(FDFScalar V)
{
	const float3 High = V.High;
	const float3 Low = V.Low;
	return MakeDFVector3(High, Low);
}
float3 DFBroadcast3(float V)
{
	const float3 Single = V;
	return Single;
}
float3  DFAddDemote (FDFScalar Lhs, FDFVector3 Rhs) { return DFAddDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFAddDemote (float Lhs, FDFVector3 Rhs) { return DFAddDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFAddDemote (FDFScalar Lhs, float3 Rhs) { return DFAddDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFAddDemote (float Lhs, float3 Rhs) { return DFAddDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFAddDemote (FDFVector3 Lhs, FDFScalar Rhs) { return DFAddDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFAddDemote (FDFVector3 Lhs, float Rhs)     { return DFAddDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFAddDemote (float3 Lhs, FDFScalar Rhs) { return DFAddDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFAddDemote (float3 Lhs, float Rhs) { return DFAddDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFFastAddDemote (FDFScalar Lhs, FDFVector3 Rhs) { return DFFastAddDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFFastAddDemote (float Lhs, FDFVector3 Rhs) { return DFFastAddDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFFastAddDemote (FDFScalar Lhs, float3 Rhs) { return DFFastAddDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFFastAddDemote (float Lhs, float3 Rhs) { return DFFastAddDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFFastAddDemote (FDFVector3 Lhs, FDFScalar Rhs) { return DFFastAddDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFFastAddDemote (FDFVector3 Lhs, float Rhs)     { return DFFastAddDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFFastAddDemote (float3 Lhs, FDFScalar Rhs) { return DFFastAddDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFFastAddDemote (float3 Lhs, float Rhs) { return DFFastAddDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFFastSubtractDemote (FDFScalar Lhs, FDFVector3 Rhs) { return DFFastSubtractDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFFastSubtractDemote (float Lhs, FDFVector3 Rhs) { return DFFastSubtractDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFFastSubtractDemote (FDFScalar Lhs, float3 Rhs) { return DFFastSubtractDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFFastSubtractDemote (float Lhs, float3 Rhs) { return DFFastSubtractDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFFastSubtractDemote (FDFVector3 Lhs, FDFScalar Rhs) { return DFFastSubtractDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFFastSubtractDemote (FDFVector3 Lhs, float Rhs)     { return DFFastSubtractDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFFastSubtractDemote (float3 Lhs, FDFScalar Rhs) { return DFFastSubtractDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFFastSubtractDemote (float3 Lhs, float Rhs) { return DFFastSubtractDemote (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (FDFScalar Lhs, FDFVector3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (float Lhs, FDFVector3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (FDFScalar Lhs, float3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (float Lhs, float3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (FDFVector3 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (FDFVector3 Lhs, float Rhs)     { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (float3 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (float3 Lhs, float Rhs) { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
float3  DFMultiplyDemote (FDFScalar Lhs, FDFVector3 Rhs) { return DFMultiplyDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFMultiplyDemote (float Lhs, FDFVector3 Rhs) { return DFMultiplyDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFMultiplyDemote (FDFScalar Lhs, float3 Rhs) { return DFMultiplyDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFMultiplyDemote (float Lhs, float3 Rhs) { return DFMultiplyDemote (DFBroadcast3(Lhs), Rhs); }
float3  DFMultiplyDemote (FDFVector3 Lhs, FDFScalar Rhs) { return DFMultiplyDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFMultiplyDemote (FDFVector3 Lhs, float Rhs)     { return DFMultiplyDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFMultiplyDemote (float3 Lhs, FDFScalar Rhs) { return DFMultiplyDemote (Lhs, DFBroadcast3(Rhs)); }
float3  DFMultiplyDemote (float3 Lhs, float Rhs) { return DFMultiplyDemote (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (FDFScalar Lhs, FDFVector3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (float Lhs, FDFVector3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (FDFScalar Lhs, float3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (float Lhs, float3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (FDFVector3 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (FDFVector3 Lhs, float Rhs)     { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (float3 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (float3 Lhs, float Rhs) { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3 DFDivideByPow2(FDFVector3 Lhs, float Rhs)
{
	float3 RhsVect = Rhs;
	return DFDivideByPow2(Lhs, RhsVect);
}
FDFVector3 MakeDFVector(FDFScalar   X, FDFScalar   Y, FDFScalar Z) { return MakeDFVector3(float3( X.High,  Y.High, Z.High), float3( X.Low,  Y.Low, Z.Low)); }
FDFVector3 MakeDFVector(FDFScalar   X, FDFVector2 YZ)              { return MakeDFVector3(float3( X.High, YZ.High),         float3( X.Low, YZ.Low)); }
FDFVector3 MakeDFVector(FDFVector2 XY, FDFScalar   Z)              { return MakeDFVector3(float3(XY.High,  Z.High),         float3(XY.Low,  Z.Low)); }
struct FDFVector4
{
	float4 High;
	float4 Low;
};
FDFVector4 MakeDFVector4(float4 High, float4 Low)
{
	FDFVector4 Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFVector4 DFPromote(FDFVector4 Value) { return Value; }
FDFVector4 DFPromote(float4 Value) { return MakeDFVector4(Value, (float4)0); }
float4 DFDemote(FDFVector4 Value) { return Value.High + Value.Low; }
float4 DFDemote(float4 Value) { return Value; }
FDFVector4 DFNegate(FDFVector4 Value)
{
	return MakeDFVector4(-Value.High, -Value.Low);
}
FDFVector4 DFTwoSum(float4 Lhs, float4 Rhs)
{
	const float4 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float4 V =   MakePrecise( ( S ) - ( Lhs ) );
	const float4 Q =   MakePrecise( ( S ) - ( V ) );
	const float4 R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float4 T =   MakePrecise( ( Rhs ) - ( V ) );
	const float4 Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFVector4(S, Y);
}
FDFVector4 DFFastTwoSum(float4 Lhs, float4 Rhs)
{
	const float4 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float4 T =   MakePrecise( ( S ) - ( Lhs ) );
	const float4 E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFVector4(S, E);
}
float4 DFAddDemote(FDFVector4 Lhs, FDFVector4 Rhs)
{
	FDFVector4 S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFVector4 T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	return S.High + S.Low;
}
float4 DFAddDemote(FDFVector4 Lhs, float4 Rhs)
{
	const FDFVector4 S = DFTwoSum(Lhs.High, Rhs);
	const float4 T = Lhs.Low + S.Low;
	return S.High + T;
}
float4 DFAddDemote(float4 Lhs, FDFVector4 Rhs) { return DFAddDemote(Rhs, Lhs); }
float4 DFAddDemote(float4 Lhs, float4 Rhs) { return Lhs + Rhs; }
float4 DFFastAddDemote(FDFVector4 Lhs, FDFVector4 Rhs)
{
	FDFVector4 S = DFTwoSum(Lhs.High, Rhs.High);
	S.Low += Lhs.Low + Rhs.Low;
	return S.High + S.Low;
}
float4 DFFastAddDemote(FDFVector4 Lhs, float4 Rhs) { return DFAddDemote(Lhs, Rhs); }
float4 DFFastAddDemote(float4 Lhs, FDFVector4 Rhs) { return DFFastAddDemote(Rhs, Lhs); }
float4 DFFastAddDemote(float4 Lhs, float4 Rhs) { return Rhs + Lhs; }
float4 DFFastSubtractDemote(float4 Lhs, float4 Rhs) { return Lhs - Rhs; }
float4 DFFastSubtractDemote(FDFVector4 Lhs, FDFVector4 Rhs) { return DFFastAddDemote(Lhs, DFNegate(Rhs)); }
float4 DFFastSubtractDemote(FDFVector4 Lhs, float4 Rhs) { return DFFastAddDemote(Lhs, -Rhs); }
float4 DFFastSubtractDemote(float4 Lhs, FDFVector4 Rhs) { return DFFastAddDemote(Lhs, DFNegate(Rhs)); }
float4 DFFastLocalSubtractDemote(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const float4 High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float4 Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float4 Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float4 DFFastLocalSubtractDemote(FDFVector4 Lhs, float4 Rhs)
{
	const float4 High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float4 Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float4 DFFastLocalSubtractDemote(float4 Lhs, FDFVector4 Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFVector4 DFTwoProduct(float4 Lhs, float4 Rhs)
{
	const float4 P = Lhs * Rhs;
	const float4 E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFVector4(P, E);
}
FDFVector4 DFMultiply(float4 Lhs, float4 Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFVector4 DFMultiply(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const FDFVector4 P = DFTwoProduct(Lhs.High, Rhs.High);
	float4 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector4 DFMultiply(FDFVector4 Lhs, float4 Rhs)
{
	FDFVector4 P = DFTwoProduct(Lhs.High, Rhs);
	float4 T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector4 DFMultiply(float4 Lhs, FDFVector4 Rhs) { return DFMultiply(Rhs, Lhs); }
float4 DFMultiplyDemote(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const FDFVector4 P = DFTwoProduct(Lhs.High, Rhs.High);
	float4 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	const float4 S =   MakePrecise( ( P.High ) + ( T ) );
	return S;
}
float4 DFMultiplyDemote(FDFVector4 Lhs, float4 Rhs)
{
	FDFVector4 P = DFTwoProduct(Lhs.High, Rhs);
	P.Low =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	const float4 S =   MakePrecise( ( P.High ) + ( P.Low ) );
	return S;
}
float4 DFMultiplyDemote(float4 Lhs, FDFVector4 Rhs) { return DFMultiplyDemote(Rhs, Lhs); }
float4 DFMultiplyDemote(float4 Lhs, float4 Rhs) { return Lhs * Rhs; }
FDFVector4 DFFastDivide(FDFVector4 Lhs, FDFVector4 Rhs);
FDFVector4 DFFastDivide(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const float4 Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFVector4 R = DFMultiply(Rhs, Th);
	const float4 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float4 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float4 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float4 Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector4 DFFastDivide(FDFVector4 Lhs, float4 Rhs)
{
	const float4 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector4 R = DFTwoProduct(Rhs, Th);
	const float4 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float4 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float4 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float4 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector4 DFFastDivide(float4 Lhs, FDFVector4 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector4 DFFastDivide(float4 Lhs, float4 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector4 DFDivideByPow2(FDFVector4 Lhs, float4 Rhs)
{
	return MakeDFVector4(Lhs.High / Rhs, Lhs.Low / Rhs);
}
float4 DFFracDemote(FDFVector4 V)
{
	return frac(frac(V.High) + frac(V.Low));
}
float4 DFFmodByPow2Demote(FDFVector4 Lhs, float4 Rhs)
{
	return DFFracDemote(DFDivideByPow2(Lhs, Rhs)) * Rhs;
}
FDFVector4 DFBroadcast4(FDFScalar V)
{
	const float4 High = V.High;
	const float4 Low = V.Low;
	return MakeDFVector4(High, Low);
}
float4 DFBroadcast4(float V)
{
	const float4 Single = V;
	return Single;
}
float4  DFAddDemote (FDFScalar Lhs, FDFVector4 Rhs) { return DFAddDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFAddDemote (float Lhs, FDFVector4 Rhs) { return DFAddDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFAddDemote (FDFScalar Lhs, float4 Rhs) { return DFAddDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFAddDemote (float Lhs, float4 Rhs) { return DFAddDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFAddDemote (FDFVector4 Lhs, FDFScalar Rhs) { return DFAddDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFAddDemote (FDFVector4 Lhs, float Rhs)     { return DFAddDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFAddDemote (float4 Lhs, FDFScalar Rhs) { return DFAddDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFAddDemote (float4 Lhs, float Rhs) { return DFAddDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFFastAddDemote (FDFScalar Lhs, FDFVector4 Rhs) { return DFFastAddDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFFastAddDemote (float Lhs, FDFVector4 Rhs) { return DFFastAddDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFFastAddDemote (FDFScalar Lhs, float4 Rhs) { return DFFastAddDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFFastAddDemote (float Lhs, float4 Rhs) { return DFFastAddDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFFastAddDemote (FDFVector4 Lhs, FDFScalar Rhs) { return DFFastAddDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFFastAddDemote (FDFVector4 Lhs, float Rhs)     { return DFFastAddDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFFastAddDemote (float4 Lhs, FDFScalar Rhs) { return DFFastAddDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFFastAddDemote (float4 Lhs, float Rhs) { return DFFastAddDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFFastSubtractDemote (FDFScalar Lhs, FDFVector4 Rhs) { return DFFastSubtractDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFFastSubtractDemote (float Lhs, FDFVector4 Rhs) { return DFFastSubtractDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFFastSubtractDemote (FDFScalar Lhs, float4 Rhs) { return DFFastSubtractDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFFastSubtractDemote (float Lhs, float4 Rhs) { return DFFastSubtractDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFFastSubtractDemote (FDFVector4 Lhs, FDFScalar Rhs) { return DFFastSubtractDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFFastSubtractDemote (FDFVector4 Lhs, float Rhs)     { return DFFastSubtractDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFFastSubtractDemote (float4 Lhs, FDFScalar Rhs) { return DFFastSubtractDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFFastSubtractDemote (float4 Lhs, float Rhs) { return DFFastSubtractDemote (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (FDFScalar Lhs, FDFVector4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (float Lhs, FDFVector4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (FDFScalar Lhs, float4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (float Lhs, float4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (FDFVector4 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (FDFVector4 Lhs, float Rhs)     { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (float4 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (float4 Lhs, float Rhs) { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
float4  DFMultiplyDemote (FDFScalar Lhs, FDFVector4 Rhs) { return DFMultiplyDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFMultiplyDemote (float Lhs, FDFVector4 Rhs) { return DFMultiplyDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFMultiplyDemote (FDFScalar Lhs, float4 Rhs) { return DFMultiplyDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFMultiplyDemote (float Lhs, float4 Rhs) { return DFMultiplyDemote (DFBroadcast4(Lhs), Rhs); }
float4  DFMultiplyDemote (FDFVector4 Lhs, FDFScalar Rhs) { return DFMultiplyDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFMultiplyDemote (FDFVector4 Lhs, float Rhs)     { return DFMultiplyDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFMultiplyDemote (float4 Lhs, FDFScalar Rhs) { return DFMultiplyDemote (Lhs, DFBroadcast4(Rhs)); }
float4  DFMultiplyDemote (float4 Lhs, float Rhs) { return DFMultiplyDemote (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (FDFScalar Lhs, FDFVector4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (float Lhs, FDFVector4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (FDFScalar Lhs, float4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (float Lhs, float4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (FDFVector4 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (FDFVector4 Lhs, float Rhs)     { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (float4 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (float4 Lhs, float Rhs) { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4 DFDivideByPow2(FDFVector4 Lhs, float Rhs)
{
	float4 RhsVect = Rhs;
	return DFDivideByPow2(Lhs, RhsVect);
}
FDFVector4 MakeDFVector(FDFScalar    X, FDFScalar    Y, FDFScalar   Z, FDFScalar W) { return MakeDFVector4(float4(  X.High,   Y.High,  Z.High, W.High), float4(  X.Low,   Y.Low,  Z.Low, W.Low)); }
FDFVector4 MakeDFVector(FDFScalar    X, FDFScalar    Y, FDFVector2 ZW)              { return MakeDFVector4(float4(  X.High,   Y.High, ZW.High),         float4(  X.Low,   Y.Low, ZW.Low)); }
FDFVector4 MakeDFVector(FDFScalar    X, FDFVector2  YZ, FDFScalar   W)              { return MakeDFVector4(float4(  X.High,  YZ.High,  W.High),         float4(  X.Low,  YZ.Low,  W.Low)); }
FDFVector4 MakeDFVector(FDFVector2  XY, FDFScalar    Z, FDFScalar   W)              { return MakeDFVector4(float4( XY.High,   Z.High,  W.High),         float4( XY.Low,   Z.Low,  W.Low)); }
FDFVector4 MakeDFVector(FDFVector2  XY, FDFVector2  ZW)                             { return MakeDFVector4(float4( XY.High,  ZW.High),                  float4( XY.Low,  ZW.Low)); }
FDFVector4 MakeDFVector(FDFScalar    X, FDFVector3 YZW)                             { return MakeDFVector4(float4(  X.High, YZW.High),                  float4(  X.Low, YZW.Low)); }
FDFVector4 MakeDFVector(FDFVector3 XYZ, FDFScalar    W)                             { return MakeDFVector4(float4(XYZ.High,   W.High),                  float4(XYZ.Low,   W.Low)); }
FDFVector4 MakeDFVector(FDFVector3 In, float W) { return MakeDFVector4(float4(In.High, W), float4(In.Low, 0)); }
struct FDFMatrix
{
	float4x4 M;
	float3 PostTranslation; 
};
float4x4 Make4x3Matrix(float4x4 M)
{
	float4x4 Result;
	Result[0] = float4(M[0].xyz, 0.0f);
	Result[1] = float4(M[1].xyz, 0.0f);
	Result[2] = float4(M[2].xyz, 0.0f);
	Result[3] = float4(M[3].xyz, 1.0f);
	return Result;
}
float4x4 MakeTranslationMatrix(float3 Offset)
{
	float4x4 Result;
	Result[0] = float4(1.0f, 0.0f, 0.0f, 0.0f);
	Result[1] = float4(0.0f, 1.0f, 0.0f, 0.0f);
	Result[2] = float4(0.0f, 0.0f, 1.0f, 0.0f);
	Result[3] = float4(Offset, 1.0f);
	return Result;
}
FDFMatrix MakeDFMatrix4x3(float3 PostTranslation, float4x4 InMatrix)
{
	FDFMatrix Result;
	Result.PostTranslation = PostTranslation;
	Result.M = Make4x3Matrix(InMatrix);
	return Result;
}
FDFMatrix MakeDFMatrix(float3 PostTranslation, float4x4 InMatrix)
{
	FDFMatrix Result;
	Result.PostTranslation = PostTranslation;
	Result.M = InMatrix;
	return Result;
}
struct FDFInverseMatrix
{
	float4x4 M;
	float3 PreTranslation; 
	int Dummy; 
};
FDFInverseMatrix MakeDFInverseMatrix(float3 PreTranslation, float4x4 InMatrix)
{
	FDFInverseMatrix Result;
	Result.PreTranslation = PreTranslation;
	Result.M = InMatrix;
	Result.Dummy = 0;
	return Result;
}
FDFInverseMatrix MakeDFInverseMatrix4x3(float3 PreTranslation, float4x4 InMatrix)
{
	FDFInverseMatrix Result;
	Result.PreTranslation = PreTranslation;
	Result.M = Make4x3Matrix(InMatrix);
	Result.Dummy = 0;
	return Result;
}
FDFVector3 DFMultiply(float3 Vector, FDFMatrix InMatrix)
{
	float4 Result = mul(float4(Vector, 1), InMatrix.M);
	FDFVector3 V = DFTwoSum(InMatrix.PostTranslation, Result.xyz);
	return V;
}
FDFVector4 DFMultiply(float4 Vector, FDFMatrix InMatrix)
{
	float4 Result = mul(Vector, InMatrix.M);
	FDFVector4 V = DFTwoSum(float4(InMatrix.PostTranslation, 0), Result);
	return V;
}
float3 DFMultiplyDemote(FDFVector3 Vector, FDFInverseMatrix InMatrix)
{
	float3 V = DFFastSubtractDemote(Vector, InMatrix.PreTranslation);
	float4 Result = mul(float4(V, 1), InMatrix.M);
	return Result.xyz;
}
float4 DFMultiplyDemote(FDFVector4 Vector, FDFInverseMatrix InMatrix)
{
	float4 V = DFFastSubtractDemote(Vector, float4(InMatrix.PreTranslation, 0));
	return mul(V, InMatrix.M);
}
FDFInverseMatrix DFMultiply(FDFInverseMatrix Lhs, float4x4 Rhs)
{
	float4x4 M = mul(Lhs.M, Rhs);
	float3 PreTranslation = Lhs.PreTranslation;
	return MakeDFInverseMatrix(PreTranslation, M);
}
FDFMatrix DFMultiply(float4x4 Lhs, FDFMatrix Rhs)
{
	float4x4 M = mul(Lhs, Rhs.M);
	float3 PostTranslation = Rhs.PostTranslation;
	return MakeDFMatrix(PostTranslation, M);
}
float4x4 MultiplyTranslation(float4x4 M, float3 Translation)
{
	float4x4 Result = M;
	Result[3].xyz += Translation;
	return Result;
}
float4x4 MultiplyTranslation(float3 Translation, float4x4 M)
{
	return mul(MakeTranslationMatrix(Translation), M);
}
FDFMatrix DFPromote(FDFMatrix Value) { return Value; }
FDFMatrix  DFPromote(float4x4 Value) { return MakeDFMatrix((float3)0, Value); }
float4x4 DFDemote(FDFMatrix V)
{
	return MultiplyTranslation(V.M, V.PostTranslation);
}
float4x4 DFDemote(float4x4 V)
{
	return V;
}
float4x4 DFDemote(FDFInverseMatrix V)
{
	return MultiplyTranslation(-V.PreTranslation, V.M);
}
FDFVector3 DFMultiplyLHSAndFastTwoSum(float3 Lhs, float Factor, float3 Rhs)
{
	const float3 S =  MakePrecise(  mad( Lhs , Factor , Rhs ) );
	const float3 E =  MakePrecise( Rhs -  mad( -Lhs , Factor , S ) );
	return MakeDFVector3(S, E);
}
struct FLWCScalar
{
	float Tile;
	float Offset;
	int Dummy; 
};
struct FLWCVector2
{
	float2 Tile;
	float2 Offset;
	int Dummy; 
};
struct FLWCVector3
{
	float3 Tile;
	float3 Offset;
	int Dummy; 
};
struct FLWCVector4
{
	float4 Tile;
	float4 Offset;
	int Dummy; 
};
struct FLWCMatrix
{
	float4x4 M;
	float3 Tile; 
	int2 Dummy; 
};
struct FLWCInverseMatrix
{
	float4x4 M;
	float3 Tile; 
	int3 Dummy; 
};
float LWCGetTileOffset(FLWCScalar V) { return  (( V ).Tile) * 2097152.00f; }
float2 LWCGetTileOffset(FLWCVector2 V) { return  (( V ).Tile) * 2097152.00f; }
float3 LWCGetTileOffset(FLWCVector3 V) { return  (( V ).Tile) * 2097152.00f; }
float4 LWCGetTileOffset(FLWCVector4 V) { return  (( V ).Tile) * 2097152.00f; }
float3 LWCGetTileOffset(FLWCMatrix V) { return  (( V ).Tile) * 2097152.00f; }
float3 LWCGetTileOffset(FLWCInverseMatrix V) { return  (( V ).Tile) * 2097152.00f; }
FLWCScalar MakeLWCScalar(float Tile, float Offset)
{
	FLWCScalar Result;
	 ( Result ).Tile = ( Tile );
	Result.Offset = Offset;
	Result.Dummy = 0;
	return Result;
}
FLWCVector2 MakeLWCVector2(float2 Tile, float2 Offset)
{
	FLWCVector2 Result;
	 ( Result ).Tile = ( Tile );
	Result.Offset = Offset;
	Result.Dummy = 0;
	return Result;
}
FLWCVector3 MakeLWCVector3(float3 Tile, float3 Offset)
{
	FLWCVector3 Result;
	 ( Result ).Tile = ( Tile );
	Result.Offset = Offset;
	Result.Dummy = 0;
	return Result;
}
FLWCVector4 MakeLWCVector4(float4 Tile, float4 Offset)
{
	FLWCVector4 Result;
	 ( Result ).Tile = ( Tile );
	Result.Offset = Offset;
	Result.Dummy = 0;
	return Result;
}
FLWCVector4 MakeLWCVector4(float3 Tile, float4 Offset)
{
	return MakeLWCVector4(float4(Tile, 0), Offset);
}
FLWCVector4 MakeLWCVector4(FLWCVector3 XYZ, float W)
{
	return MakeLWCVector4( (( XYZ ).Tile), float4(XYZ.Offset, W));
}
FLWCScalar MakeLWCVector(FLWCScalar X) { return X; }
FLWCVector2 MakeLWCVector(FLWCScalar X, FLWCScalar Y) { return MakeLWCVector2(float2( (( X ).Tile),  (( Y ).Tile)), float2(X.Offset, Y.Offset)); }
FLWCVector3 MakeLWCVector(FLWCScalar X, FLWCScalar Y, FLWCScalar Z) { return MakeLWCVector3(float3( (( X ).Tile),  (( Y ).Tile),  (( Z ).Tile)), float3(X.Offset, Y.Offset, Z.Offset)); }
FLWCVector3 MakeLWCVector(FLWCScalar X, FLWCVector2 YZ) { return MakeLWCVector3(float3( (( X ).Tile),  (( YZ ).Tile)), float3(X.Offset, YZ.Offset)); }
FLWCVector3 MakeLWCVector(FLWCVector2 XY, FLWCScalar Z) { return MakeLWCVector3(float3( (( XY ).Tile),  (( Z ).Tile)), float3(XY.Offset, Z.Offset)); }
FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCScalar Y, FLWCScalar Z, FLWCScalar W) { return MakeLWCVector4(float4( (( X ).Tile),  (( Y ).Tile),  (( Z ).Tile),  (( W ).Tile)), float4(X.Offset, Y.Offset, Z.Offset, W.Offset)); }
FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCScalar Y, FLWCVector2 ZW) { return MakeLWCVector4(float4( (( X ).Tile),  (( Y ).Tile),  (( ZW ).Tile)), float4(X.Offset, Y.Offset, ZW.Offset)); }
FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCVector2 YZ, FLWCScalar W) { return MakeLWCVector4(float4( (( X ).Tile),  (( YZ ).Tile),  (( W ).Tile)), float4(X.Offset, YZ.Offset, W.Offset)); }
FLWCVector4 MakeLWCVector(FLWCVector2 XY, FLWCScalar Z, FLWCScalar W) { return MakeLWCVector4(float4( (( XY ).Tile),  (( Z ).Tile),  (( W ).Tile)), float4(XY.Offset, Z.Offset, W.Offset)); }
FLWCVector4 MakeLWCVector(FLWCVector2 XY, FLWCVector2 ZW) { return MakeLWCVector4(float4( (( XY ).Tile),  (( ZW ).Tile)), float4(XY.Offset, ZW.Offset)); }
FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCVector3 YZW) { return MakeLWCVector4(float4( (( X ).Tile),  (( YZW ).Tile)), float4(X.Offset, YZW.Offset)); }
FLWCVector4 MakeLWCVector(FLWCVector3 XYZ, FLWCScalar W) { return MakeLWCVector4(float4( (( XYZ ).Tile),  (( W ).Tile)), float4(XYZ.Offset, W.Offset)); }
FLWCMatrix MakeLWCMatrix(float3 Tile, float4x4 InMatrix)
{
	FLWCMatrix Result;
	 ( Result ).Tile = ( Tile );
	Result.M = InMatrix;
	Result.Dummy = 0;
	return Result;
}
FLWCInverseMatrix MakeLWCInverseMatrix(float3 Tile, float4x4 InMatrix)
{
	FLWCInverseMatrix Result;
	 ( Result ).Tile = ( -Tile );
	Result.M = InMatrix;
	Result.Dummy = 0;
	return Result;
}
FLWCScalar LWCGetComponent(FLWCScalar V, int C) { return V; }
FLWCScalar LWCGetComponent(FLWCVector2 V, int C) { return MakeLWCScalar( (( V ).Tile)[C], V.Offset[C]); }
FLWCScalar LWCGetComponent(FLWCVector3 V, int C) { return MakeLWCScalar( (( V ).Tile)[C], V.Offset[C]); }
FLWCScalar LWCGetComponent(FLWCVector4 V, int C) { return MakeLWCScalar( (( V ).Tile)[C], V.Offset[C]); }
float LWCToFloat(FLWCScalar Value)   { return LWCGetTileOffset(Value) + Value.Offset; }
float2 LWCToFloat(FLWCVector2 Value) { return LWCGetTileOffset(Value) + Value.Offset; }
float3 LWCToFloat(FLWCVector3 Value) { return LWCGetTileOffset(Value) + Value.Offset; }
float4 LWCToFloat(FLWCVector4 Value) { return LWCGetTileOffset(Value) + Value.Offset; }
float4x4 LWCToFloat(FLWCMatrix Value)
{
	float4x4 Result = Value.M;
	Result[3].xyz = LWCGetTileOffset(Value) + Result[3].xyz;
	return Result;
}
float4x4 LWCToFloat(FLWCInverseMatrix Value)
{
	float4x4 TileOffset = MakeTranslationMatrix(LWCGetTileOffset(Value));
	return mul(TileOffset, Value.M);
}
float LWCToFloat(float Value) { return Value; }
float2 LWCToFloat(float2 Value) { return Value; }
float3 LWCToFloat(float3 Value) { return Value; }
float4 LWCToFloat(float4 Value) { return Value; }
float4x4 LWCToFloat(float4x4 Value) { return Value; }
FLWCVector3 LWCMultiply(float3 Position, FLWCMatrix InMatrix)
{
	float3 Offset = (Position.xxx * InMatrix.M[0].xyz + Position.yyy * InMatrix.M[1].xyz + Position.zzz * InMatrix.M[2].xyz) + InMatrix.M[3].xyz;
	return MakeLWCVector3( (( InMatrix ).Tile), Offset);
}
FLWCVector4 LWCMultiply(float4 Position, FLWCMatrix InMatrix)
{
	float4 Offset = mul(Position, InMatrix.M);
	return MakeLWCVector4( (( InMatrix ).Tile), Offset);
}
float3 LWCMultiply(FLWCVector3 Position, FLWCInverseMatrix InMatrix)
{
	float3 LocalPosition = LWCToFloat(MakeLWCVector3( (( Position ).Tile) +  (( InMatrix ).Tile), Position.Offset));
	return (LocalPosition.xxx * InMatrix.M[0].xyz + LocalPosition.yyy * InMatrix.M[1].xyz + LocalPosition.zzz * InMatrix.M[2].xyz) + InMatrix.M[3].xyz;
}
float4 LWCMultiply(FLWCVector4 Position, FLWCInverseMatrix InMatrix)
{
	float4 LocalPosition = LWCToFloat(MakeLWCVector4( (( Position ).Tile) + float4( (( InMatrix ).Tile), 0), Position.Offset));
	return mul(LocalPosition, InMatrix.M);
}
FLWCMatrix LWCMultiply(float4x4 Lhs, FLWCMatrix Rhs)
{
	float4x4 ResultMatrix = mul(Lhs, Rhs.M);
	return MakeLWCMatrix( (( Rhs ).Tile), ResultMatrix);
}
FLWCInverseMatrix LWCMultiply(FLWCInverseMatrix Lhs, float4x4 Rhs)
{
	float4x4 ResultMatrix = mul(Lhs.M, Rhs);
	return MakeLWCInverseMatrix(- (( Lhs ).Tile), ResultMatrix);
}
float4x4 LWCMultiply(FLWCMatrix Lhs, FLWCInverseMatrix Rhs)
{
	float4x4 Result = Lhs.M;
	Result = mul(Result, MakeTranslationMatrix(( (( Lhs ).Tile) +  (( Rhs ).Tile)) * 2097152.00f));
	Result = mul(Result, Rhs.M);
	return Result;
}
FLWCScalar LWCNormalizeTile(FLWCScalar V)
{
	float IntTile = floor(V.Tile + (V.Offset * 4.76837158e-07f + 0.5f));
	return MakeLWCScalar(IntTile, (V.Tile - IntTile) * 2097152.00f + V.Offset);
}
FLWCScalar LWCAdd(FLWCScalar Lhs, FLWCScalar Rhs) { return MakeLWCScalar( (( Lhs ).Tile) +  (( Rhs ).Tile), Lhs.Offset + Rhs.Offset); }
FLWCScalar LWCAdd(float Lhs, FLWCScalar Rhs) { return MakeLWCScalar( (( Rhs ).Tile), Lhs + Rhs.Offset); }
FLWCScalar LWCAdd(FLWCScalar Lhs, float Rhs) { return MakeLWCScalar( (( Lhs ).Tile), Lhs.Offset + Rhs); }
FLWCScalar LWCSubtract(FLWCScalar Lhs, FLWCScalar Rhs) { return MakeLWCScalar( (( Lhs ).Tile) -  (( Rhs ).Tile), Lhs.Offset - Rhs.Offset); }
FLWCScalar LWCSubtract(float Lhs, FLWCScalar Rhs) { return MakeLWCScalar(- (( Rhs ).Tile), Lhs - Rhs.Offset); }
FLWCScalar LWCSubtract(FLWCScalar Lhs, float Rhs) { return MakeLWCScalar( (( Lhs ).Tile), Lhs.Offset - Rhs); }
FLWCScalar LWCMultiply(FLWCScalar Lhs, FLWCScalar Rhs)
{
	return MakeLWCScalar( (( Lhs ).Tile) * ( (( Rhs ).Tile) * 2097152.00f + Rhs.Offset) +  (( Rhs ).Tile) * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCScalar LWCMultiply(float Lhs, FLWCScalar Rhs) { return MakeLWCScalar( (( Rhs ).Tile) * Lhs, Lhs * Rhs.Offset); }
FLWCScalar LWCMultiply(FLWCScalar Lhs, float Rhs) { return MakeLWCScalar( (( Lhs ).Tile) * Rhs, Lhs.Offset * Rhs); }
FLWCVector2 LWCNormalizeTile(FLWCVector2 V)
{
	float2 IntTile = floor(V.Tile + (V.Offset * 4.76837158e-07f + 0.5f));
	return MakeLWCVector2(IntTile, (V.Tile - IntTile) * 2097152.00f + V.Offset);
}
FLWCVector2 LWCAdd(FLWCVector2 Lhs, FLWCVector2 Rhs) { return MakeLWCVector2( (( Lhs ).Tile) +  (( Rhs ).Tile), Lhs.Offset + Rhs.Offset); }
FLWCVector2 LWCAdd(float2 Lhs, FLWCVector2 Rhs) { return MakeLWCVector2( (( Rhs ).Tile), Lhs + Rhs.Offset); }
FLWCVector2 LWCAdd(FLWCVector2 Lhs, float2 Rhs) { return MakeLWCVector2( (( Lhs ).Tile), Lhs.Offset + Rhs); }
FLWCVector2 LWCSubtract(FLWCVector2 Lhs, FLWCVector2 Rhs) { return MakeLWCVector2( (( Lhs ).Tile) -  (( Rhs ).Tile), Lhs.Offset - Rhs.Offset); }
FLWCVector2 LWCSubtract(float2 Lhs, FLWCVector2 Rhs) { return MakeLWCVector2(- (( Rhs ).Tile), Lhs - Rhs.Offset); }
FLWCVector2 LWCSubtract(FLWCVector2 Lhs, float2 Rhs) { return MakeLWCVector2( (( Lhs ).Tile), Lhs.Offset - Rhs); }
FLWCVector2 LWCMultiply(FLWCVector2 Lhs, FLWCVector2 Rhs)
{
	return MakeLWCVector2( (( Lhs ).Tile) * ( (( Rhs ).Tile) * 2097152.00f + Rhs.Offset) +  (( Rhs ).Tile) * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCVector2 LWCMultiply(float2 Lhs, FLWCVector2 Rhs) { return MakeLWCVector2( (( Rhs ).Tile) * Lhs, Lhs * Rhs.Offset); }
FLWCVector2 LWCMultiply(FLWCVector2 Lhs, float2 Rhs) { return MakeLWCVector2( (( Lhs ).Tile) * Rhs, Lhs.Offset * Rhs); }
FLWCVector3 LWCNormalizeTile(FLWCVector3 V)
{
	float3 IntTile = floor(V.Tile + (V.Offset * 4.76837158e-07f + 0.5f));
	return MakeLWCVector3(IntTile, (V.Tile - IntTile) * 2097152.00f + V.Offset);
}
FLWCVector3 LWCAdd(FLWCVector3 Lhs, FLWCVector3 Rhs) { return MakeLWCVector3( (( Lhs ).Tile) +  (( Rhs ).Tile), Lhs.Offset + Rhs.Offset); }
FLWCVector3 LWCAdd(float3 Lhs, FLWCVector3 Rhs) { return MakeLWCVector3( (( Rhs ).Tile), Lhs + Rhs.Offset); }
FLWCVector3 LWCAdd(FLWCVector3 Lhs, float3 Rhs) { return MakeLWCVector3( (( Lhs ).Tile), Lhs.Offset + Rhs); }
FLWCVector3 LWCSubtract(FLWCVector3 Lhs, FLWCVector3 Rhs) { return MakeLWCVector3( (( Lhs ).Tile) -  (( Rhs ).Tile), Lhs.Offset - Rhs.Offset); }
FLWCVector3 LWCSubtract(float3 Lhs, FLWCVector3 Rhs) { return MakeLWCVector3(- (( Rhs ).Tile), Lhs - Rhs.Offset); }
FLWCVector3 LWCSubtract(FLWCVector3 Lhs, float3 Rhs) { return MakeLWCVector3( (( Lhs ).Tile), Lhs.Offset - Rhs); }
FLWCVector3 LWCMultiply(FLWCVector3 Lhs, FLWCVector3 Rhs)
{
	return MakeLWCVector3( (( Lhs ).Tile) * ( (( Rhs ).Tile) * 2097152.00f + Rhs.Offset) +  (( Rhs ).Tile) * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCVector3 LWCMultiply(float3 Lhs, FLWCVector3 Rhs) { return MakeLWCVector3( (( Rhs ).Tile) * Lhs, Lhs * Rhs.Offset); }
FLWCVector3 LWCMultiply(FLWCVector3 Lhs, float3 Rhs) { return MakeLWCVector3( (( Lhs ).Tile) * Rhs, Lhs.Offset * Rhs); }
FLWCVector4 LWCNormalizeTile(FLWCVector4 V)
{
	float4 IntTile = floor(V.Tile + (V.Offset * 4.76837158e-07f + 0.5f));
	return MakeLWCVector4(IntTile, (V.Tile - IntTile) * 2097152.00f + V.Offset);
}
FLWCVector4 LWCAdd(FLWCVector4 Lhs, FLWCVector4 Rhs) { return MakeLWCVector4( (( Lhs ).Tile) +  (( Rhs ).Tile), Lhs.Offset + Rhs.Offset); }
FLWCVector4 LWCAdd(float4 Lhs, FLWCVector4 Rhs) { return MakeLWCVector4( (( Rhs ).Tile), Lhs + Rhs.Offset); }
FLWCVector4 LWCAdd(FLWCVector4 Lhs, float4 Rhs) { return MakeLWCVector4( (( Lhs ).Tile), Lhs.Offset + Rhs); }
FLWCVector4 LWCSubtract(FLWCVector4 Lhs, FLWCVector4 Rhs) { return MakeLWCVector4( (( Lhs ).Tile) -  (( Rhs ).Tile), Lhs.Offset - Rhs.Offset); }
FLWCVector4 LWCSubtract(float4 Lhs, FLWCVector4 Rhs) { return MakeLWCVector4(- (( Rhs ).Tile), Lhs - Rhs.Offset); }
FLWCVector4 LWCSubtract(FLWCVector4 Lhs, float4 Rhs) { return MakeLWCVector4( (( Lhs ).Tile), Lhs.Offset - Rhs); }
FLWCVector4 LWCMultiply(FLWCVector4 Lhs, FLWCVector4 Rhs)
{
	return MakeLWCVector4( (( Lhs ).Tile) * ( (( Rhs ).Tile) * 2097152.00f + Rhs.Offset) +  (( Rhs ).Tile) * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCVector4 LWCMultiply(float4 Lhs, FLWCVector4 Rhs) { return MakeLWCVector4( (( Rhs ).Tile) * Lhs, Lhs * Rhs.Offset); }
FLWCVector4 LWCMultiply(FLWCVector4 Lhs, float4 Rhs) { return MakeLWCVector4( (( Lhs ).Tile) * Rhs, Lhs.Offset * Rhs); }
FLWCScalar DFToTileOffset( FDFScalar In)																								{ float Tile =  MakePrecise( round(In.High / 2097152.00f) ); float Offset =   MakePrecise( (   MakePrecise(  mad( ( Tile ) , ( -2097152.00f ) , ( In.High ) ) ) ) + ( In.Low ) );																																								return MakeLWCScalar (Tile, Offset);																						}
FLWCVector2 DFToTileOffset( FDFVector2 In)																								{ float2 Tile =  MakePrecise( round(In.High / 2097152.00f) ); float2 Offset =   MakePrecise( (   MakePrecise(  mad( ( Tile ) , ( -2097152.00f ) , ( In.High ) ) ) ) + ( In.Low ) );																																								return MakeLWCVector2 (Tile, Offset);																						}
FLWCVector3 DFToTileOffset( FDFVector3 In)																								{ float3 Tile =  MakePrecise( round(In.High / 2097152.00f) ); float3 Offset =   MakePrecise( (   MakePrecise(  mad( ( Tile ) , ( -2097152.00f ) , ( In.High ) ) ) ) + ( In.Low ) );																																								return MakeLWCVector3 (Tile, Offset);																						}
FLWCVector4 DFToTileOffset( FDFVector4 In)																								{ float4 Tile =  MakePrecise( round(In.High / 2097152.00f) ); float4 Offset =   MakePrecise( (   MakePrecise(  mad( ( Tile ) , ( -2097152.00f ) , ( In.High ) ) ) ) + ( In.Low ) );																																								return MakeLWCVector4 (Tile, Offset);																						}
FLWCScalar DFFastToTileOffset( FDFScalar In)																							{ float Tile = In.High * (1 / 2097152.00f); float Offset = In.Low; 																																																									return MakeLWCScalar (Tile, Offset);																						}
FLWCVector2 DFFastToTileOffset( FDFVector2 In)																							{ float2 Tile = In.High * (1 / 2097152.00f); float2 Offset = In.Low; 																																																									return MakeLWCVector2 (Tile, Offset);																						}
FLWCVector3 DFFastToTileOffset( FDFVector3 In)																							{ float3 Tile = In.High * (1 / 2097152.00f); float3 Offset = In.Low; 																																																									return MakeLWCVector3 (Tile, Offset);																						}
FLWCVector4 DFFastToTileOffset( FDFVector4 In)																							{ float4 Tile = In.High * (1 / 2097152.00f); float4 Offset = In.Low; 																																																									return MakeLWCVector4 (Tile, Offset);																						}
FLWCMatrix DFToTileOffset(FDFMatrix In)
{
	FLWCVector3 PosHigh = DFToTileOffset(MakeDFVector3(In.PostTranslation, 0));
	float4x4 M = MultiplyTranslation(In.M, PosHigh.Offset);
	float3 Tile = PosHigh.Tile;
	return MakeLWCMatrix(Tile, M);
}
FLWCMatrix DFFastToTileOffset(FDFMatrix In)
{
	float4x4 M = In.M;
	float3 Tile = In.PostTranslation / 2097152.00f;
	return MakeLWCMatrix(Tile, M);
}
FLWCInverseMatrix DFToTileOffset(FDFInverseMatrix In)
{
	FLWCVector3 PosHigh = DFToTileOffset(MakeDFVector3(In.PreTranslation, 0));
	float4x4 M = MultiplyTranslation(-PosHigh.Offset, In.M);
	float3 Tile = PosHigh.Tile;
	return MakeLWCInverseMatrix(Tile, M);
}
FLWCInverseMatrix DFFastToTileOffset(FDFInverseMatrix In)
{
	float4x4 M = In.M;
	float3 Tile = In.PreTranslation / 2097152.00f;
	return MakeLWCInverseMatrix(Tile, M);
}
FDFScalar DFFromTileOffset(FLWCScalar In)
{
	float TileOffset = In.Tile * 2097152.00f;
	return DFFastTwoSum(TileOffset, In.Offset);
}
FDFVector2 DFFromTileOffset(FLWCVector2 In)
{
	float2 TileOffset = In.Tile * 2097152.00f;
	return DFFastTwoSum(TileOffset, In.Offset);
}
FDFVector3 DFFromTileOffset(FLWCVector3 In)
{
	float3 TileOffset = In.Tile * 2097152.00f;
	return DFFastTwoSum(TileOffset, In.Offset);
}
FDFVector4 DFFromTileOffset(FLWCVector4 In)
{
	float4 TileOffset = In.Tile * 2097152.00f;
	return DFFastTwoSum(TileOffset, In.Offset);
}
FDFMatrix DFFromTileOffset(FLWCMatrix In)
{
	float4x4 M = In.M;
	float3 PostTranslation = In.Tile * 2097152.00f;
	return MakeDFMatrix(PostTranslation, M);
}
FDFInverseMatrix DFFromTileOffset(FLWCInverseMatrix In)
{
	float4x4 M = In.M;
	float3 PreTranslation = -In.Tile * 2097152.00f;
	return MakeDFInverseMatrix(PreTranslation, M);
}
float LWCToFloat(FDFScalar Value)   { return DFDemote(Value); }
float2 LWCToFloat(FDFVector2 Value) { return DFDemote(Value); }
float3 LWCToFloat(FDFVector3 Value) { return DFDemote(Value); }
float4 LWCToFloat(FDFVector4 Value) { return DFDemote(Value); }
float4x4 LWCToFloat(FDFMatrix Value) { return DFDemote(Value); }
float4x4 LWCToFloat(FDFInverseMatrix Value) { return DFDemote(Value); }
struct FLightSceneData
{
	FDFVector3 WorldPosition;
	float InvRadius;
	float FalloffExponent;
	float4 Color;
	float3 Direction;
	float SpecularScale;
	float3 Tangent;
	float SourceRadius;
	float2 SpotAngles;
	float SoftSourceRadius;
	float SourceLength;
	float RectLightBarnCosAngle;
	float RectLightBarnLength;
	float2 RectLightAtlasUVOffset;
	float2 RectLightAtlasUVScale;
	float RectLightAtlasMaxLevel;
	float InverseExposureBlend;
	float IESAtlasIndex;
	uint LightTypeAndShadowMapChannelMaskPacked;
	float2 Padding;
};
struct FViewConstants {
	 float4x4    TranslatedWorldToClip ;
	 float4x4    RelativeWorldToClip ;
	 float4x4    ClipToRelativeWorld ;
	 float4x4    TranslatedWorldToView ;
	 float4x4    ViewToTranslatedWorld ;
	 float4x4    TranslatedWorldToCameraView ;
	 float4x4    CameraViewToTranslatedWorld ;
	 float4x4    ViewToClip ;
	 float4x4    ViewToClipNoAA ;
	 float4x4    ClipToView ;
	 float4x4    ClipToTranslatedWorld ;
	 float4x4    SVPositionToTranslatedWorld ;
	 float4x4    ScreenToRelativeWorld ;
	 float4x4    ScreenToTranslatedWorld ;
	 float4x4    MobileMultiviewShadowTransform ;
	 float3    ViewOriginHigh ;
	 float    Padding972 ;
	 float3    ViewForward ;
	 float    Padding988 ;
	 float3    ViewUp ;
	 float    Padding1004 ;
	 float3    ViewRight ;
	 float    Padding1020 ;
	 float3    HMDViewNoRollUp ;
	 float    Padding1036 ;
	 float3    HMDViewNoRollRight ;
	 float    Padding1052 ;
	 float4    InvDeviceZToWorldZTransform ;
	 float4    ScreenPositionScaleBias ;
	 float3    ViewOriginLow ;
	 float    Padding1100 ;
	 float3    TranslatedWorldCameraOrigin ;
	 float    Padding1116 ;
	 float3    WorldViewOriginHigh ;
	 float    Padding1132 ;
	 float3    WorldViewOriginLow ;
	 float    Padding1148 ;
	 float3    PreViewTranslationHigh ;
	 float    Padding1164 ;
	 float3    PreViewTranslationLow ;
	 float    Padding1180 ;
	 float4x4    PrevViewToClip ;
	 float4x4    PrevClipToView ;
	 float4x4    PrevTranslatedWorldToClip ;
	 float4x4    PrevTranslatedWorldToView ;
	 float4x4    PrevViewToTranslatedWorld ;
	 float4x4    PrevTranslatedWorldToCameraView ;
	 float4x4    PrevCameraViewToTranslatedWorld ;
	 float3    PrevTranslatedWorldCameraOrigin ;
	 float    Padding1644 ;
	 float3    PrevWorldCameraOriginHigh ;
	 float    Padding1660 ;
	 float3    PrevWorldCameraOriginLow ;
	 float    Padding1676 ;
	 float3    PrevWorldViewOriginHigh ;
	 float    Padding1692 ;
	 float3    PrevWorldViewOriginLow ;
	 float    Padding1708 ;
	 float3    PrevPreViewTranslationHigh ;
	 float    Padding1724 ;
	 float3    PrevPreViewTranslationLow ;
	 float    Padding1740 ;
	 float3    ViewTilePosition ;
	 float    Padding1756 ;
	 float3    RelativeWorldCameraOriginTO ;
	 float    Padding1772 ;
	 float3    RelativeWorldViewOriginTO ;
	 float    Padding1788 ;
	 float3    RelativePreViewTranslationTO ;
	 float    Padding1804 ;
	 float3    PrevRelativeWorldCameraOriginTO ;
	 float    Padding1820 ;
	 float3    PrevRelativeWorldViewOriginTO ;
	 float    Padding1836 ;
	 float3    RelativePrevPreViewTranslationTO ;
	 float    Padding1852 ;
	 float4x4    PrevClipToRelativeWorld ;
	 float4x4    PrevScreenToTranslatedWorld ;
	 float4x4    ClipToPrevClip ;
	 float4x4    ClipToPrevClipWithAA ;
	 float4    TemporalAAJitter ;
	 float4    GlobalClippingPlane ;
	 float2    FieldOfViewWideAngles ;
	 float2    PrevFieldOfViewWideAngles ;
	 float4    ViewRectMin ;
	 float4    ViewSizeAndInvSize ;
	 uint4    ViewRectMinAndSize ;
	 float4    LightProbeSizeRatioAndInvSizeRatio ;
	 float4    BufferSizeAndInvSize ;
	 float4    BufferBilinearUVMinMax ;
	 float4    ScreenToViewSpace ;
	 float2    BufferToSceneTextureScale ;
	 float2    ResolutionFractionAndInv ;
	 int    NumSceneColorMSAASamples ;
	 float    ProjectionDepthThicknessScale ;
	 float    PreExposure ;
	 float    OneOverPreExposure ;
	 float4    DiffuseOverrideParameter ;
	 float4    SpecularOverrideParameter ;
	 float4    NormalOverrideParameter ;
	 float2    RoughnessOverrideParameter ;
	 float    PrevFrameGameTime ;
	 float    PrevFrameRealTime ;
	 float    OutOfBoundsMask ;
	 float    Padding2372 ;
	 float    Padding2376 ;
	 float    Padding2380 ;
	 float3    WorldCameraMovementSinceLastFrame ;
	 float    CullingSign ;
	 float    NearPlane ;
	 float    GameTime ;
	 float    RealTime ;
	 float    DeltaTime ;
	 float    MaterialTextureMipBias ;
	 float    MaterialTextureDerivativeMultiply ;
	 uint    Random ;
	 uint    FrameNumber ;
	 uint    FrameCounter ;
	 uint    StateFrameIndexMod8 ;
	 uint    StateFrameIndex ;
	 uint    DebugViewModeMask ;
	 uint    WorldIsPaused ;
	 float    CameraCut ;
	 float    UnlitViewmodeMask ;
	 float    Padding2460 ;
	 float4    DirectionalLightColor ;
	 float3    DirectionalLightDirection ;
	 float    Padding2492 ;
	 float4    TranslucencyLightingVolumeMin[2] ;
	 float4    TranslucencyLightingVolumeInvSize[2] ;
	 float4    TemporalAAParams ;
	 float4    CircleDOFParams ;
	 float    DepthOfFieldSensorWidth ;
	 float    DepthOfFieldFocalDistance ;
	 float    DepthOfFieldScale ;
	 float    DepthOfFieldFocalLength ;
	 float    DepthOfFieldFocalRegion ;
	 float    DepthOfFieldNearTransitionRegion ;
	 float    DepthOfFieldFarTransitionRegion ;
	 float    MotionBlurNormalizedToPixel ;
	 float    GeneralPurposeTweak ;
	 float    GeneralPurposeTweak2 ;
	 float    DemosaicVposOffset ;
	 float    DecalDepthBias ;
	 float3    IndirectLightingColorScale ;
	 float    Padding2652 ;
	 float3    PrecomputedIndirectLightingColorScale ;
	 float    Padding2668 ;
	 float3    PrecomputedIndirectSpecularColorScale ;
	 float    Padding2684 ;
	 float4    AtmosphereLightDirection[2] ;
	 float4    AtmosphereLightIlluminanceOnGroundPostTransmittance[2] ;
	 float4    AtmosphereLightIlluminanceOuterSpace[2] ;
	 float4    AtmosphereLightDiscLuminance[2] ;
	 float4    AtmosphereLightDiscCosHalfApexAngle_PPTrans[2] ;
	 float4    SkyViewLutSizeAndInvSize ;
	 float3    SkyCameraTranslatedWorldOrigin ;
	 float    Padding2876 ;
	 float4    SkyPlanetTranslatedWorldCenterAndViewHeight ;
	 float4x4    SkyViewLutReferential ;
	 float4    SkyAtmosphereSkyLuminanceFactor ;
	 float    SkyAtmospherePresentInScene ;
	 float    SkyAtmosphereHeightFogContribution ;
	 float    SkyAtmosphereBottomRadiusKm ;
	 float    SkyAtmosphereTopRadiusKm ;
	 float4    SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize ;
	 float    SkyAtmosphereAerialPerspectiveStartDepthKm ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv ;
	 float    SkyAtmosphereApplyCameraAerialPerspectiveVolume ;
	 float    Padding3032 ;
	 float    Padding3036 ;
	 float3    NormalCurvatureToRoughnessScaleBias ;
	 float    RenderingReflectionCaptureMask ;
	 float    RealTimeReflectionCapture ;
	 float    RealTimeReflectionCapturePreExposure ;
	 float    Padding3064 ;
	 float    Padding3068 ;
	 float4    AmbientCubemapTint ;
	 float    AmbientCubemapIntensity ;
	 float    SkyLightApplyPrecomputedBentNormalShadowingFlag ;
	 float    SkyLightAffectReflectionFlag ;
	 float    SkyLightAffectGlobalIlluminationFlag ;
	 float4    SkyLightColor ;
	 float    SkyLightVolumetricScatteringIntensity ;
	 float    Padding3124 ;
	 float    Padding3128 ;
	 float    Padding3132 ;
	 float4    MobileSkyIrradianceEnvironmentMap[8] ;
	 float    MobilePreviewMode ;
	 float    HMDEyePaddingOffset ;
	 float    ReflectionCubemapMaxMip ;
	 float    ShowDecalsMask ;
	 uint    DistanceFieldAOSpecularOcclusionMode ;
	 float    IndirectCapsuleSelfShadowingIntensity ;
	 float    Padding3288 ;
	 float    Padding3292 ;
	 float3    ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight ;
	 int    StereoPassIndex ;
	 float4    GlobalVolumeTranslatedCenterAndExtent[6] ;
	 float4    GlobalVolumeTranslatedWorldToUVAddAndMul[6] ;
	 float4    GlobalDistanceFieldMipTranslatedWorldToUVScale[6] ;
	 float4    GlobalDistanceFieldMipTranslatedWorldToUVBias[6] ;
	 float    GlobalDistanceFieldMipFactor ;
	 float    GlobalDistanceFieldMipTransition ;
	 int    GlobalDistanceFieldClipmapSizeInPages ;
	 int    Padding3708 ;
	 float3    GlobalDistanceFieldInvPageAtlasSize ;
	 float    Padding3724 ;
	 float3    GlobalDistanceFieldInvCoverageAtlasSize ;
	 float    GlobalVolumeDimension ;
	 float    GlobalVolumeTexelSize ;
	 float    MaxGlobalDFAOConeDistance ;
	 uint    NumGlobalSDFClipmaps ;
	 float    CoveredExpandSurfaceScale ;
	 float    NotCoveredExpandSurfaceScale ;
	 float    NotCoveredMinStepScale ;
	 float    DitheredTransparencyStepThreshold ;
	 float    DitheredTransparencyTraceThreshold ;
	 int2    CursorPosition ;
	 float    bCheckerboardSubsurfaceProfileRendering ;
	 float    Padding3788 ;
	 float3    VolumetricFogInvGridSize ;
	 float    Padding3804 ;
	 float3    VolumetricFogGridZParams ;
	 float    Padding3820 ;
	 float2    VolumetricFogSVPosToVolumeUV ;
	 float2    VolumetricFogViewGridUVToPrevViewRectUV ;
	 float2    VolumetricFogPrevViewGridRectUVToResourceUV ;
	 float2    VolumetricFogPrevUVMax ;
	 float2    VolumetricFogPrevUVMaxForTemporalBlend ;
	 float2    VolumetricFogScreenToResourceUV ;
	 float2    VolumetricFogUVMax ;
	 float    VolumetricFogMaxDistance ;
	 float    Padding3884 ;
	 float3    VolumetricLightmapWorldToUVScale ;
	 float    Padding3900 ;
	 float3    VolumetricLightmapWorldToUVAdd ;
	 float    Padding3916 ;
	 float3    VolumetricLightmapIndirectionTextureSize ;
	 float    VolumetricLightmapBrickSize ;
	 float3    VolumetricLightmapBrickTexelSize ;
	 float    IndirectLightingCacheShowFlag ;
	 float    EyeToPixelSpreadAngle ;
	 float    Padding3956 ;
	 float    Padding3960 ;
	 float    Padding3964 ;
	 float4    XRPassthroughCameraUVs[2] ;
	 float    GlobalVirtualTextureMipBias ;
	 uint    VirtualTextureFeedbackShift ;
	 uint    VirtualTextureFeedbackMask ;
	 uint    VirtualTextureFeedbackStride ;
	 uint    VirtualTextureFeedbackJitterOffset ;
	 uint    VirtualTextureFeedbackSampleOffset ;
	 uint    Padding4024 ;
	 uint    Padding4028 ;
	 float4    RuntimeVirtualTextureMipLevel ;
	 float2    RuntimeVirtualTexturePackHeight ;
	 float    Padding4056 ;
	 float    Padding4060 ;
	 float4    RuntimeVirtualTextureDebugParams ;
	 int    FarShadowStaticMeshLODBias ;
	 float    MinRoughness ;
	 float    Padding4088 ;
	 float    Padding4092 ;
	 float4    HairRenderInfo ;
	 uint    EnableSkyLight ;
	 uint    HairRenderInfoBits ;
	 uint    HairComponents ;
	 float    bSubsurfacePostprocessEnabled ;
	 float4    SSProfilesTextureSizeAndInvSize ;
	 float4    SSProfilesPreIntegratedTextureSizeAndInvSize ;
	 float4    SpecularProfileTextureSizeAndInvSize ;
	 float3    PhysicsFieldClipmapCenter ;
	 float    PhysicsFieldClipmapDistance ;
	 int    PhysicsFieldClipmapResolution ;
	 int    PhysicsFieldClipmapExponent ;
	 int    PhysicsFieldClipmapCount ;
	 int    PhysicsFieldTargetCount ;
	 int4    PhysicsFieldTargets[32] ;
	 uint    GPUSceneViewId ;
	 float    ViewResolutionFraction ;
	 float    SubSurfaceColorAsTransmittanceAtDistanceInMeters ;
	 float    Padding4732 ;
	 float4    TanAndInvTanHalfFOV ;
	 float4    PrevTanAndInvTanHalfFOV ;
	 float2    WorldDepthToPixelWorldRadius ;
	 float    Padding4776 ;
	 float    Padding4780 ;
	 float4    ScreenRayLengthMultiplier ;
	 float4    GlintLUTParameters0 ;
	 float4    GlintLUTParameters1 ;
	 int4    EnvironmentComponentsFlags ;
	 uint    BindlessSampler_MaterialTextureBilinearWrapedSampler ;
	 uint    Padding4852 ;
	 uint    BindlessSampler_MaterialTextureBilinearClampedSampler ;
	 uint    Padding4860 ;
	 uint    BindlessSRV_VolumetricLightmapIndirectionTexture ;
	 uint    Padding4868 ;
	 uint    BindlessSRV_VolumetricLightmapBrickAmbientVector ;
	 uint    Padding4876 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients0 ;
	 uint    Padding4884 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients1 ;
	 uint    Padding4892 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients2 ;
	 uint    Padding4900 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients3 ;
	 uint    Padding4908 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients4 ;
	 uint    Padding4916 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients5 ;
	 uint    Padding4924 ;
	 uint    BindlessSRV_SkyBentNormalBrickTexture ;
	 uint    Padding4932 ;
	 uint    BindlessSRV_DirectionalLightShadowingBrickTexture ;
	 uint    Padding4940 ;
	 uint    BindlessSampler_VolumetricLightmapBrickAmbientVectorSampler ;
	 uint    Padding4948 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler0 ;
	 uint    Padding4956 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler1 ;
	 uint    Padding4964 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler2 ;
	 uint    Padding4972 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler3 ;
	 uint    Padding4980 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler4 ;
	 uint    Padding4988 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler5 ;
	 uint    Padding4996 ;
	 uint    BindlessSampler_SkyBentNormalTextureSampler ;
	 uint    Padding5004 ;
	 uint    BindlessSampler_DirectionalLightShadowingTextureSampler ;
	 uint    Padding5012 ;
	 uint    BindlessSRV_GlobalDistanceFieldPageAtlasTexture ;
	 uint    Padding5020 ;
	 uint    BindlessSRV_GlobalDistanceFieldCoverageAtlasTexture ;
	 uint    Padding5028 ;
	 uint    BindlessSRV_GlobalDistanceFieldPageTableTexture ;
	 uint    Padding5036 ;
	 uint    BindlessSRV_GlobalDistanceFieldMipTexture ;
	 uint    Padding5044 ;
	 uint    BindlessSampler_GlobalDistanceFieldPageAtlasTextureSampler ;
	 uint    Padding5052 ;
	 uint    BindlessSampler_GlobalDistanceFieldCoverageAtlasTextureSampler ;
	 uint    Padding5060 ;
	 uint    BindlessSampler_GlobalDistanceFieldMipTextureSampler ;
	 uint    Padding5068 ;
	 uint    BindlessSRV_AtmosphereTransmittanceTexture ;
	 uint    Padding5076 ;
	 uint    BindlessSampler_AtmosphereTransmittanceTextureSampler ;
	 uint    Padding5084 ;
	 uint    BindlessSRV_AtmosphereIrradianceTexture ;
	 uint    Padding5092 ;
	 uint    BindlessSampler_AtmosphereIrradianceTextureSampler ;
	 uint    Padding5100 ;
	 uint    BindlessSRV_AtmosphereInscatterTexture ;
	 uint    Padding5108 ;
	 uint    BindlessSampler_AtmosphereInscatterTextureSampler ;
	 uint    Padding5116 ;
	 uint    BindlessSRV_PerlinNoiseGradientTexture ;
	 uint    Padding5124 ;
	 uint    BindlessSampler_PerlinNoiseGradientTextureSampler ;
	 uint    Padding5132 ;
	 uint    BindlessSRV_PerlinNoise3DTexture ;
	 uint    Padding5140 ;
	 uint    BindlessSampler_PerlinNoise3DTextureSampler ;
	 uint    Padding5148 ;
	 uint    BindlessSRV_SobolSamplingTexture ;
	 uint    Padding5156 ;
	 uint    BindlessSampler_SharedPointWrappedSampler ;
	 uint    Padding5164 ;
	 uint    BindlessSampler_SharedPointClampedSampler ;
	 uint    Padding5172 ;
	 uint    BindlessSampler_SharedBilinearWrappedSampler ;
	 uint    Padding5180 ;
	 uint    BindlessSampler_SharedBilinearClampedSampler ;
	 uint    Padding5188 ;
	 uint    BindlessSampler_SharedBilinearAnisoClampedSampler ;
	 uint    Padding5196 ;
	 uint    BindlessSampler_SharedTrilinearWrappedSampler ;
	 uint    Padding5204 ;
	 uint    BindlessSampler_SharedTrilinearClampedSampler ;
	 uint    Padding5212 ;
	 uint    BindlessSRV_PreIntegratedBRDF ;
	 uint    Padding5220 ;
	 uint    BindlessSampler_PreIntegratedBRDFSampler ;
	 uint    Padding5228 ;
	 uint    BindlessSRV_SkyIrradianceEnvironmentMap ;
	 uint    Padding5236 ;
	 uint    BindlessSRV_TransmittanceLutTexture ;
	 uint    Padding5244 ;
	 uint    BindlessSampler_TransmittanceLutTextureSampler ;
	 uint    Padding5252 ;
	 uint    BindlessSRV_SkyViewLutTexture ;
	 uint    Padding5260 ;
	 uint    BindlessSampler_SkyViewLutTextureSampler ;
	 uint    Padding5268 ;
	 uint    BindlessSRV_DistantSkyLightLutTexture ;
	 uint    Padding5276 ;
	 uint    BindlessSampler_DistantSkyLightLutTextureSampler ;
	 uint    Padding5284 ;
	 uint    BindlessSRV_CameraAerialPerspectiveVolume ;
	 uint    Padding5292 ;
	 uint    BindlessSampler_CameraAerialPerspectiveVolumeSampler ;
	 uint    Padding5300 ;
	 uint    BindlessSRV_CameraAerialPerspectiveVolumeMieOnly ;
	 uint    Padding5308 ;
	 uint    BindlessSampler_CameraAerialPerspectiveVolumeMieOnlySampler ;
	 uint    Padding5316 ;
	 uint    BindlessSRV_CameraAerialPerspectiveVolumeRayOnly ;
	 uint    Padding5324 ;
	 uint    BindlessSampler_CameraAerialPerspectiveVolumeRayOnlySampler ;
	 uint    Padding5332 ;
	 uint    BindlessSRV_HairScatteringLUTTexture ;
	 uint    Padding5340 ;
	 uint    BindlessSampler_HairScatteringLUTSampler ;
	 uint    Padding5348 ;
	 uint    BindlessSRV_GGXLTCMatTexture ;
	 uint    Padding5356 ;
	 uint    BindlessSampler_GGXLTCMatSampler ;
	 uint    Padding5364 ;
	 uint    BindlessSRV_GGXLTCAmpTexture ;
	 uint    Padding5372 ;
	 uint    BindlessSampler_GGXLTCAmpSampler ;
	 uint    Padding5380 ;
	 uint    BindlessSRV_SheenLTCTexture ;
	 uint    Padding5388 ;
	 uint    BindlessSampler_SheenLTCSampler ;
	 uint    Padding5396 ;
	 uint    bShadingEnergyConservation ;
	 uint    bShadingEnergyPreservation ;
	 uint    BindlessSRV_ShadingEnergyGGXSpecTexture ;
	 uint    Padding5412 ;
	 uint    BindlessSRV_ShadingEnergyGGXGlassTexture ;
	 uint    Padding5420 ;
	 uint    BindlessSRV_ShadingEnergyClothSpecTexture ;
	 uint    Padding5428 ;
	 uint    BindlessSRV_ShadingEnergyDiffuseTexture ;
	 uint    Padding5436 ;
	 uint    BindlessSampler_ShadingEnergySampler ;
	 uint    Padding5444 ;
	 uint    BindlessSRV_GlintTexture ;
	 uint    Padding5452 ;
	 uint    BindlessSampler_GlintSampler ;
	 uint    Padding5460 ;
	 uint    BindlessSRV_SimpleVolumeTexture ;
	 uint    Padding5468 ;
	 uint    BindlessSampler_SimpleVolumeTextureSampler ;
	 uint    Padding5476 ;
	 uint    BindlessSRV_SimpleVolumeEnvTexture ;
	 uint    Padding5484 ;
	 uint    BindlessSampler_SimpleVolumeEnvTextureSampler ;
	 uint    Padding5492 ;
	 uint    BindlessSRV_SSProfilesTexture ;
	 uint    Padding5500 ;
	 uint    BindlessSampler_SSProfilesSampler ;
	 uint    Padding5508 ;
	 uint    BindlessSampler_SSProfilesTransmissionSampler ;
	 uint    Padding5516 ;
	 uint    BindlessSRV_SSProfilesPreIntegratedTexture ;
	 uint    Padding5524 ;
	 uint    BindlessSampler_SSProfilesPreIntegratedSampler ;
	 uint    Padding5532 ;
	 uint    BindlessSRV_SpecularProfileTexture ;
	 uint    Padding5540 ;
	 uint    BindlessSampler_SpecularProfileSampler ;
	 uint    Padding5548 ;
	 uint    BindlessSRV_WaterIndirection ;
	 uint    Padding5556 ;
	 uint    BindlessSRV_WaterData ;
	 uint    Padding5564 ;
	 float4    RectLightAtlasSizeAndInvSize ;
	 float    RectLightAtlasMaxMipLevel ;
	 float    Padding5588 ;
	 uint    BindlessSRV_RectLightAtlasTexture ;
	 uint    Padding5596 ;
	 uint    BindlessSampler_RectLightAtlasSampler ;
	 uint    Padding5604 ;
	 uint    Padding5608 ;
	 uint    Padding5612 ;
	 float4    IESAtlasSizeAndInvSize ;
	 uint    BindlessSRV_IESAtlasTexture ;
	 uint    Padding5636 ;
	 uint    BindlessSampler_IESAtlasSampler ;
	 uint    Padding5644 ;
	 uint    BindlessSampler_LandscapeWeightmapSampler ;
	 uint    Padding5652 ;
	 uint    BindlessSRV_LandscapeIndirection ;
	 uint    Padding5660 ;
	 uint    BindlessSRV_LandscapePerComponentData ;
	 uint    Padding5668 ;
	 uint    BindlessUAV_VTFeedbackBuffer ;
	 uint    Padding5676 ;
	 uint    BindlessSRV_PhysicsFieldClipmapBuffer ;
	 uint    Padding5684 ;
	 uint    Padding5688 ;
	 uint    Padding5692 ;
	 float3    TLASPreViewTranslationHigh ;
	 float    Padding5708 ;
	 float3    TLASPreViewTranslationLow ;
 };
ConstantBuffer<FViewConstants> View;
Texture3D<uint4>  View_VolumetricLightmapIndirectionTexture;
Texture3D  View_DirectionalLightShadowingBrickTexture;
Texture2D  View_PerlinNoiseGradientTexture;
SamplerState  View_PerlinNoiseGradientTextureSampler;
Texture3D  View_PerlinNoise3DTexture;
SamplerState  View_PerlinNoise3DTextureSampler;
Texture2D<uint>  View_SobolSamplingTexture;
SamplerState  View_SharedBilinearClampedSampler;
SamplerState  View_SharedTrilinearClampedSampler;
Texture2D  View_PreIntegratedBRDF;
SamplerState  View_PreIntegratedBRDFSampler;
StructuredBuffer<float4>  View_SkyIrradianceEnvironmentMap;
Texture2D  View_GGXLTCMatTexture;
SamplerState  View_GGXLTCMatSampler;
Texture2D  View_GGXLTCAmpTexture;
SamplerState  View_GGXLTCAmpSampler;
Texture2D  View_SSProfilesTexture;
Texture2D<float4>  View_RectLightAtlasTexture;
struct FPrimitiveConstants {
	 uint    Flags ;
	 uint    InstanceSceneDataOffset ;
	 uint    NumInstanceSceneDataEntries ;
	 int    SingleCaptureIndex ;
	 float3    PositionHigh ;
	 uint    PrimitiveComponentId ;
	 float4x4    LocalToRelativeWorld ;
	 float4x4    RelativeWorldToLocal ;
	 float4x4    PreviousLocalToRelativeWorld ;
	 float4x4    PreviousRelativeWorldToLocal ;
	 float4x4    WorldToPreviousWorld ;
	 float3    InvNonUniformScale ;
	 float    ObjectBoundsX ;
	 float4    ObjectWorldPositionHighAndRadius ;
	 float3    ObjectWorldPositionLow ;
	 float    MinMaterialDisplacement ;
	 float3    ActorWorldPositionHigh ;
	 float    MaxMaterialDisplacement ;
	 float3    ActorWorldPositionLow ;
	 uint    LightmapUVIndex ;
	 float3    ObjectOrientation ;
	 uint    LightmapDataIndex ;
	 float4    NonUniformScale ;
	 float3    PreSkinnedLocalBoundsMin ;
	 uint    NaniteResourceID ;
	 float3    PreSkinnedLocalBoundsMax ;
	 uint    NaniteHierarchyOffset ;
	 float3    LocalObjectBoundsMin ;
	 float    ObjectBoundsY ;
	 float3    LocalObjectBoundsMax ;
	 float    ObjectBoundsZ ;
	 float3    InstanceLocalBoundsCenter ;
	 uint    InstancePayloadDataOffset ;
	 float3    InstanceLocalBoundsExtent ;
	 uint    InstancePayloadDataStride ;
	 uint    InstancePayloadExtensionSize ;
	 uint    Padding564 ;
	 float2    WireframeAndPrimitiveColor ;
	 uint    PackedNaniteFlags ;
	 int    PersistentPrimitiveIndex ;
	 float2    InstanceDrawDistanceMinMaxSquared ;
	 float    InstanceWPODisableDistanceSquared ;
	 uint    NaniteRayTracingDataOffset ;
	 float    MaxWPOExtent ;
	 uint    CustomStencilValueAndMask ;
	 uint    VisibilityFlags ;
	 uint    Padding612 ;
	 uint    Padding616 ;
	 uint    Padding620 ;
	 float4    CustomPrimitiveData[9] ;
 };
ConstantBuffer<FPrimitiveConstants> Primitive;
StructuredBuffer<float4>  Scene_GPUScene_GPUScenePrimitiveSceneData;
struct FTranslucentBasePassConstants {
	 uint    Shared_Forward_NumLocalLights ;
	 uint    Shared_Forward_NumReflectionCaptures ;
	 uint    Shared_Forward_HasDirectionalLight ;
	 uint    Shared_Forward_NumGridCells ;
	 int3    Shared_Forward_CulledGridSize ;
	 uint    Shared_Forward_MaxCulledLightsPerCell ;
	 uint    Shared_Forward_LightGridPixelSizeShift ;
	 uint    Padding36 ;
	 uint    Padding40 ;
	 uint    Padding44 ;
	 float3    Shared_Forward_LightGridZParams ;
	 float    Padding60 ;
	 float3    Shared_Forward_DirectionalLightDirection ;
	 float    Shared_Forward_DirectionalLightSourceRadius ;
	 float    Shared_Forward_DirectionalLightSoftSourceRadius ;
	 float    Padding84 ;
	 float    Padding88 ;
	 float    Padding92 ;
	 float3    Shared_Forward_DirectionalLightColor ;
	 float    Shared_Forward_DirectionalLightVolumetricScatteringIntensity ;
	 float    Shared_Forward_DirectionalLightSpecularScale ;
	 uint    Shared_Forward_DirectionalLightShadowMapChannelMask ;
	 float2    Shared_Forward_DirectionalLightDistanceFadeMAD ;
	 uint    Shared_Forward_NumDirectionalLightCascades ;
	 int    Shared_Forward_DirectionalLightVSM ;
	 int    Padding136 ;
	 int    Padding140 ;
	 float4    Shared_Forward_CascadeEndDepths ;
	 float4x4    Shared_Forward_DirectionalLightTranslatedWorldToShadowMatrix[4] ;
	 float4    Shared_Forward_DirectionalLightShadowmapMinMax[4] ;
	 float4    Shared_Forward_DirectionalLightShadowmapAtlasBufferSize ;
	 float    Shared_Forward_DirectionalLightDepthBias ;
	 uint    Shared_Forward_DirectionalLightUseStaticShadowing ;
	 uint    Shared_Forward_SimpleLightsEndIndex ;
	 uint    Shared_Forward_ClusteredDeferredSupportedEndIndex ;
	 uint    Shared_Forward_ManyLightsSupportedStartIndex ;
	 uint    Padding516 ;
	 uint    Padding520 ;
	 uint    Padding524 ;
	 float4    Shared_Forward_DirectionalLightStaticShadowBufferSize ;
	 float4x4    Shared_Forward_DirectionalLightTranslatedWorldToStaticShadow ;
	 uint    Shared_Forward_DirectLightingShowFlag ;
	 uint    Shared_Forward_LightFunctionAtlasLightIndex ;
	 float    Padding616 ;
	 float    Padding620 ;
	 float    Shared_Forward_DirectionalLightSMRTSettings_ScreenRayLength ;
	 int    Shared_Forward_DirectionalLightSMRTSettings_SMRTRayCount ;
	 int    Shared_Forward_DirectionalLightSMRTSettings_SMRTSamplesPerRay ;
	 float    Shared_Forward_DirectionalLightSMRTSettings_SMRTRayLengthScale ;
	 float    Shared_Forward_DirectionalLightSMRTSettings_SMRTCotMaxRayAngleFromLight ;
	 float    Shared_Forward_DirectionalLightSMRTSettings_SMRTTexelDitherScale ;
	 float    Shared_Forward_DirectionalLightSMRTSettings_SMRTExtrapolateSlope ;
	 float    Shared_Forward_DirectionalLightSMRTSettings_SMRTMaxSlopeBias ;
	 uint    Shared_Forward_DirectionalLightSMRTSettings_SMRTAdaptiveRayCount ;
	 uint    Padding660 ;
	 uint    Padding664 ;
	 uint    Padding668 ;
	 uint    BindlessSRV_Shared_Forward_DirectionalLightShadowmapAtlas ;
	 uint    Padding676 ;
	 uint    BindlessSampler_Shared_Forward_ShadowmapSampler ;
	 uint    Padding684 ;
	 uint    BindlessSRV_Shared_Forward_DirectionalLightStaticShadowmap ;
	 uint    Padding692 ;
	 uint    BindlessSampler_Shared_Forward_StaticShadowmapSampler ;
	 uint    Padding700 ;
	 uint    BindlessSRV_Shared_Forward_ForwardLocalLightBuffer ;
	 uint    Padding708 ;
	 uint    BindlessSRV_Shared_Forward_NumCulledLightsGrid ;
	 uint    Padding716 ;
	 uint    BindlessSRV_Shared_Forward_CulledLightDataGrid32Bit ;
	 uint    Padding724 ;
	 uint    BindlessSRV_Shared_Forward_CulledLightDataGrid16Bit ;
	 float    Padding732 ;
	 uint    Shared_ForwardISR_NumLocalLights ;
	 uint    Shared_ForwardISR_NumReflectionCaptures ;
	 uint    Shared_ForwardISR_HasDirectionalLight ;
	 uint    Shared_ForwardISR_NumGridCells ;
	 int3    Shared_ForwardISR_CulledGridSize ;
	 uint    Shared_ForwardISR_MaxCulledLightsPerCell ;
	 uint    Shared_ForwardISR_LightGridPixelSizeShift ;
	 uint    Padding772 ;
	 uint    Padding776 ;
	 uint    Padding780 ;
	 float3    Shared_ForwardISR_LightGridZParams ;
	 float    Padding796 ;
	 float3    Shared_ForwardISR_DirectionalLightDirection ;
	 float    Shared_ForwardISR_DirectionalLightSourceRadius ;
	 float    Shared_ForwardISR_DirectionalLightSoftSourceRadius ;
	 float    Padding820 ;
	 float    Padding824 ;
	 float    Padding828 ;
	 float3    Shared_ForwardISR_DirectionalLightColor ;
	 float    Shared_ForwardISR_DirectionalLightVolumetricScatteringIntensity ;
	 float    Shared_ForwardISR_DirectionalLightSpecularScale ;
	 uint    Shared_ForwardISR_DirectionalLightShadowMapChannelMask ;
	 float2    Shared_ForwardISR_DirectionalLightDistanceFadeMAD ;
	 uint    Shared_ForwardISR_NumDirectionalLightCascades ;
	 int    Shared_ForwardISR_DirectionalLightVSM ;
	 int    Padding872 ;
	 int    Padding876 ;
	 float4    Shared_ForwardISR_CascadeEndDepths ;
	 float4x4    Shared_ForwardISR_DirectionalLightTranslatedWorldToShadowMatrix[4] ;
	 float4    Shared_ForwardISR_DirectionalLightShadowmapMinMax[4] ;
	 float4    Shared_ForwardISR_DirectionalLightShadowmapAtlasBufferSize ;
	 float    Shared_ForwardISR_DirectionalLightDepthBias ;
	 uint    Shared_ForwardISR_DirectionalLightUseStaticShadowing ;
	 uint    Shared_ForwardISR_SimpleLightsEndIndex ;
	 uint    Shared_ForwardISR_ClusteredDeferredSupportedEndIndex ;
	 uint    Shared_ForwardISR_ManyLightsSupportedStartIndex ;
	 uint    Padding1252 ;
	 uint    Padding1256 ;
	 uint    Padding1260 ;
	 float4    Shared_ForwardISR_DirectionalLightStaticShadowBufferSize ;
	 float4x4    Shared_ForwardISR_DirectionalLightTranslatedWorldToStaticShadow ;
	 uint    Shared_ForwardISR_DirectLightingShowFlag ;
	 uint    Shared_ForwardISR_LightFunctionAtlasLightIndex ;
	 float    Padding1352 ;
	 float    Padding1356 ;
	 float    Shared_ForwardISR_DirectionalLightSMRTSettings_ScreenRayLength ;
	 int    Shared_ForwardISR_DirectionalLightSMRTSettings_SMRTRayCount ;
	 int    Shared_ForwardISR_DirectionalLightSMRTSettings_SMRTSamplesPerRay ;
	 float    Shared_ForwardISR_DirectionalLightSMRTSettings_SMRTRayLengthScale ;
	 float    Shared_ForwardISR_DirectionalLightSMRTSettings_SMRTCotMaxRayAngleFromLight ;
	 float    Shared_ForwardISR_DirectionalLightSMRTSettings_SMRTTexelDitherScale ;
	 float    Shared_ForwardISR_DirectionalLightSMRTSettings_SMRTExtrapolateSlope ;
	 float    Shared_ForwardISR_DirectionalLightSMRTSettings_SMRTMaxSlopeBias ;
	 uint    Shared_ForwardISR_DirectionalLightSMRTSettings_SMRTAdaptiveRayCount ;
	 uint    Padding1396 ;
	 uint    Padding1400 ;
	 uint    Padding1404 ;
	 uint    BindlessSRV_Shared_ForwardISR_DirectionalLightShadowmapAtlas ;
	 uint    Padding1412 ;
	 uint    BindlessSampler_Shared_ForwardISR_ShadowmapSampler ;
	 uint    Padding1420 ;
	 uint    BindlessSRV_Shared_ForwardISR_DirectionalLightStaticShadowmap ;
	 uint    Padding1428 ;
	 uint    BindlessSampler_Shared_ForwardISR_StaticShadowmapSampler ;
	 uint    Padding1436 ;
	 uint    BindlessSRV_Shared_ForwardISR_ForwardLocalLightBuffer ;
	 uint    Padding1444 ;
	 uint    BindlessSRV_Shared_ForwardISR_NumCulledLightsGrid ;
	 uint    Padding1452 ;
	 uint    BindlessSRV_Shared_ForwardISR_CulledLightDataGrid32Bit ;
	 uint    Padding1460 ;
	 uint    BindlessSRV_Shared_ForwardISR_CulledLightDataGrid16Bit ;
	 float    Padding1468 ;
	 float4    Shared_Reflection_SkyLightParameters ;
	 uint    BindlessSRV_Shared_Reflection_SkyLightCubemap ;
	 uint    Padding1492 ;
	 uint    BindlessSampler_Shared_Reflection_SkyLightCubemapSampler ;
	 uint    Padding1500 ;
	 uint    BindlessSRV_Shared_Reflection_SkyLightBlendDestinationCubemap ;
	 uint    Padding1508 ;
	 uint    BindlessSampler_Shared_Reflection_SkyLightBlendDestinationCubemapSampler ;
	 uint    Padding1516 ;
	 uint    BindlessSRV_Shared_Reflection_ReflectionCubemap ;
	 uint    Padding1524 ;
	 uint    BindlessSampler_Shared_Reflection_ReflectionCubemapSampler ;
	 uint    Padding1532 ;
	 uint    BindlessSRV_Shared_Reflection_PreIntegratedGF ;
	 uint    Padding1540 ;
	 uint    BindlessSampler_Shared_Reflection_PreIntegratedGFSampler ;
	 float    Padding1548 ;
	 float4    Shared_PlanarReflection_ReflectionPlane ;
	 float4    Shared_PlanarReflection_PlanarReflectionOrigin ;
	 float4    Shared_PlanarReflection_PlanarReflectionXAxis ;
	 float4    Shared_PlanarReflection_PlanarReflectionYAxis ;
	 float3x4    Shared_PlanarReflection_InverseTransposeMirrorMatrix ;
	 float3    Shared_PlanarReflection_PlanarReflectionParameters ;
	 float    Padding1676 ;
	 float2    Shared_PlanarReflection_PlanarReflectionParameters2 ;
	 float    Padding1688 ;
	 float    Padding1692 ;
	 float4x4    Shared_PlanarReflection_ProjectionWithExtraFOV[2] ;
	 float4    Shared_PlanarReflection_PlanarReflectionScreenScaleBias[2] ;
	 float2    Shared_PlanarReflection_PlanarReflectionScreenBound ;
	 uint    Shared_PlanarReflection_bIsStereo ;
	 uint    Padding1868 ;
	 uint    BindlessSRV_Shared_PlanarReflection_PlanarReflectionTexture ;
	 uint    Padding1876 ;
	 uint    BindlessSampler_Shared_PlanarReflection_PlanarReflectionSampler ;
	 float    Padding1884 ;
	 float4    Shared_Fog_ExponentialFogParameters ;
	 float4    Shared_Fog_ExponentialFogParameters2 ;
	 float4    Shared_Fog_ExponentialFogColorParameter ;
	 float4    Shared_Fog_ExponentialFogParameters3 ;
	 float4    Shared_Fog_SkyAtmosphereAmbientContributionColorScale ;
	 float4    Shared_Fog_InscatteringLightDirection ;
	 float4    Shared_Fog_DirectionalInscatteringColor ;
	 float2    Shared_Fog_SinCosInscatteringColorCubemapRotation ;
	 float    Padding2008 ;
	 float    Padding2012 ;
	 float3    Shared_Fog_FogInscatteringTextureParameters ;
	 float    Shared_Fog_ApplyVolumetricFog ;
	 float    Shared_Fog_VolumetricFogStartDistance ;
	 float    Shared_Fog_VolumetricFogNearFadeInDistanceInv ;
	 uint    BindlessSRV_Shared_Fog_FogInscatteringColorCubemap ;
	 uint    Padding2044 ;
	 uint    BindlessSampler_Shared_Fog_FogInscatteringColorSampler ;
	 uint    Padding2052 ;
	 uint    BindlessSRV_Shared_Fog_IntegratedLightScattering ;
	 uint    Padding2060 ;
	 uint    BindlessSampler_Shared_Fog_IntegratedLightScatteringSampler ;
	 float    Padding2068 ;
	 float    Padding2072 ;
	 float    Padding2076 ;
	 float4    Shared_FogISR_ExponentialFogParameters ;
	 float4    Shared_FogISR_ExponentialFogParameters2 ;
	 float4    Shared_FogISR_ExponentialFogColorParameter ;
	 float4    Shared_FogISR_ExponentialFogParameters3 ;
	 float4    Shared_FogISR_SkyAtmosphereAmbientContributionColorScale ;
	 float4    Shared_FogISR_InscatteringLightDirection ;
	 float4    Shared_FogISR_DirectionalInscatteringColor ;
	 float2    Shared_FogISR_SinCosInscatteringColorCubemapRotation ;
	 float    Padding2200 ;
	 float    Padding2204 ;
	 float3    Shared_FogISR_FogInscatteringTextureParameters ;
	 float    Shared_FogISR_ApplyVolumetricFog ;
	 float    Shared_FogISR_VolumetricFogStartDistance ;
	 float    Shared_FogISR_VolumetricFogNearFadeInDistanceInv ;
	 uint    BindlessSRV_Shared_FogISR_FogInscatteringColorCubemap ;
	 uint    Padding2236 ;
	 uint    BindlessSampler_Shared_FogISR_FogInscatteringColorSampler ;
	 uint    Padding2244 ;
	 uint    BindlessSRV_Shared_FogISR_IntegratedLightScattering ;
	 uint    Padding2252 ;
	 uint    BindlessSampler_Shared_FogISR_IntegratedLightScatteringSampler ;
	 float    Padding2260 ;
	 float    Padding2264 ;
	 float    Padding2268 ;
	 uint    BindlessSRV_Shared_LFV_LocalFogVolumeInstances ;
	 uint    Padding2276 ;
	 uint2    Shared_LFV_LocalFogVolumeTileDataTextureResolution ;
	 uint    Shared_LFV_LocalFogVolumeInstanceCount ;
	 uint    Shared_LFV_LocalFogVolumeTilePixelSize ;
	 float    Shared_LFV_LocalFogVolumeMaxDensityIntoVolumetricFog ;
	 uint    Shared_LFV_ShouldRenderLocalFogVolumeInVolumetricFog ;
	 float    Shared_LFV_GlobalStartDistance ;
	 float    Padding2308 ;
	 float    Padding2312 ;
	 float    Padding2316 ;
	 float4    Shared_LFV_HalfResTextureSizeAndInvSize ;
	 float3    Shared_LFV_DirectionalLightColor ;
	 float    Padding2348 ;
	 float3    Shared_LFV_DirectionalLightDirection ;
	 float    Padding2364 ;
	 uint    BindlessSRV_Shared_LFV_LocalFogVolumeTileDataTexture ;
	 float    Padding2372 ;
	 float    Padding2376 ;
	 float    Padding2380 ;
	 uint    BindlessSRV_Shared_LightFunctionAtlas_LightFunctionAtlasTexture ;
	 uint    Padding2388 ;
	 uint    BindlessSRV_Shared_LightFunctionAtlas_LightInfoDataBuffer ;
	 uint    Padding2396 ;
	 uint    BindlessSampler_Shared_LightFunctionAtlas_LightFunctionAtlasSampler ;
	 uint    Padding2404 ;
	 float    Shared_LightFunctionAtlas_Slot_UVSize ;
	 float    Padding2412 ;
	 uint    Shared_UseBasePassSkylight ;
	 float    Padding2420 ;
	 float    Padding2424 ;
	 float    Padding2428 ;
	 uint    BindlessSRV_SceneTextures_SceneColorTexture ;
	 uint    Padding2436 ;
	 uint    BindlessSRV_SceneTextures_SceneDepthTexture ;
	 uint    Padding2444 ;
	 uint    BindlessSRV_SceneTextures_ScenePartialDepthTexture ;
	 uint    Padding2452 ;
	 uint    BindlessSRV_SceneTextures_GBufferATexture ;
	 uint    Padding2460 ;
	 uint    BindlessSRV_SceneTextures_GBufferBTexture ;
	 uint    Padding2468 ;
	 uint    BindlessSRV_SceneTextures_GBufferCTexture ;
	 uint    Padding2476 ;
	 uint    BindlessSRV_SceneTextures_GBufferDTexture ;
	 uint    Padding2484 ;
	 uint    BindlessSRV_SceneTextures_GBufferETexture ;
	 uint    Padding2492 ;
	 uint    BindlessSRV_SceneTextures_GBufferFTexture ;
	 uint    Padding2500 ;
	 uint    BindlessSRV_SceneTextures_GBufferVelocityTexture ;
	 uint    Padding2508 ;
	 uint    BindlessSRV_SceneTextures_ScreenSpaceAOTexture ;
	 uint    Padding2516 ;
	 uint    BindlessSRV_SceneTextures_CustomDepthTexture ;
	 uint    Padding2524 ;
	 uint    BindlessSRV_SceneTextures_CustomStencilTexture ;
	 uint    Padding2532 ;
	 uint    BindlessSampler_SceneTextures_PointClampSampler ;
	 float    Padding2540 ;
	 uint    Substrate_MaxBytesPerPixel ;
	 uint    Substrate_MaxClosurePerPixel ;
	 uint    Substrate_bRoughDiffuse ;
	 uint    Substrate_PeelLayersAboveDepth ;
	 uint    Substrate_bRoughnessTracking ;
	 float    Padding2564 ;
	 float    Padding2568 ;
	 float    Padding2572 ;
	 int    Substrate_FirstSliceStoringSubstrateSSSData ;
	 int    Padding2580 ;
	 uint    BindlessSRV_Substrate_MaterialTextureArray ;
	 uint    Padding2588 ;
	 uint    BindlessSRV_Substrate_TopLayerTexture ;
	 float    Padding2596 ;
	 float    Padding2600 ;
	 float    Padding2604 ;
	 float4x4    ForwardDirLightCloudShadow_CloudShadowmapTranslatedWorldToLightClipMatrix ;
	 float    ForwardDirLightCloudShadow_CloudShadowmapFarDepthKm ;
	 float    Padding2676 ;
	 uint    BindlessSRV_ForwardDirLightCloudShadow_CloudShadowmapTexture ;
	 uint    Padding2684 ;
	 uint    BindlessSampler_ForwardDirLightCloudShadow_CloudShadowmapSampler ;
	 uint    Padding2692 ;
	 float    ForwardDirLightCloudShadow_CloudShadowmapStrength ;
	 float    Padding2700 ;
	 uint    OIT_bOITEnable ;
	 uint    OIT_OITMethod ;
	 uint    OIT_MaxSideSamplePerPixel ;
	 uint    OIT_MaxSamplePerPixel ;
	 float    OIT_TransmittanceThreshold ;
	 float    Padding2724 ;
	 uint    BindlessUAV_OIT_OutOITSampleCount ;
	 uint    Padding2732 ;
	 uint    BindlessUAV_OIT_OutOITSampleData ;
	 float    Padding2740 ;
	 float    Padding2744 ;
	 float    Padding2748 ;
	 float4    HZBUvFactorAndInvFactor ;
	 float4    PrevScreenPositionScaleBias ;
	 float2    PrevSceneColorBilinearUVMin ;
	 float2    PrevSceneColorBilinearUVMax ;
	 float    PrevSceneColorPreExposureInv ;
	 int    SSRQuality ;
	 uint    BindlessSRV_HZBTexture ;
	 uint    Padding2812 ;
	 uint    BindlessSampler_HZBSampler ;
	 uint    Padding2820 ;
	 uint    BindlessSRV_PrevSceneColor ;
	 uint    Padding2828 ;
	 uint    BindlessSampler_PrevSceneColorSampler ;
	 uint    Padding2836 ;
	 uint    BindlessSRV_VolumetricCloudColor ;
	 uint    Padding2844 ;
	 uint    BindlessSampler_VolumetricCloudColorSampler ;
	 uint    Padding2852 ;
	 uint    BindlessSRV_VolumetricCloudDepth ;
	 uint    Padding2860 ;
	 uint    BindlessSampler_VolumetricCloudDepthSampler ;
	 uint    Padding2868 ;
	 float    ApplyVolumetricCloudOnTransparent ;
	 float    SoftBlendingDistanceKm ;
	 uint    BindlessSRV_TranslucencyLightingVolumeAmbientInner ;
	 uint    Padding2884 ;
	 uint    BindlessSRV_TranslucencyLightingVolumeAmbientOuter ;
	 uint    Padding2892 ;
	 uint    BindlessSRV_TranslucencyLightingVolumeDirectionalInner ;
	 uint    Padding2900 ;
	 uint    BindlessSRV_TranslucencyLightingVolumeDirectionalOuter ;
	 float    Padding2908 ;
	 float    ReprojectionRadiusScale ;
	 float    ClipmapWorldExtent ;
	 float    ClipmapDistributionBase ;
	 float    InvClipmapFadeSize ;
	 int2    ProbeAtlasResolutionInProbes ;
	 uint    RadianceProbeClipmapResolution ;
	 uint    NumRadianceProbeClipmaps ;
	 uint    RadianceProbeResolution ;
	 uint    FinalProbeResolution ;
	 uint    FinalRadianceAtlasMaxMip ;
	 uint    CalculateIrradiance ;
	 uint    IrradianceProbeResolution ;
	 uint    OcclusionProbeResolution ;
	 uint    NumProbesToTraceBudget ;
	 uint    RadianceCacheStats ;
	 uint    BindlessSRV_RadianceProbeIndirectionTexture ;
	 uint    Padding2980 ;
	 uint    BindlessSRV_RadianceCacheFinalRadianceAtlas ;
	 uint    Padding2988 ;
	 uint    BindlessSRV_RadianceCacheFinalIrradianceAtlas ;
	 uint    Padding2996 ;
	 uint    BindlessSRV_RadianceCacheProbeOcclusionAtlas ;
	 uint    Padding3004 ;
	 uint    BindlessSRV_RadianceCacheDepthAtlas ;
	 uint    Padding3012 ;
	 uint    BindlessSRV_ProbeWorldOffset ;
	 uint    Padding3020 ;
	 float4    RadianceProbeSettings[6] ;
	 float4    PaddedWorldPositionToRadianceProbeCoordBias[6] ;
	 float4    PaddedRadianceProbeCoordToWorldPositionBias[6] ;
	 float2    InvProbeFinalRadianceAtlasResolution ;
	 float2    InvProbeFinalIrradianceAtlasResolution ;
	 float2    InvProbeDepthAtlasResolution ;
	 uint    OverrideCacheOcclusionLighting ;
	 uint    ShowBlackRadianceCacheLighting ;
	 uint    ProbeAtlasResolutionModuloMask ;
	 uint    ProbeAtlasResolutionDivideShift ;
	 float    Padding3352 ;
	 float    Padding3356 ;
	 uint    BindlessSRV_Radiance ;
	 uint    Padding3364 ;
	 uint    BindlessSRV_Normal ;
	 uint    Padding3372 ;
	 uint    BindlessSRV_SceneDepth ;
	 uint    Padding3380 ;
	 uint    Enabled ;
	 float    RelativeDepthThreshold ;
	 float    SpecularScale ;
	 float    Contrast ;
	 float    Padding3400 ;
	 float    Padding3404 ;
	 uint    BindlessSRV_TranslucencyGIVolume0 ;
	 uint    Padding3412 ;
	 uint    BindlessSRV_TranslucencyGIVolume1 ;
	 uint    Padding3420 ;
	 uint    BindlessSRV_TranslucencyGIVolumeHistory0 ;
	 uint    Padding3428 ;
	 uint    BindlessSRV_TranslucencyGIVolumeHistory1 ;
	 uint    Padding3436 ;
	 uint    BindlessSampler_TranslucencyGIVolumeSampler ;
	 uint    Padding3444 ;
	 uint    Padding3448 ;
	 uint    Padding3452 ;
	 float3    TranslucencyGIGridZParams ;
	 uint    TranslucencyGIGridPixelSizeShift ;
	 int3    TranslucencyGIGridSize ;
	 float    Padding3484 ;
	 uint    BindlessSRV_PreIntegratedGFTexture ;
	 uint    Padding3492 ;
	 uint    BindlessSampler_PreIntegratedGFSampler ;
	 uint    Padding3500 ;
	 uint    BindlessSRV_EyeAdaptationBuffer ;
	 uint    Padding3508 ;
	 uint    BindlessSRV_SceneColorCopyTexture ;
	 uint    Padding3516 ;
	 uint    BindlessSampler_SceneColorCopySampler ;
	 float    Padding3524 ;
	 float    Padding3528 ;
	 float    Padding3532 ;
	 int3    BlueNoise_Dimensions ;
	 int    Padding3548 ;
	 int3    BlueNoise_ModuloMasks ;
	 int    Padding3564 ;
	 uint    BindlessSRV_BlueNoise_ScalarTexture ;
	 uint    Padding3572 ;
	 uint    BindlessSRV_BlueNoise_Vec2Texture ;
	 float    Padding3580 ;
	 float4x4    AVSM_TranslatedWorldToShadow[6] ;
	 float3    AVSM_TranslatedWorldOrigin ;
	 float    Padding3980 ;
	 float4    AVSM_TranslatedWorldPlane ;
	 int2    AVSM_Resolution ;
	 int    AVSM_NumShadowMatrices ;
	 int    AVSM_MaxSampleCount ;
	 int    AVSM_bIsEmpty ;
	 int    AVSM_bIsDirectionalLight ;
	 uint    BindlessSRV_AVSM_LinkedListBuffer ;
	 uint    Padding4028 ;
	 uint    BindlessSRV_AVSM_IndirectionBuffer ;
	 uint    Padding4036 ;
	 uint    BindlessSRV_AVSM_SampleBuffer ;
 };
ConstantBuffer<FTranslucentBasePassConstants> TranslucentBasePass;
Texture2D  TranslucentBasePass_Shared_Forward_DirectionalLightShadowmapAtlas;
SamplerState  TranslucentBasePass_Shared_Forward_ShadowmapSampler;
Texture2D  TranslucentBasePass_Shared_Forward_DirectionalLightStaticShadowmap;
SamplerState  TranslucentBasePass_Shared_Forward_StaticShadowmapSampler;
StructuredBuffer<float4>  TranslucentBasePass_Shared_Forward_ForwardLocalLightBuffer;
StructuredBuffer<uint>  TranslucentBasePass_Shared_Forward_NumCulledLightsGrid;
Buffer<uint>  TranslucentBasePass_Shared_Forward_CulledLightDataGrid16Bit;
TextureCube  TranslucentBasePass_Shared_Reflection_SkyLightCubemap;
SamplerState  TranslucentBasePass_Shared_Reflection_SkyLightCubemapSampler;
TextureCubeArray  TranslucentBasePass_Shared_Reflection_ReflectionCubemap;
SamplerState  TranslucentBasePass_Shared_Reflection_ReflectionCubemapSampler;
Texture2D  TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionTexture;
Texture3D  TranslucentBasePass_Shared_Fog_IntegratedLightScattering;
Texture3D<uint>  TranslucentBasePass_RadianceProbeIndirectionTexture;
Texture2D<float3>  TranslucentBasePass_RadianceCacheFinalRadianceAtlas;
StructuredBuffer<float4>  TranslucentBasePass_ProbeWorldOffset;
Texture2DArray  TranslucentBasePass_Radiance;
Texture2D  TranslucentBasePass_SceneDepth;
Texture3D  TranslucentBasePass_TranslucencyGIVolume0;
Texture3D  TranslucentBasePass_TranslucencyGIVolume1;
Texture3D  TranslucentBasePass_TranslucencyGIVolumeHistory0;
Texture3D  TranslucentBasePass_TranslucencyGIVolumeHistory1;
SamplerState  TranslucentBasePass_TranslucencyGIVolumeSampler;
Texture2D  TranslucentBasePass_HZBTexture;
SamplerState  TranslucentBasePass_HZBSampler;
Texture2D  TranslucentBasePass_PrevSceneColor;
SamplerState  TranslucentBasePass_PrevSceneColorSampler;
struct FReflectionCaptureSM5Constants {
	 float4    PositionHighAndRadius[341] ;
	 float4    PositionLow[341] ;
	 float4    CaptureProperties[341] ;
	 float4    CaptureOffsetAndAverageBrightness[341] ;
	 float4x4    BoxTransform[341] ;
	 float4    BoxScales[341] ;
 };
ConstantBuffer<FReflectionCaptureSM5Constants> ReflectionCaptureSM5;
struct FVirtualShadowMapConstants {
	 uint    NumFullShadowMaps ;
	 uint    NumSinglePageShadowMaps ;
	 uint    MaxPhysicalPages ;
	 uint    NumShadowMapSlots ;
	 uint    StaticCachedArrayIndex ;
	 uint    PhysicalPageRowMask ;
	 uint    PhysicalPageRowShift ;
	 uint    PackedShadowMaskMaxLightCount ;
	 float4    RecPhysicalPoolSize ;
	 int2    PhysicalPoolSize ;
	 int2    PhysicalPoolSizePages ;
	 uint    bExcludeNonNaniteFromCoarsePages ;
	 float    CoarsePagePixelThresholdDynamic ;
	 float    CoarsePagePixelThresholdStatic ;
	 float    CoarsePagePixelThresholdDynamicNanite ;
	 uint    SceneFrameNumber ;
	 uint    bClipmapGreedyLevelSelection ;
	 float    GlobalResolutionLodBias ;
	 float    Padding92 ;
	 uint    BindlessSRV_ProjectionData ;
	 uint    Padding100 ;
	 uint    BindlessSRV_PageTable ;
	 uint    Padding108 ;
	 uint    BindlessSRV_PageFlags ;
	 uint    Padding116 ;
	 uint    BindlessSRV_PageRectBounds ;
	 uint    Padding124 ;
	 uint    BindlessSRV_PhysicalPagePool ;
	 uint    Padding132 ;
	 uint    BindlessSRV_CachePrimitiveAsDynamic ;
	 uint    Padding140 ;
	 uint    BindlessSRV_LightGridData ;
	 uint    Padding148 ;
	 uint    BindlessSRV_NumCulledLightsGrid ;
 };
ConstantBuffer<FVirtualShadowMapConstants> VirtualShadowMap;
ByteAddressBuffer  VirtualShadowMap_ProjectionData;
StructuredBuffer<uint>  VirtualShadowMap_PageTable;
Texture2DArray<uint>  VirtualShadowMap_PhysicalPagePool;
struct FMaterialConstants {
	 float4    PreshaderBuffer[2] ;
	 uint    BindlessSampler_Wrap_WorldGroupSettings ;
	 uint    Padding36 ;
	 uint    BindlessSampler_Clamp_WorldGroupSettings ;
 };
ConstantBuffer<FMaterialConstants> Material;
struct ViewStateTileOffsetData
{
	FLWCVector3 WorldCameraOrigin;
	FLWCVector3 WorldViewOrigin;
	FLWCVector3 PrevWorldCameraOrigin;
	FLWCVector3 PrevWorldViewOrigin;
	FLWCVector3 PreViewTranslation;
	FLWCVector3 PrevPreViewTranslation;
};
struct ViewState
{
	float4x4 TranslatedWorldToClip;
	float4x4 RelativeWorldToClip;
	float4x4 ClipToRelativeWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToRelativeWorld;
	float4x4 ScreenToTranslatedWorld;
	float4x4 MobileMultiviewShadowTransform;
	float3 ViewOriginHigh;
	float3 ViewForward;
	float3 ViewUp;
	float3 ViewRight;
	float3 HMDViewNoRollUp;
	float3 HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4 ScreenPositionScaleBias;
	float3 ViewOriginLow;
	float3 TranslatedWorldCameraOrigin;
	float3 WorldViewOriginHigh;
	float3 WorldViewOriginLow;
	float3 PreViewTranslationHigh;
	float3 PreViewTranslationLow;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevTranslatedWorldCameraOrigin;
	float3 PrevWorldCameraOriginHigh;
	float3 PrevWorldCameraOriginLow;
	float3 PrevWorldViewOriginHigh;
	float3 PrevWorldViewOriginLow;
	float3 PrevPreViewTranslationHigh;
	float3 PrevPreViewTranslationLow;
	float3 ViewTilePosition;
	float3 RelativeWorldCameraOriginTO;
	float3 RelativeWorldViewOriginTO;
	float3 RelativePreViewTranslationTO;
	float3 PrevRelativeWorldCameraOriginTO;
	float3 PrevRelativeWorldViewOriginTO;
	float3 RelativePrevPreViewTranslationTO;
	float4x4 PrevClipToRelativeWorld;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4x4 ClipToPrevClipWithAA;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4 ViewRectMin;
	float4 ViewSizeAndInvSize;
	uint4 ViewRectMinAndSize;
	float4 LightProbeSizeRatioAndInvSizeRatio;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	float4 ScreenToViewSpace;
	float2 BufferToSceneTextureScale;
	float2 ResolutionFractionAndInv;
	int NumSceneColorMSAASamples;
	float ProjectionDepthThicknessScale;
	float PreExposure;
	float OneOverPreExposure;
	float4 DiffuseOverrideParameter;
	float4 SpecularOverrideParameter;
	float4 NormalOverrideParameter;
	float2 RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float NearPlane;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint FrameCounter;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	uint DebugViewModeMask;
	uint WorldIsPaused;
	float CameraCut;
	float UnlitViewmodeMask;
	float4 DirectionalLightColor;
	float3 DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float GeneralPurposeTweak;
	float GeneralPurposeTweak2;
	float DemosaicVposOffset;
	float DecalDepthBias;
	float3 IndirectLightingColorScale;
	float3 PrecomputedIndirectLightingColorScale;
	float3 PrecomputedIndirectSpecularColorScale;
	float4 AtmosphereLightDirection[2];
	float4 AtmosphereLightIlluminanceOnGroundPostTransmittance[2];
	float4 AtmosphereLightIlluminanceOuterSpace[2];
	float4 AtmosphereLightDiscLuminance[2];
	float4 AtmosphereLightDiscCosHalfApexAngle_PPTrans[2];
	float4 SkyViewLutSizeAndInvSize;
	float3 SkyCameraTranslatedWorldOrigin;
	float4 SkyPlanetTranslatedWorldCenterAndViewHeight;
	float4x4 SkyViewLutReferential;
	float4 SkyAtmosphereSkyLuminanceFactor;
	float SkyAtmospherePresentInScene;
	float SkyAtmosphereHeightFogContribution;
	float SkyAtmosphereBottomRadiusKm;
	float SkyAtmosphereTopRadiusKm;
	float4 SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	float SkyAtmosphereAerialPerspectiveStartDepthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float RealTimeReflectionCapture;
	float RealTimeReflectionCapturePreExposure;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float SkyLightAffectReflectionFlag;
	float SkyLightAffectGlobalIlluminationFlag;
	float4 SkyLightColor;
	float SkyLightVolumetricScatteringIntensity;
	float4 MobileSkyIrradianceEnvironmentMap[8];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeTranslatedCenterAndExtent[6];
	float4 GlobalVolumeTranslatedWorldToUVAddAndMul[6];
	float4 GlobalDistanceFieldMipTranslatedWorldToUVScale[6];
	float4 GlobalDistanceFieldMipTranslatedWorldToUVBias[6];
	float GlobalDistanceFieldMipFactor;
	float GlobalDistanceFieldMipTransition;
	int GlobalDistanceFieldClipmapSizeInPages;
	float3 GlobalDistanceFieldInvPageAtlasSize;
	float3 GlobalDistanceFieldInvCoverageAtlasSize;
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDFAOConeDistance;
	uint NumGlobalSDFClipmaps;
	float CoveredExpandSurfaceScale;
	float NotCoveredExpandSurfaceScale;
	float NotCoveredMinStepScale;
	float DitheredTransparencyStepThreshold;
	float DitheredTransparencyTraceThreshold;
	int2 CursorPosition;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float2 VolumetricFogViewGridUVToPrevViewRectUV;
	float2 VolumetricFogPrevViewGridRectUVToResourceUV;
	float2 VolumetricFogPrevUVMax;
	float2 VolumetricFogPrevUVMaxForTemporalBlend;
	float2 VolumetricFogScreenToResourceUV;
	float2 VolumetricFogUVMax;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
	float4 XRPassthroughCameraUVs[2];
	float GlobalVirtualTextureMipBias;
	uint VirtualTextureFeedbackShift;
	uint VirtualTextureFeedbackMask;
	uint VirtualTextureFeedbackStride;
	uint VirtualTextureFeedbackJitterOffset;
	uint VirtualTextureFeedbackSampleOffset;
	float4 RuntimeVirtualTextureMipLevel;
	float2 RuntimeVirtualTexturePackHeight;
	float4 RuntimeVirtualTextureDebugParams;
	int FarShadowStaticMeshLODBias;
	float MinRoughness;
	float4 HairRenderInfo;
	uint EnableSkyLight;
	uint HairRenderInfoBits;
	uint HairComponents;
	float bSubsurfacePostprocessEnabled;
	float4 SSProfilesTextureSizeAndInvSize;
	float4 SSProfilesPreIntegratedTextureSizeAndInvSize;
	float4 SpecularProfileTextureSizeAndInvSize;
	float3 PhysicsFieldClipmapCenter;
	float PhysicsFieldClipmapDistance;
	int PhysicsFieldClipmapResolution;
	int PhysicsFieldClipmapExponent;
	int PhysicsFieldClipmapCount;
	int PhysicsFieldTargetCount;
	int4 PhysicsFieldTargets[32];
	uint GPUSceneViewId;
	float ViewResolutionFraction;
	float SubSurfaceColorAsTransmittanceAtDistanceInMeters;
	float4 TanAndInvTanHalfFOV;
	float4 PrevTanAndInvTanHalfFOV;
	float2 WorldDepthToPixelWorldRadius;
	float4 ScreenRayLengthMultiplier;
	float4 GlintLUTParameters0;
	float4 GlintLUTParameters1;
	int4 EnvironmentComponentsFlags;
	FDFInverseMatrix WorldToClip;
	FDFMatrix ClipToWorld;
	FDFMatrix ScreenToWorld;
	FDFMatrix PrevClipToWorld;
	FDFVector3 WorldCameraOrigin;
	FDFVector3 WorldViewOrigin;
	FDFVector3 PrevWorldCameraOrigin;
	FDFVector3 PrevWorldViewOrigin;
	FDFVector3 PreViewTranslation;
	FDFVector3 PrevPreViewTranslation;
	ViewStateTileOffsetData TileOffset;
};
void FinalizeViewState(inout ViewState InOutView);
ViewState GetPrimaryView()
{
	ViewState Result;
	Result.TranslatedWorldToClip = View.TranslatedWorldToClip;
	Result.RelativeWorldToClip = View.RelativeWorldToClip;
	Result.ClipToRelativeWorld = View.ClipToRelativeWorld;
	Result.TranslatedWorldToView = View.TranslatedWorldToView;
	Result.ViewToTranslatedWorld = View.ViewToTranslatedWorld;
	Result.TranslatedWorldToCameraView = View.TranslatedWorldToCameraView;
	Result.CameraViewToTranslatedWorld = View.CameraViewToTranslatedWorld;
	Result.ViewToClip = View.ViewToClip;
	Result.ViewToClipNoAA = View.ViewToClipNoAA;
	Result.ClipToView = View.ClipToView;
	Result.ClipToTranslatedWorld = View.ClipToTranslatedWorld;
	Result.SVPositionToTranslatedWorld = View.SVPositionToTranslatedWorld;
	Result.ScreenToRelativeWorld = View.ScreenToRelativeWorld;
	Result.ScreenToTranslatedWorld = View.ScreenToTranslatedWorld;
	Result.MobileMultiviewShadowTransform = View.MobileMultiviewShadowTransform;
	Result.ViewOriginHigh = View.ViewOriginHigh;
	Result.ViewForward = View.ViewForward;
	Result.ViewUp = View.ViewUp;
	Result.ViewRight = View.ViewRight;
	Result.HMDViewNoRollUp = View.HMDViewNoRollUp;
	Result.HMDViewNoRollRight = View.HMDViewNoRollRight;
	Result.InvDeviceZToWorldZTransform = View.InvDeviceZToWorldZTransform;
	Result.ScreenPositionScaleBias = View.ScreenPositionScaleBias;
	Result.ViewOriginLow = View.ViewOriginLow;
	Result.TranslatedWorldCameraOrigin = View.TranslatedWorldCameraOrigin;
	Result.WorldViewOriginHigh = View.WorldViewOriginHigh;
	Result.WorldViewOriginLow = View.WorldViewOriginLow;
	Result.PreViewTranslationHigh = View.PreViewTranslationHigh;
	Result.PreViewTranslationLow = View.PreViewTranslationLow;
	Result.PrevViewToClip = View.PrevViewToClip;
	Result.PrevClipToView = View.PrevClipToView;
	Result.PrevTranslatedWorldToClip = View.PrevTranslatedWorldToClip;
	Result.PrevTranslatedWorldToView = View.PrevTranslatedWorldToView;
	Result.PrevViewToTranslatedWorld = View.PrevViewToTranslatedWorld;
	Result.PrevTranslatedWorldToCameraView = View.PrevTranslatedWorldToCameraView;
	Result.PrevCameraViewToTranslatedWorld = View.PrevCameraViewToTranslatedWorld;
	Result.PrevTranslatedWorldCameraOrigin = View.PrevTranslatedWorldCameraOrigin;
	Result.PrevWorldCameraOriginHigh = View.PrevWorldCameraOriginHigh;
	Result.PrevWorldCameraOriginLow = View.PrevWorldCameraOriginLow;
	Result.PrevWorldViewOriginHigh = View.PrevWorldViewOriginHigh;
	Result.PrevWorldViewOriginLow = View.PrevWorldViewOriginLow;
	Result.PrevPreViewTranslationHigh = View.PrevPreViewTranslationHigh;
	Result.PrevPreViewTranslationLow = View.PrevPreViewTranslationLow;
	Result.ViewTilePosition = View.ViewTilePosition;
	Result.RelativeWorldCameraOriginTO = View.RelativeWorldCameraOriginTO;
	Result.RelativeWorldViewOriginTO = View.RelativeWorldViewOriginTO;
	Result.RelativePreViewTranslationTO = View.RelativePreViewTranslationTO;
	Result.PrevRelativeWorldCameraOriginTO = View.PrevRelativeWorldCameraOriginTO;
	Result.PrevRelativeWorldViewOriginTO = View.PrevRelativeWorldViewOriginTO;
	Result.RelativePrevPreViewTranslationTO = View.RelativePrevPreViewTranslationTO;
	Result.PrevClipToRelativeWorld = View.PrevClipToRelativeWorld;
	Result.PrevScreenToTranslatedWorld = View.PrevScreenToTranslatedWorld;
	Result.ClipToPrevClip = View.ClipToPrevClip;
	Result.ClipToPrevClipWithAA = View.ClipToPrevClipWithAA;
	Result.TemporalAAJitter = View.TemporalAAJitter;
	Result.GlobalClippingPlane = View.GlobalClippingPlane;
	Result.FieldOfViewWideAngles = View.FieldOfViewWideAngles;
	Result.PrevFieldOfViewWideAngles = View.PrevFieldOfViewWideAngles;
	Result.ViewRectMin = View.ViewRectMin;
	Result.ViewSizeAndInvSize = View.ViewSizeAndInvSize;
	Result.ViewRectMinAndSize = View.ViewRectMinAndSize;
	Result.LightProbeSizeRatioAndInvSizeRatio = View.LightProbeSizeRatioAndInvSizeRatio;
	Result.BufferSizeAndInvSize = View.BufferSizeAndInvSize;
	Result.BufferBilinearUVMinMax = View.BufferBilinearUVMinMax;
	Result.ScreenToViewSpace = View.ScreenToViewSpace;
	Result.BufferToSceneTextureScale = View.BufferToSceneTextureScale;
	Result.ResolutionFractionAndInv = View.ResolutionFractionAndInv;
	Result.NumSceneColorMSAASamples = View.NumSceneColorMSAASamples;
	Result.ProjectionDepthThicknessScale = View.ProjectionDepthThicknessScale;
	Result.PreExposure = View.PreExposure;
	Result.OneOverPreExposure = View.OneOverPreExposure;
	Result.DiffuseOverrideParameter = View.DiffuseOverrideParameter;
	Result.SpecularOverrideParameter = View.SpecularOverrideParameter;
	Result.NormalOverrideParameter = View.NormalOverrideParameter;
	Result.RoughnessOverrideParameter = View.RoughnessOverrideParameter;
	Result.PrevFrameGameTime = View.PrevFrameGameTime;
	Result.PrevFrameRealTime = View.PrevFrameRealTime;
	Result.OutOfBoundsMask = View.OutOfBoundsMask;
	Result.WorldCameraMovementSinceLastFrame = View.WorldCameraMovementSinceLastFrame;
	Result.CullingSign = View.CullingSign;
	Result.NearPlane = View.NearPlane;
	Result.GameTime = View.GameTime;
	Result.RealTime = View.RealTime;
	Result.DeltaTime = View.DeltaTime;
	Result.MaterialTextureMipBias = View.MaterialTextureMipBias;
	Result.MaterialTextureDerivativeMultiply = View.MaterialTextureDerivativeMultiply;
	Result.Random = View.Random;
	Result.FrameNumber = View.FrameNumber;
	Result.FrameCounter = View.FrameCounter;
	Result.StateFrameIndexMod8 = View.StateFrameIndexMod8;
	Result.StateFrameIndex = View.StateFrameIndex;
	Result.DebugViewModeMask = View.DebugViewModeMask;
	Result.WorldIsPaused = View.WorldIsPaused;
	Result.CameraCut = View.CameraCut;
	Result.UnlitViewmodeMask = View.UnlitViewmodeMask;
	Result.DirectionalLightColor = View.DirectionalLightColor;
	Result.DirectionalLightDirection = View.DirectionalLightDirection;
	Result.TranslucencyLightingVolumeMin = View.TranslucencyLightingVolumeMin;
	Result.TranslucencyLightingVolumeInvSize = View.TranslucencyLightingVolumeInvSize;
	Result.TemporalAAParams = View.TemporalAAParams;
	Result.CircleDOFParams = View.CircleDOFParams;
	Result.DepthOfFieldSensorWidth = View.DepthOfFieldSensorWidth;
	Result.DepthOfFieldFocalDistance = View.DepthOfFieldFocalDistance;
	Result.DepthOfFieldScale = View.DepthOfFieldScale;
	Result.DepthOfFieldFocalLength = View.DepthOfFieldFocalLength;
	Result.DepthOfFieldFocalRegion = View.DepthOfFieldFocalRegion;
	Result.DepthOfFieldNearTransitionRegion = View.DepthOfFieldNearTransitionRegion;
	Result.DepthOfFieldFarTransitionRegion = View.DepthOfFieldFarTransitionRegion;
	Result.MotionBlurNormalizedToPixel = View.MotionBlurNormalizedToPixel;
	Result.GeneralPurposeTweak = View.GeneralPurposeTweak;
	Result.GeneralPurposeTweak2 = View.GeneralPurposeTweak2;
	Result.DemosaicVposOffset = View.DemosaicVposOffset;
	Result.DecalDepthBias = View.DecalDepthBias;
	Result.IndirectLightingColorScale = View.IndirectLightingColorScale;
	Result.PrecomputedIndirectLightingColorScale = View.PrecomputedIndirectLightingColorScale;
	Result.PrecomputedIndirectSpecularColorScale = View.PrecomputedIndirectSpecularColorScale;
	Result.AtmosphereLightDirection = View.AtmosphereLightDirection;
	Result.AtmosphereLightIlluminanceOnGroundPostTransmittance = View.AtmosphereLightIlluminanceOnGroundPostTransmittance;
	Result.AtmosphereLightIlluminanceOuterSpace = View.AtmosphereLightIlluminanceOuterSpace;
	Result.AtmosphereLightDiscLuminance = View.AtmosphereLightDiscLuminance;
	Result.AtmosphereLightDiscCosHalfApexAngle_PPTrans = View.AtmosphereLightDiscCosHalfApexAngle_PPTrans;
	Result.SkyViewLutSizeAndInvSize = View.SkyViewLutSizeAndInvSize;
	Result.SkyCameraTranslatedWorldOrigin = View.SkyCameraTranslatedWorldOrigin;
	Result.SkyPlanetTranslatedWorldCenterAndViewHeight = View.SkyPlanetTranslatedWorldCenterAndViewHeight;
	Result.SkyViewLutReferential = View.SkyViewLutReferential;
	Result.SkyAtmosphereSkyLuminanceFactor = View.SkyAtmosphereSkyLuminanceFactor;
	Result.SkyAtmospherePresentInScene = View.SkyAtmospherePresentInScene;
	Result.SkyAtmosphereHeightFogContribution = View.SkyAtmosphereHeightFogContribution;
	Result.SkyAtmosphereBottomRadiusKm = View.SkyAtmosphereBottomRadiusKm;
	Result.SkyAtmosphereTopRadiusKm = View.SkyAtmosphereTopRadiusKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize = View.SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	Result.SkyAtmosphereAerialPerspectiveStartDepthKm = View.SkyAtmosphereAerialPerspectiveStartDepthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	Result.SkyAtmosphereApplyCameraAerialPerspectiveVolume = View.SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	Result.NormalCurvatureToRoughnessScaleBias = View.NormalCurvatureToRoughnessScaleBias;
	Result.RenderingReflectionCaptureMask = View.RenderingReflectionCaptureMask;
	Result.RealTimeReflectionCapture = View.RealTimeReflectionCapture;
	Result.RealTimeReflectionCapturePreExposure = View.RealTimeReflectionCapturePreExposure;
	Result.AmbientCubemapTint = View.AmbientCubemapTint;
	Result.AmbientCubemapIntensity = View.AmbientCubemapIntensity;
	Result.SkyLightApplyPrecomputedBentNormalShadowingFlag = View.SkyLightApplyPrecomputedBentNormalShadowingFlag;
	Result.SkyLightAffectReflectionFlag = View.SkyLightAffectReflectionFlag;
	Result.SkyLightAffectGlobalIlluminationFlag = View.SkyLightAffectGlobalIlluminationFlag;
	Result.SkyLightColor = View.SkyLightColor;
	Result.SkyLightVolumetricScatteringIntensity = View.SkyLightVolumetricScatteringIntensity;
	Result.MobileSkyIrradianceEnvironmentMap = View.MobileSkyIrradianceEnvironmentMap;
	Result.MobilePreviewMode = View.MobilePreviewMode;
	Result.HMDEyePaddingOffset = View.HMDEyePaddingOffset;
	Result.ReflectionCubemapMaxMip = View.ReflectionCubemapMaxMip;
	Result.ShowDecalsMask = View.ShowDecalsMask;
	Result.DistanceFieldAOSpecularOcclusionMode = View.DistanceFieldAOSpecularOcclusionMode;
	Result.IndirectCapsuleSelfShadowingIntensity = View.IndirectCapsuleSelfShadowingIntensity;
	Result.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight = View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	Result.StereoPassIndex = View.StereoPassIndex;
	Result.GlobalVolumeTranslatedCenterAndExtent = View.GlobalVolumeTranslatedCenterAndExtent;
	Result.GlobalVolumeTranslatedWorldToUVAddAndMul = View.GlobalVolumeTranslatedWorldToUVAddAndMul;
	Result.GlobalDistanceFieldMipTranslatedWorldToUVScale = View.GlobalDistanceFieldMipTranslatedWorldToUVScale;
	Result.GlobalDistanceFieldMipTranslatedWorldToUVBias = View.GlobalDistanceFieldMipTranslatedWorldToUVBias;
	Result.GlobalDistanceFieldMipFactor = View.GlobalDistanceFieldMipFactor;
	Result.GlobalDistanceFieldMipTransition = View.GlobalDistanceFieldMipTransition;
	Result.GlobalDistanceFieldClipmapSizeInPages = View.GlobalDistanceFieldClipmapSizeInPages;
	Result.GlobalDistanceFieldInvPageAtlasSize = View.GlobalDistanceFieldInvPageAtlasSize;
	Result.GlobalDistanceFieldInvCoverageAtlasSize = View.GlobalDistanceFieldInvCoverageAtlasSize;
	Result.GlobalVolumeDimension = View.GlobalVolumeDimension;
	Result.GlobalVolumeTexelSize = View.GlobalVolumeTexelSize;
	Result.MaxGlobalDFAOConeDistance = View.MaxGlobalDFAOConeDistance;
	Result.NumGlobalSDFClipmaps = View.NumGlobalSDFClipmaps;
	Result.CoveredExpandSurfaceScale = View.CoveredExpandSurfaceScale;
	Result.NotCoveredExpandSurfaceScale = View.NotCoveredExpandSurfaceScale;
	Result.NotCoveredMinStepScale = View.NotCoveredMinStepScale;
	Result.DitheredTransparencyStepThreshold = View.DitheredTransparencyStepThreshold;
	Result.DitheredTransparencyTraceThreshold = View.DitheredTransparencyTraceThreshold;
	Result.CursorPosition = View.CursorPosition;
	Result.bCheckerboardSubsurfaceProfileRendering = View.bCheckerboardSubsurfaceProfileRendering;
	Result.VolumetricFogInvGridSize = View.VolumetricFogInvGridSize;
	Result.VolumetricFogGridZParams = View.VolumetricFogGridZParams;
	Result.VolumetricFogSVPosToVolumeUV = View.VolumetricFogSVPosToVolumeUV;
	Result.VolumetricFogViewGridUVToPrevViewRectUV = View.VolumetricFogViewGridUVToPrevViewRectUV;
	Result.VolumetricFogPrevViewGridRectUVToResourceUV = View.VolumetricFogPrevViewGridRectUVToResourceUV;
	Result.VolumetricFogPrevUVMax = View.VolumetricFogPrevUVMax;
	Result.VolumetricFogPrevUVMaxForTemporalBlend = View.VolumetricFogPrevUVMaxForTemporalBlend;
	Result.VolumetricFogScreenToResourceUV = View.VolumetricFogScreenToResourceUV;
	Result.VolumetricFogUVMax = View.VolumetricFogUVMax;
	Result.VolumetricFogMaxDistance = View.VolumetricFogMaxDistance;
	Result.VolumetricLightmapWorldToUVScale = View.VolumetricLightmapWorldToUVScale;
	Result.VolumetricLightmapWorldToUVAdd = View.VolumetricLightmapWorldToUVAdd;
	Result.VolumetricLightmapIndirectionTextureSize = View.VolumetricLightmapIndirectionTextureSize;
	Result.VolumetricLightmapBrickSize = View.VolumetricLightmapBrickSize;
	Result.VolumetricLightmapBrickTexelSize = View.VolumetricLightmapBrickTexelSize;
	Result.IndirectLightingCacheShowFlag = View.IndirectLightingCacheShowFlag;
	Result.EyeToPixelSpreadAngle = View.EyeToPixelSpreadAngle;
	Result.XRPassthroughCameraUVs = View.XRPassthroughCameraUVs;
	Result.GlobalVirtualTextureMipBias = View.GlobalVirtualTextureMipBias;
	Result.VirtualTextureFeedbackShift = View.VirtualTextureFeedbackShift;
	Result.VirtualTextureFeedbackMask = View.VirtualTextureFeedbackMask;
	Result.VirtualTextureFeedbackStride = View.VirtualTextureFeedbackStride;
	Result.VirtualTextureFeedbackJitterOffset = View.VirtualTextureFeedbackJitterOffset;
	Result.VirtualTextureFeedbackSampleOffset = View.VirtualTextureFeedbackSampleOffset;
	Result.RuntimeVirtualTextureMipLevel = View.RuntimeVirtualTextureMipLevel;
	Result.RuntimeVirtualTexturePackHeight = View.RuntimeVirtualTexturePackHeight;
	Result.RuntimeVirtualTextureDebugParams = View.RuntimeVirtualTextureDebugParams;
	Result.FarShadowStaticMeshLODBias = View.FarShadowStaticMeshLODBias;
	Result.MinRoughness = View.MinRoughness;
	Result.HairRenderInfo = View.HairRenderInfo;
	Result.EnableSkyLight = View.EnableSkyLight;
	Result.HairRenderInfoBits = View.HairRenderInfoBits;
	Result.HairComponents = View.HairComponents;
	Result.bSubsurfacePostprocessEnabled = View.bSubsurfacePostprocessEnabled;
	Result.SSProfilesTextureSizeAndInvSize = View.SSProfilesTextureSizeAndInvSize;
	Result.SSProfilesPreIntegratedTextureSizeAndInvSize = View.SSProfilesPreIntegratedTextureSizeAndInvSize;
	Result.SpecularProfileTextureSizeAndInvSize = View.SpecularProfileTextureSizeAndInvSize;
	Result.PhysicsFieldClipmapCenter = View.PhysicsFieldClipmapCenter;
	Result.PhysicsFieldClipmapDistance = View.PhysicsFieldClipmapDistance;
	Result.PhysicsFieldClipmapResolution = View.PhysicsFieldClipmapResolution;
	Result.PhysicsFieldClipmapExponent = View.PhysicsFieldClipmapExponent;
	Result.PhysicsFieldClipmapCount = View.PhysicsFieldClipmapCount;
	Result.PhysicsFieldTargetCount = View.PhysicsFieldTargetCount;
	Result.PhysicsFieldTargets = View.PhysicsFieldTargets;
	Result.GPUSceneViewId = View.GPUSceneViewId;
	Result.ViewResolutionFraction = View.ViewResolutionFraction;
	Result.SubSurfaceColorAsTransmittanceAtDistanceInMeters = View.SubSurfaceColorAsTransmittanceAtDistanceInMeters;
	Result.TanAndInvTanHalfFOV = View.TanAndInvTanHalfFOV;
	Result.PrevTanAndInvTanHalfFOV = View.PrevTanAndInvTanHalfFOV;
	Result.WorldDepthToPixelWorldRadius = View.WorldDepthToPixelWorldRadius;
	Result.ScreenRayLengthMultiplier = View.ScreenRayLengthMultiplier;
	Result.GlintLUTParameters0 = View.GlintLUTParameters0;
	Result.GlintLUTParameters1 = View.GlintLUTParameters1;
	Result.EnvironmentComponentsFlags = View.EnvironmentComponentsFlags;
	FinalizeViewState(Result);
	return Result;
}
void FinalizeViewState(inout ViewState InOutView)
{
	InOutView.WorldToClip = MakeDFInverseMatrix(InOutView.ViewOriginHigh, InOutView.RelativeWorldToClip);
	InOutView.ClipToWorld = MakeDFMatrix(InOutView.ViewOriginHigh, InOutView.ClipToRelativeWorld);
	InOutView.ScreenToWorld = MakeDFMatrix(InOutView.ViewOriginHigh, InOutView.ScreenToRelativeWorld);
	InOutView.PrevClipToWorld = MakeDFMatrix(InOutView.ViewOriginHigh, InOutView.PrevClipToRelativeWorld);
	InOutView.WorldCameraOrigin = MakeDFVector3(InOutView.ViewOriginHigh, InOutView.ViewOriginLow);
	InOutView.WorldViewOrigin = MakeDFVector3(InOutView.WorldViewOriginHigh, InOutView.WorldViewOriginLow);
	InOutView.PrevWorldCameraOrigin = MakeDFVector3(InOutView.PrevWorldCameraOriginHigh, InOutView.PrevWorldCameraOriginLow);
	InOutView.PrevWorldViewOrigin = MakeDFVector3(InOutView.PrevWorldViewOriginHigh, InOutView.PrevWorldViewOriginLow);
	InOutView.PreViewTranslation = MakeDFVector3(InOutView.PreViewTranslationHigh, InOutView.PreViewTranslationLow);
	InOutView.PrevPreViewTranslation = MakeDFVector3(InOutView.PrevPreViewTranslationHigh, InOutView.PrevPreViewTranslationLow);
	InOutView.TileOffset.WorldCameraOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.RelativeWorldCameraOriginTO);
	InOutView.TileOffset.WorldViewOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.RelativeWorldViewOriginTO);
	InOutView.TileOffset.PrevWorldCameraOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.PrevRelativeWorldCameraOriginTO);
	InOutView.TileOffset.PrevWorldViewOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.PrevRelativeWorldViewOriginTO);
	InOutView.TileOffset.PreViewTranslation = MakeLWCVector3(-InOutView.ViewTilePosition, InOutView.RelativePreViewTranslationTO);
	InOutView.TileOffset.PrevPreViewTranslation = MakeLWCVector3(-InOutView.ViewTilePosition, InOutView.RelativePrevPreViewTranslationTO);
}
static ViewState ResolvedView = (ViewState)0.0f;
ViewState ResolveView()
{
	return GetPrimaryView();
}
float4 Texture2DArraySample(Texture2DArray Tex, SamplerState Sampler, float3 UV)
{
	return Tex.Sample(Sampler, UV);
}
float4 Texture2DSampleLevel(Texture2D Tex, SamplerState Sampler, float2 UV, float Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4 Texture3DSampleLevel(Texture3D Tex, SamplerState Sampler, float3 UV, float Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4 TextureCubeSampleLevel(TextureCube Tex, SamplerState Sampler, float3 UV, float Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float Luminance( float3 LinearColor )
{
	return dot( LinearColor, float3( 0.3, 0.59, 0.11 ) );
}
float length2(float2 v)
{
	return dot(v, v);
}
float length2(float3 v)
{
	return dot(v, v);
}
float length2(float4 v)
{
	return dot(v, v);
}
float sqrtFast( float x )
{
	int i = asint(x);
	i = 0x1FBD1DF5 + (i >> 1);
	return asfloat(i);
}
float acosFast(float inX) 
{
    float x = abs(inX);
    float res = -0.156583f * x + (0.5 * PI);
    res *= sqrt(1.0f - x);
    return (inX >= 0) ? res : PI - res;
}
float2 acosFast( float2 x )
{
	return float2( acosFast(x.x), acosFast(x.y) );
}
float3 acosFast( float3 x )
{
	return float3( acosFast(x.x), acosFast(x.y), acosFast(x.z) );
}
float4 acosFast( float4 x )
{
	return float4( acosFast(x.x), acosFast(x.y), acosFast(x.z), acosFast(x.w) );
}
float asinFast( float x )
{
    return (0.5 * PI) - acosFast(x);
}
float2 asinFast( float2 x)
{
	return float2( asinFast(x.x), asinFast(x.y) );
}
float3 asinFast( float3 x)
{
	return float3( asinFast(x.x), asinFast(x.y), asinFast(x.z) );
}
float4 asinFast( float4 x )
{
	return float4( asinFast(x.x), asinFast(x.y), asinFast(x.z), asinFast(x.w) );
}
float FastExp( float x) { return exp2(1.442695f * x); }
float2 FastExp( float2 x) { return exp2(1.442695f * x); }
float3 FastExp( float3 x) { return exp2(1.442695f * x); }
float4 FastExp( float4 x) { return exp2(1.442695f * x); }
float InterleavedGradientNoise( float2 uv, float FrameId )
{
	uv += FrameId * (float2(47, 17) * 0.695f);
    const float3 magic = float3( 0.06711056f, 0.00583715f, 52.9829189f );
    return frac(magic.z * frac(dot(uv, magic.xy)));
}
float RandBBSfloat(float seed)
{
	float s = frac(seed / 4093);
	s = frac(s * s * 4093);
	s = frac(s * s * 4093);
	return s;
}
uint3 Rand3DPCG16(int3 p)
{
	uint3 v = uint3(p);
	v = v * 1664525u + 1013904223u;
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	return v >> 16u;
}
float3 NoiseTileWrap(float3 v,  bool bTiling, float RepeatSize)
{
	return bTiling ? (frac(v / RepeatSize) * RepeatSize) : v;
}
float4 PerlinRamp(float4 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10); 
}
float4 MGradient(int seed, float3 offset)
{
	uint rand = Rand3DPCG16(int3(seed,0,0)).x;
	float3 direction = float3(rand.xxx & int3(0x8000, 0x4000, 0x2000)) * float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000) - 1;
	return float4(direction, dot(direction, offset));
}
float3 NoiseSeeds(float3 v, bool bTiling, float RepeatSize,
	out float seed000, out float seed001, out float seed010, out float seed011,
	out float seed100, out float seed101, out float seed110, out float seed111)
{
	float3 fv = frac(v);
	float3 iv = floor(v);
	const float3 primes = float3(19, 47, 101);
	if (bTiling)
	{	
		seed000 = dot(primes, NoiseTileWrap(iv, true, RepeatSize));
		seed100 = dot(primes, NoiseTileWrap(iv + float3(1, 0, 0), true, RepeatSize));
		seed010 = dot(primes, NoiseTileWrap(iv + float3(0, 1, 0), true, RepeatSize));
		seed110 = dot(primes, NoiseTileWrap(iv + float3(1, 1, 0), true, RepeatSize));
		seed001 = dot(primes, NoiseTileWrap(iv + float3(0, 0, 1), true, RepeatSize));
		seed101 = dot(primes, NoiseTileWrap(iv + float3(1, 0, 1), true, RepeatSize));
		seed011 = dot(primes, NoiseTileWrap(iv + float3(0, 1, 1), true, RepeatSize));
		seed111 = dot(primes, NoiseTileWrap(iv + float3(1, 1, 1), true, RepeatSize));
	}
	else
	{	
		seed000 = dot(iv, primes);
		seed100 = seed000 + primes.x;
		seed010 = seed000 + primes.y;
		seed110 = seed100 + primes.y;
		seed001 = seed000 + primes.z;
		seed101 = seed100 + primes.z;
		seed011 = seed010 + primes.z;
		seed111 = seed110 + primes.z;
	}
	return fv;
}
float GradientNoise3D_ALU(float3 v, bool bTiling, float RepeatSize)
{
	float seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111;
	float3 fv = NoiseSeeds(v, bTiling, RepeatSize, seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111);
	float rand000 = MGradient(int(seed000), fv - float3(0, 0, 0)).w;
	float rand100 = MGradient(int(seed100), fv - float3(1, 0, 0)).w;
	float rand010 = MGradient(int(seed010), fv - float3(0, 1, 0)).w;
	float rand110 = MGradient(int(seed110), fv - float3(1, 1, 0)).w;
	float rand001 = MGradient(int(seed001), fv - float3(0, 0, 1)).w;
	float rand101 = MGradient(int(seed101), fv - float3(1, 0, 1)).w;
	float rand011 = MGradient(int(seed011), fv - float3(0, 1, 1)).w;
	float rand111 = MGradient(int(seed111), fv - float3(1, 1, 1)).w;
	float3 Weights = PerlinRamp(float4(fv, 0)).xyz;
	float i = lerp(lerp(rand000, rand100, Weights.x), lerp(rand010, rand110, Weights.x), Weights.y);
	float j = lerp(lerp(rand001, rand101, Weights.x), lerp(rand011, rand111, Weights.x), Weights.y);
	return lerp(i, j, Weights.z).x;
}
float ValueNoise3D_ALU(float3 v, bool bTiling, float RepeatSize)
{
	float seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111;
	float3 fv = NoiseSeeds(v, bTiling, RepeatSize, seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111);
	float rand000 = RandBBSfloat(seed000) * 2 - 1;
	float rand100 = RandBBSfloat(seed100) * 2 - 1;
	float rand010 = RandBBSfloat(seed010) * 2 - 1;
	float rand110 = RandBBSfloat(seed110) * 2 - 1;
	float rand001 = RandBBSfloat(seed001) * 2 - 1;
	float rand101 = RandBBSfloat(seed101) * 2 - 1;
	float rand011 = RandBBSfloat(seed011) * 2 - 1;
	float rand111 = RandBBSfloat(seed111) * 2 - 1;
	float3 Weights = PerlinRamp(float4(fv, 0)).xyz;
	float i = lerp(lerp(rand000, rand100, Weights.x), lerp(rand010, rand110, Weights.x), Weights.y);
	float j = lerp(lerp(rand001, rand101, Weights.x), lerp(rand011, rand111, Weights.x), Weights.y);
	return lerp(i, j, Weights.z).x;
}
float GradientNoise3D_TEX(float3 v, bool bTiling, float RepeatSize)
{
	bTiling = true;
	float3 fv = frac(v);
	float3 iv0 = NoiseTileWrap(floor(v), bTiling, RepeatSize);
	float3 iv1 = NoiseTileWrap(iv0 + 1, bTiling, RepeatSize);
	const int2 ZShear = int2(17, 89);
	float2 OffsetA = iv0.z * ZShear;
	float2 OffsetB = OffsetA + ZShear;	
	if (bTiling)						
	{
		OffsetB = iv1.z * ZShear;
	}
	float ts = 1 / 128.0f;
	float2 TexA0 = (iv0.xy + OffsetA + 0.5f) * ts;
	float2 TexB0 = (iv0.xy + OffsetB + 0.5f) * ts;
	float2 TexA1 = TexA0 + ts;	
	float2 TexB1 = TexB0 + ts;
	if (bTiling)				
	{
		TexA1 = (iv1.xy + OffsetA + 0.5f) * ts;
		TexB1 = (iv1.xy + OffsetB + 0.5f) * ts;
	}
	float3 A = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA0.x, TexA0.y), 0).xyz * 2 - 1;
	float3 B = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA1.x, TexA0.y), 0).xyz * 2 - 1;
	float3 C = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA0.x, TexA1.y), 0).xyz * 2 - 1;
	float3 D = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA1.x, TexA1.y), 0).xyz * 2 - 1;
	float3 E = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB0.x, TexB0.y), 0).xyz * 2 - 1;
	float3 F = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB1.x, TexB0.y), 0).xyz * 2 - 1;
	float3 G = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB0.x, TexB1.y), 0).xyz * 2 - 1;
	float3 H = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB1.x, TexB1.y), 0).xyz * 2 - 1;
	float a = dot(A, fv - float3(0, 0, 0));
	float b = dot(B, fv - float3(1, 0, 0));
	float c = dot(C, fv - float3(0, 1, 0));
	float d = dot(D, fv - float3(1, 1, 0));
	float e = dot(E, fv - float3(0, 0, 1));
	float f = dot(F, fv - float3(1, 0, 1));
	float g = dot(G, fv - float3(0, 1, 1));
	float h = dot(H, fv - float3(1, 1, 1));
	float3 Weights = PerlinRamp(frac(float4(fv, 0))).xyz;
	float i = lerp(lerp(a, b, Weights.x), lerp(c, d, Weights.x), Weights.y);
	float j = lerp(lerp(e, f, Weights.x), lerp(g, h, Weights.x), Weights.y);
	return lerp(i, j, Weights.z);
}
float FastGradientPerlinNoise3D_TEX(float3 xyz)
{
	float Extent = 16;
	xyz = frac(xyz / (Extent - 1)) * (Extent - 1);
	float3 uvw = frac(xyz);
	float3 p0 = xyz - uvw;
	float3 f = PerlinRamp(float4(uvw, 0)).xyz;	
	float3 p = p0 + f;
	float4 NoiseSample = Texture3DSampleLevel(View_PerlinNoise3DTexture, View_PerlinNoise3DTextureSampler, p / Extent + 0.5f / Extent, 0);		
	float3 n = NoiseSample.xyz * 255.0f / 127.0f - 1.0f;
	float d = NoiseSample.w * 255.f - 127;
	return dot(xyz, n) - d;
}
float3 VoronoiCornerSample(float3 pos, int Quality)
{
	float3 noise = float3(Rand3DPCG16(int3(pos))) / 0xffff - 0.5;
	if (Quality <= 2)
	{
		return normalize(noise) * 0.2588;
	}
	if (Quality == 3)
	{
		return normalize(noise) * 0.3090;
	}
	return noise;
}
float4 VoronoiCompare(float4 minval, float3 candidate, float3 offset, bool bDistanceOnly)
{
	if (bDistanceOnly)
	{
		return float4(0, 0, 0, min(minval.w, dot(offset, offset)));
	}
	else
	{
		float newdist = dot(offset, offset);
		return newdist > minval.w ? minval : float4(candidate, newdist);
	}
}
float4 VoronoiNoise3D_ALU(float3 v, int Quality, bool bTiling, float RepeatSize, bool bDistanceOnly)
{
	float3 fv = frac(v),  fv2 = frac(v + 0.5);
	float3 iv = floor(v), iv2 = floor(v + 0.5);
	float4 mindist = float4(0,0,0,100);
	float3 p, offset;
	if (Quality == 3)
	{
		 [unroll( 3 )] for (offset.x = -1; offset.x <= 1; ++offset.x)
		{
			 [unroll( 3 )] for (offset.y = -1; offset.y <= 1; ++offset.y)
			{
				 [unroll( 3 )] for (offset.z = -1; offset.z <= 1; ++offset.z)
				{
					p = offset + VoronoiCornerSample(NoiseTileWrap(iv2 + offset, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv2 + p, fv2 - p, bDistanceOnly);
				}
			}
		}
	}
	else
	{
		 [unroll( 2 )] for (offset.x = 0; offset.x <= 1; ++offset.x)
		{
			 [unroll( 2 )] for (offset.y = 0; offset.y <= 1; ++offset.y)
			{
				 [unroll( 2 )] for (offset.z = 0; offset.z <= 1; ++offset.z)
				{
					p = offset + VoronoiCornerSample(NoiseTileWrap(iv + offset, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);
					if (Quality == 2)
					{
						p = offset + VoronoiCornerSample(NoiseTileWrap(iv2 + offset, bTiling, RepeatSize) + 467, Quality);
						mindist = VoronoiCompare(mindist, iv2 + p, fv2 - p, bDistanceOnly);
					}
				}
			}
		}
	}
	if (Quality >= 4)
	{
		 [unroll( 2 )] for (offset.x = -1; offset.x <= 2; offset.x += 3)
		{
			 [unroll( 2 )] for (offset.y = 0; offset.y <= 1; ++offset.y)
			{
				 [unroll( 2 )] for (offset.z = 0; offset.z <= 1; ++offset.z)
				{
					p = offset.xyz + VoronoiCornerSample(NoiseTileWrap(iv + offset.xyz, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);
					p = offset.yzx + VoronoiCornerSample(NoiseTileWrap(iv + offset.yzx, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);
					p = offset.zxy + VoronoiCornerSample(NoiseTileWrap(iv + offset.zxy, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);
				}
			}
		}
	}
	return float4(mindist.xyz, sqrt(mindist.w));
}
float4 ComputeSimplexWeights3D(float3 OrthogonalPos, out float3 PosA, out float3 PosB, out float3 PosC, out float3 PosD)
{
	float3 OrthogonalPosFloor = floor(OrthogonalPos);
	PosA = OrthogonalPosFloor;
	PosB = PosA + float3(1, 1, 1);
	OrthogonalPos -= OrthogonalPosFloor;
	float Largest = max(OrthogonalPos.x, max(OrthogonalPos.y, OrthogonalPos.z));
	float Smallest = min(OrthogonalPos.x, min(OrthogonalPos.y, OrthogonalPos.z));
	PosC = PosA + float3(Largest == OrthogonalPos.x, Largest == OrthogonalPos.y, Largest == OrthogonalPos.z);
	PosD = PosA + float3(Smallest != OrthogonalPos.x, Smallest != OrthogonalPos.y, Smallest != OrthogonalPos.z);
	float4 ret;
	float RG = OrthogonalPos.x - OrthogonalPos.y;
	float RB = OrthogonalPos.x - OrthogonalPos.z;
	float GB = OrthogonalPos.y - OrthogonalPos.z;
	ret.b = 
		  min(max(0, RG), max(0, RB))		
		+ min(max(0, -RG), max(0, GB))		
		+ min(max(0, -RB), max(0, -GB));	
	ret.a = 
		  min(max(0, -RG), max(0, -RB))		
		+ min(max(0, RG), max(0, -GB))		
		+ min(max(0, RB), max(0, GB));		
	ret.g = Smallest;
	ret.r = 1.0f - ret.g - ret.b - ret.a;
	return ret;
}
float2 GetPerlinNoiseGradientTextureAt(float2 v)
{
	float2 TexA = (v.xy + 0.5f) / 128.0f;
	float3 p = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, TexA, 0).xyz * 2 - 1;
	return normalize(p.xy + p.z * 0.33f);
}
float3 GetPerlinNoiseGradientTextureAt(float3 v)
{
	const float2 ZShear = float2(17.0f, 89.0f);
	float2 OffsetA = v.z * ZShear;
	float2 TexA = (v.xy + OffsetA + 0.5f) / 128.0f;
	return Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, TexA , 0).xyz * 2 - 1;
}
float2 SkewSimplex(float2 In)
{
	return In + dot(In, (sqrt(3.0f) - 1.0f) * 0.5f );
}
float2 UnSkewSimplex(float2 In)
{
	return In - dot(In, (3.0f - sqrt(3.0f)) / 6.0f );
}
float3 SkewSimplex(float3 In)
{
	return In + dot(In, 1.0 / 3.0f );
}
float3 UnSkewSimplex(float3 In)
{
	return In - dot(In, 1.0 / 6.0f );
}
float SimplexNoise3D_TEX(float3 EvalPos)
{
	float3 OrthogonalPos = SkewSimplex(EvalPos);
	float3 PosA, PosB, PosC, PosD;
	float4 Weights = ComputeSimplexWeights3D(OrthogonalPos, PosA, PosB, PosC, PosD);
	float3 A = GetPerlinNoiseGradientTextureAt(PosA);
	float3 B = GetPerlinNoiseGradientTextureAt(PosB);
	float3 C = GetPerlinNoiseGradientTextureAt(PosC);
	float3 D = GetPerlinNoiseGradientTextureAt(PosD);
	PosA = UnSkewSimplex(PosA);
	PosB = UnSkewSimplex(PosB);
	PosC = UnSkewSimplex(PosC);
	PosD = UnSkewSimplex(PosD);
	float DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosA));	DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float a = dot(A, EvalPos - PosA) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosB));	DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float b = dot(B, EvalPos - PosB) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosC));	DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float c = dot(C, EvalPos - PosC) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosD));	DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float d = dot(D, EvalPos - PosD) * DistanceWeight;
	return 32 * (a + b + c + d);
}
float Square( float x )
{
	return x*x;
}
float2 Square( float2 x )
{
	return x*x;
}
float3 Square( float3 x )
{
	return x*x;
}
float4 Square( float4 x )
{
	return x*x;
}
float Pow2( float x )
{
	return x*x;
}
float2 Pow2( float2 x )
{
	return x*x;
}
float3 Pow2( float3 x )
{
	return x*x;
}
float4 Pow2( float4 x )
{
	return x*x;
}
float Pow4( float x )
{
	float xx = x*x;
	return xx * xx;
}
float2 Pow4( float2 x )
{
	float2 xx = x*x;
	return xx * xx;
}
float3 Pow4( float3 x )
{
	float3 xx = x*x;
	return xx * xx;
}
float4 Pow4( float4 x )
{
	float4 xx = x*x;
	return xx * xx;
}
float Pow5( float x )
{
	float xx = x*x;
	return xx * xx * x;
}
float2 Pow5( float2 x )
{
	float2 xx = x*x;
	return xx * xx * x;
}
float3 Pow5( float3 x )
{
	float3 xx = x*x;
	return xx * xx * x;
}
float4 Pow5( float4 x )
{
	float4 xx = x*x;
	return xx * xx * x;
}
bool IsOrthoProjection(float4x4 ViewToClip)
{
	return ViewToClip._44 >= 1.0f;
}
bool IsOrthoProjection(ViewState InView)
{
	return IsOrthoProjection(InView.ViewToClip);
}
bool IsOrthoProjection()
{
	return IsOrthoProjection(View.ViewToClip);
}
float ConvertToDeviceZ(float SceneDepth)
{
	[flatten]
	if (IsOrthoProjection())
	{
		return SceneDepth * View.ViewToClip[2][2] + View.ViewToClip[3][2];
	}
	else
	{
		return 1.0f / ((SceneDepth + View.InvDeviceZToWorldZTransform[3]) * View.InvDeviceZToWorldZTransform[2]);
	}
}
float2 ScreenPositionToBufferUV(float4 ScreenPosition)
{
	return float2(ScreenPosition.xy / ScreenPosition.w * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz);
}
float2 SvPositionToBufferUV(float4 SvPosition)
{
	return SvPosition.xy * View.BufferSizeAndInvSize.zw;
}
float3 SvPositionToResolvedTranslatedWorld(float4 SvPosition)
{
	float4 HomWorldPos = mul(float4(SvPosition.xyz, 1), ResolvedView.SVPositionToTranslatedWorld);
	return HomWorldPos.xyz / HomWorldPos.w;
}
float4 SvPositionToResolvedScreenPosition(float4 SvPosition)
{
	float2 PixelPos = SvPosition.xy - ResolvedView.ViewRectMin.xy;	
	float3 NDCPos = float3( (PixelPos * ResolvedView.ViewSizeAndInvSize.zw - 0.5f) * float2(2, -2), SvPosition.z);
	return float4(NDCPos.xyz, 1) * SvPosition.w;
}
float2 SvPositionToViewportUV(float4 SvPosition)
{
	float2 PixelPos = SvPosition.xy - ResolvedView.ViewRectMin.xy;	
	return PixelPos.xy * ResolvedView.ViewSizeAndInvSize.zw;
}
float2 BufferUVToViewportUV(float2 BufferUV)
{
	float2 PixelPos = BufferUV.xy * View.BufferSizeAndInvSize.xy - View.ViewRectMin.xy;
	return PixelPos.xy * View.ViewSizeAndInvSize.zw;
}
float2 ScreenPosToViewportUV(float2 ScreenPos)
{
	return float2(0.5 + 0.5 * ScreenPos.x, 0.5 - 0.5 * ScreenPos.y);
}
float2 ScreenAlignedPosition( float4 ScreenPosition )
{
	return float2(ScreenPositionToBufferUV(ScreenPosition));
}
float Noise3D_Multiplexer(int Function, float3 Position, int Quality, bool bTiling, float RepeatSize)
{
	switch(Function)
	{
		case 0:
			return SimplexNoise3D_TEX(Position);
		case 1:
			return GradientNoise3D_TEX(Position, bTiling, RepeatSize);
		case 2:
			return FastGradientPerlinNoise3D_TEX(Position);
		case 3:
			return GradientNoise3D_ALU(Position, bTiling, RepeatSize);
		case 4:
			return ValueNoise3D_ALU(Position, bTiling, RepeatSize);
		default:
			return VoronoiNoise3D_ALU(Position, Quality, bTiling, RepeatSize, true).w * 2. - 1.;
	}
	return 0;
}
float MaterialExpressionNoise(float3 Position, float Scale, int Quality, int Function, bool bTurbulence, uint Levels, float OutputMin, float OutputMax, float LevelScale, float FilterWidth, bool bTiling, float RepeatSize)
{
	Position *= Scale;
	FilterWidth *= Scale;
	float Out = 0.0f;
	float OutScale = 1.0f;
	float InvLevelScale = 1.0f / LevelScale;
	[loop] for(uint i = 0; i < Levels; ++i)
	{
		OutScale *= saturate(1.0 - FilterWidth);
		if(bTurbulence)
		{
			Out += abs(Noise3D_Multiplexer(Function, Position, Quality, bTiling, RepeatSize)) * OutScale;
		}
		else
		{
			Out += Noise3D_Multiplexer(Function, Position, Quality, bTiling, RepeatSize) * OutScale;
		}
		Position *= LevelScale;
		RepeatSize *= LevelScale;
		OutScale *= InvLevelScale;
		FilterWidth *= LevelScale;
	}
	if(!bTurbulence)
	{
		Out = Out * 0.5f + 0.5f;
	}
	return lerp(OutputMin, OutputMax, Out);
}
float MaterialExpressionNoise(FDFVector3 LWCPosition, float Scale, int Quality, int Function, bool bTurbulence, uint Levels, float OutputMin, float OutputMax, float LevelScale, float FilterWidth, bool bTiling, float RepeatSize)
{
	const float TileSize = 65536;
	float3 Position = abs(TileSize * DFFracDemote(DFDivideByPow2(LWCPosition, TileSize))); 
	return MaterialExpressionNoise(Position, Scale, Quality, Function, bTurbulence, Levels, OutputMin, OutputMax, LevelScale, FilterWidth, bTiling, RepeatSize);
}
float MaterialExpressionNoise(FLWCVector3 LWCPosition, float Scale, int Quality, int Function, bool bTurbulence, uint Levels, float OutputMin, float OutputMax, float LevelScale, float FilterWidth, bool bTiling, float RepeatSize)
{
	float3 Position = LWCNormalizeTile(LWCPosition).Offset;
	return MaterialExpressionNoise(Position, Scale, Quality, Function, bTurbulence, Levels, OutputMin, OutputMax, LevelScale, FilterWidth, bTiling, RepeatSize);
}
float ComputeDistanceFromBoxToPoint(float3 Mins, float3 Maxs, float3 InPoint)
{
	float3 DistancesToMin =  select_internal( InPoint < Mins , abs(InPoint - Mins) , float(0.0) );
	float3 DistancesToMax =  select_internal( InPoint > Maxs , abs(InPoint - Maxs) , float(0.0) );
	float Distance = dot(DistancesToMin, 1);
	Distance += dot(DistancesToMax, 1);
	return Distance;
}
float2 RayIntersectSphere(float3 RayOrigin, float3 RayDirection, float4 Sphere)
{
	float3 LocalPosition = RayOrigin - Sphere.xyz;
	float LocalPositionSqr = dot(LocalPosition, LocalPosition);
	float3 QuadraticCoef;
	QuadraticCoef.x = dot(RayDirection, RayDirection);
	QuadraticCoef.y = 2 * dot(RayDirection, LocalPosition);
	QuadraticCoef.z = LocalPositionSqr - Sphere.w * Sphere.w;
	float Discriminant = QuadraticCoef.y * QuadraticCoef.y - 4 * QuadraticCoef.x * QuadraticCoef.z;
	float2 Intersections = -1;
	[flatten]
	if (Discriminant >= 0)
	{
		float SqrtDiscriminant = sqrt(Discriminant);
		Intersections = (-QuadraticCoef.y + float2(-1, 1) * SqrtDiscriminant) / (2 * QuadraticCoef.x);
	}
	return Intersections;
}
float3 TransformTangentVectorToWorld(float3x3 TangentToWorld, float3 InTangentVector)
{
	return mul(InTangentVector, TangentToWorld);
}
float3 DecodeVelocityFromTexture(float4 InEncodedV)
{
	float4 EncodedV = InEncodedV;
	const float InvDiv = 1.0f / (0.499f * 0.5f);
	float3 V;
	V.xy = EncodedV.xy * InvDiv - 32767.0f / 65535.0f * InvDiv;
		V.z = asfloat((uint(round(EncodedV.z * 65535.0f)) << 16) | (uint(round(EncodedV.w * 65535.0f)) & 0xFFFE));
		V.xy = (V.xy * abs(V.xy)) * 0.5;
	return V;
}
float SafeSaturate( float In) {	return saturate(In);}
float2 SafeSaturate( float2 In) {	return saturate(In);}
float3 SafeSaturate( float3 In) {	return saturate(In);}
float4 SafeSaturate( float4 In) {	return saturate(In);}
struct FPixelShaderIn
{
	float4 SvPosition;
	uint Coverage;
	bool bIsFrontFace;
};
struct FPixelShaderOut
{
	float4 MRT[8];
	uint SubstrateOutput[3];
	uint SubstrateTopLayerData;
	uint Coverage;
	float Depth;
};
struct FTwoBandSHVector
{
	float4 V;
};
struct FTwoBandSHVectorRGB
{
	FTwoBandSHVector R;
	FTwoBandSHVector G;
	FTwoBandSHVector B;
};
float DotSH(FTwoBandSHVector A,FTwoBandSHVector B)
{
	float Result = dot(A.V, B.V);
	return Result;
}
float3 DotSH(FTwoBandSHVectorRGB A,FTwoBandSHVector B)
{
	float3 Result = 0;
	Result.r = DotSH(A.R,B);
	Result.g = DotSH(A.G,B);
	Result.b = DotSH(A.B,B);
	return Result;
}
FTwoBandSHVector SHBasisFunction(float3 InputVector)
{
	FTwoBandSHVector Result;
	Result.V.x = 0.282095f; 
	Result.V.y = -0.488603f * InputVector.y;
	Result.V.z = 0.488603f * InputVector.z;
	Result.V.w = -0.488603f * InputVector.x;
	return Result;
}
FTwoBandSHVector CalcDiffuseTransferSH(float3 Normal,float Exponent)
{
	FTwoBandSHVector Result = SHBasisFunction(Normal);
	float L0 =					2 * PI / (1 + 1 * Exponent							);
	float L1 =					2 * PI / (2 + 1 * Exponent							);
	Result.V.x *= L0;
	Result.V.yzw *= L1;
	return Result;
}
FLWCScalar DFToWS(FDFScalar In) { return DFToTileOffset(In); }
FLWCScalar DFFastToWS(FDFScalar In) { return DFFastToTileOffset(In); }
FLWCVector2 DFToWS(FDFVector2 In) { return DFToTileOffset(In); }
FLWCVector2 DFFastToWS(FDFVector2 In) { return DFFastToTileOffset(In); }
FLWCVector3 DFToWS(FDFVector3 In) { return DFToTileOffset(In); }
FLWCVector3 DFFastToWS(FDFVector3 In) { return DFFastToTileOffset(In); }
FLWCVector4 DFToWS(FDFVector4 In) { return DFToTileOffset(In); }
FLWCVector4 DFFastToWS(FDFVector4 In) { return DFFastToTileOffset(In); }
FLWCMatrix DFToWS(FDFMatrix In) { return DFToTileOffset(In); }
FLWCMatrix DFFastToWS(FDFMatrix In) { return DFFastToTileOffset(In); }
FLWCInverseMatrix DFToWS(FDFInverseMatrix In) { return DFToTileOffset(In); }
FLWCInverseMatrix DFFastToWS(FDFInverseMatrix In) { return DFFastToTileOffset(In); }
float DFToWS( float In) { return In; }
float2 DFToWS( float2 In) { return In; }
float3 DFToWS( float3 In) { return In; }
float4 DFToWS( float4 In) { return In; }
uint2 SobolPixel(uint2 Pixel)
{
	int3 SobolLo = int3(Pixel & 0xfu, 0);
	int3 SobolHi = int3((Pixel >> 4u) & 0xfu, 0) + int3(16, 0, 0);
	uint Packed = View_SobolSamplingTexture.Load(SobolLo) ^ View_SobolSamplingTexture.Load(SobolHi);
	return uint2(Packed, Packed << 8u) & 0xff00u;
}
uint2 SobolIndex(uint2 Base, int Index, int Bits = 10)
{
	uint2 SobolNumbers[10] = {
		uint2(0x8680u, 0x4c80u), uint2(0xf240u, 0x9240u), uint2(0x8220u, 0x0e20u), uint2(0x4110u, 0x1610u), uint2(0xa608u, 0x7608u),
		uint2(0x8a02u, 0x280au), uint2(0xe204u, 0x9e04u), uint2(0xa400u, 0x4682u), uint2(0xe300u, 0xa74du), uint2(0xb700u, 0x9817u),
	};
	uint2 Result = Base;
	[unroll] for (int b = 0; b < 10 && b < Bits; ++b)
	{
		Result ^= (Index & (1u << b)) ? SobolNumbers[b] : 0;
	}
	return Result;
}
float3x3 GetTangentBasis( float3 TangentZ )
{
	const float Sign = TangentZ.z >= 0 ? 1 : -1;
	const float a = -rcp( Sign + TangentZ.z );
	const float b = TangentZ.x * TangentZ.y * a;
	float3 TangentX = { 1 + Sign * a * Pow2( TangentZ.x ), Sign * b, -Sign * TangentZ.x };
	float3 TangentY = { b,  Sign + a * Pow2( TangentZ.y ), -TangentZ.y };
	return float3x3( TangentX, TangentY, TangentZ );
}
float3 TangentToWorld( float3 Vec, float3 TangentZ )
{
	return mul( Vec, GetTangentBasis( TangentZ ) );
}
float2 InverseEquiAreaSphericalMapping(float3 Direction)
{
	Direction = normalize(Direction);
	float3 AbsDir = abs(Direction);
	float R = sqrt(1 - AbsDir.z);
	float Epsilon = 5.42101086243e-20; 
	float x = min(AbsDir.x, AbsDir.y) / (max(AbsDir.x, AbsDir.y) + Epsilon);
	const float t1 = 0.406758566246788489601959989e-5f;
	const float t2 = 0.636226545274016134946890922156f;
	const float t3 = 0.61572017898280213493197203466e-2f;
	const float t4 = -0.247333733281268944196501420480f;
	const float t5 = 0.881770664775316294736387951347e-1f;
	const float t6 = 0.419038818029165735901852432784e-1f;
	const float t7 = -0.251390972343483509333252996350e-1f;
	float Phi = t6 + t7 * x;
	Phi = t5 + Phi * x;
	Phi = t4 + Phi * x;
	Phi = t3 + Phi * x;
	Phi = t2 + Phi * x;
	Phi = t1 + Phi * x;
	Phi = (AbsDir.x < AbsDir.y) ? 1 - Phi : Phi;
	float2 UV = float2(R - Phi * R, Phi * R);
	UV = (Direction.z < 0) ? 1 - UV.yx : UV;
	UV = asfloat(asuint(UV) ^ (asuint(Direction.xy) & 0x80000000u));
	return UV * 0.5 + 0.5;
}
float4 UniformSampleSphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = 1 - 2 * E.y;
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );
	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;
	float PDF = 1.0 / (4 * PI);
	return float4( H, PDF );
}
float4 CosineSampleHemisphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = sqrt(E.y);
	float SinTheta = sqrt(1 - CosTheta * CosTheta);
	float3 H;
	H.x = SinTheta * cos(Phi);
	H.y = SinTheta * sin(Phi);
	H.z = CosTheta;
	float PDF = CosTheta * (1.0 / PI);
	return float4(H, PDF);
}
float4 CosineSampleHemisphere( float2 E, float3 N ) 
{
	float3 H = UniformSampleSphere( E ).xyz;
	H = normalize( N + H );
	float PDF = dot(H, N) * (1.0 /  PI);
	return float4( H, PDF );
}
float4 UniformSampleConeRobust(float2 E, float SinThetaMax2)
{
	float Phi = 2 * PI * E.x;
	float OneMinusCosThetaMax = SinThetaMax2 < 0.01 ? SinThetaMax2 * (0.5 + 0.125 * SinThetaMax2) : 1 - sqrt(1 - SinThetaMax2);
	float CosTheta = 1 - OneMinusCosThetaMax * E.y;
	float SinTheta = sqrt(1 - CosTheta * CosTheta);
	float3 L;
	L.x = SinTheta * cos(Phi);
	L.y = SinTheta * sin(Phi);
	L.z = CosTheta;
	float PDF = 1.0 / (2 * PI * OneMinusCosThetaMax);
	return float4(L, PDF);
}
float UniformConeSolidAngle(float SinThetaMax2)
{
	float OneMinusCosThetaMax = SinThetaMax2 < 0.01 ? SinThetaMax2 * (0.5 + 0.125 * SinThetaMax2) : 1 - sqrt(1 - SinThetaMax2);
	return 2 * PI * OneMinusCosThetaMax;
}
float4 ImportanceSampleGGX( float2 E, float a2 )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = sqrt( (1 - E.y) / ( 1 + (a2 - 1) * E.y ) );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );
	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;
	float d = ( CosTheta * a2 - CosTheta ) * CosTheta + 1;
	float D = a2 / ( PI*d*d );
	float PDF = D * CosTheta;
	return float4( H, PDF );
}
float2 UnitVectorToOctahedron( float3 N )
{
	N.xy /= dot( 1, abs(N) );
	if( N.z <= 0 )
	{
		N.xy = ( 1 - abs(N.yx) ) *  select_internal( N.xy >= 0 , float2(1,1) , float2(-1,-1) );
	}
	return N.xy;
}
float3 OctahedronToUnitVector( float2 Oct )
{
	float3 N = float3( Oct, 1 - dot( 1, abs(Oct) ) );
	float t = max( -N.z, 0 );
	N.xy +=  select_internal( N.xy >= 0 , float2(-t, -t) , float2(t, t) );
	return normalize(N);
}
struct FPrimitiveSceneData
{
	uint		Flags;
	uint		VisibilityFlags;
	int			InstanceSceneDataOffset; 
	int			NumInstanceSceneDataEntries;
	int			PersistentPrimitiveIndex;
	uint		SingleCaptureIndex; 
	float3		PositionHigh;
	uint		PrimitiveComponentId; 
	FDFMatrix	LocalToWorld;
	FDFInverseMatrix WorldToLocal;
	FDFMatrix	PreviousLocalToWorld;
	FDFInverseMatrix PreviousWorldToLocal;
	float4x4	WorldToPreviousWorld; 
	float3		InvNonUniformScale;
	float		ObjectBoundsX;
	FDFVector3	ObjectWorldPosition;
	FDFVector3	ActorWorldPosition;
	float		MinMaterialDisplacement;
	float		MaxMaterialDisplacement;
	FLWCVector3	ObjectWorldPositionTO;
	FLWCVector3	ActorWorldPositionTO;
	float		ObjectRadius;
	uint		LightmapUVIndex;   
	float3		ObjectOrientation; 
	uint		LightmapDataIndex; 
	float4		NonUniformScale;
	float3		PreSkinnedLocalBoundsMin;
	uint		NaniteResourceID;
	float3		PreSkinnedLocalBoundsMax;
	uint		NaniteHierarchyOffset;
	float3		LocalObjectBoundsMin;
	float		ObjectBoundsY;
	float3		LocalObjectBoundsMax;
	float		ObjectBoundsZ;
	uint		InstancePayloadDataOffset;
	uint		InstancePayloadDataStride;
	uint		InstancePayloadExtensionSize;
	float3		InstanceLocalBoundsCenter;
	float3		InstanceLocalBoundsExtent;
	float3		WireframeColor; 
	float3		PrimitiveColor; 
	uint		PackedNaniteFlags;
	float2 		InstanceDrawDistanceMinMaxSquared;
	float		InstanceWPODisableDistanceSquared;
	uint		NaniteRayTracingDataOffset;
	float		MaxWPOExtent;
	uint		CustomStencilValueAndMask;
	float4		CustomPrimitiveData[9u]; 
};
float3 UnpackColorRGB24(float PackedColorFloat)
{
	uint PackedColor = asuint(PackedColorFloat);
	return float3
	(
		float((PackedColor >> 24u) & 0xFF),
		float((PackedColor >> 16u) & 0xFF),
		float((PackedColor >>  8u) & 0xFF)
	) * (1.0f / 255.0f);
}
struct FInstanceSceneEditorData
{
	float3 HitProxyId;
	uint   HitProxyPacked;
	bool bIsSelected;
};
struct FInstanceSceneData
{
	FDFMatrix LocalToWorld;
	FDFMatrix PrevLocalToWorld;
	FDFInverseMatrix WorldToLocal;
	float4   NonUniformScale;
	float3   InvNonUniformScale;
	float    DeterminantSign;
	float3   LocalBoundsCenter;
	uint     PrimitiveId;
	uint     RelativeId;
	uint     PayloadDataOffset;
	uint     PayloadExtensionOffset;
	uint     PayloadExtensionSize;
	float3   LocalBoundsExtent;
	uint     LastUpdateSceneFrameNumber;
	uint     NaniteRuntimeResourceID;
	uint     NaniteHierarchyOffset;
	float    RandomID;
	float4   LightMapAndShadowMapUVBias;
	bool     ValidInstance;
	uint     Flags;
	FInstanceSceneEditorData EditorData;
};
float4 LoadPrimitivePrimitiveSceneDataElement(uint PrimitiveIndex, uint ItemIndex)
{
	uint TargetIdx = PrimitiveIndex + ItemIndex;
	 { };
	return Scene_GPUScene_GPUScenePrimitiveSceneData[TargetIdx];
}
FPrimitiveSceneData GetPrimitiveData(uint PrimitiveId)
{
	FPrimitiveSceneData PrimitiveData = (FPrimitiveSceneData)0;
	uint PrimitiveIndex = PrimitiveId * 42;
	float3 PositionHigh = LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 1).xyz;
	const float4x4 LocalToWorld = transpose(float4x4(
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 2),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 3),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 4),
		float4(0, 0, 0, 1)
	));
	const float4x4 PreviousLocalToWorld = transpose(float4x4(
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 8),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 9),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 10),
		float4(0, 0, 0, 1)
	));
	const float4x4 WorldToLocal = transpose(float4x4(
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 5),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 6),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 7),
		float4(0, 0, 0, 1)
	));
	const float4x4 PreviousWorldToLocal = transpose(float4x4(
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 11),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 12),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 13),
		float4(0, 0, 0, 1)
	));
	const float4x4 WorldToPreviousWorld = transpose(float4x4(
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 14),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 15),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 16),
		float4(0, 0, 0, 1)
	));
	float4 ObjectWorldPositionHighAndRadius	= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 18);
	float4 ObjectWorldPositionLow			= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 19);
	float4 ActorWorldPositionHigh	= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 20);
	float4 ActorWorldPositionLow	= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 21);
	PrimitiveData.Flags									= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).x);
	PrimitiveData.InstanceSceneDataOffset				= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).y);
	PrimitiveData.NumInstanceSceneDataEntries			= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).z);
	PrimitiveData.SingleCaptureIndex					= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).w) & 0xFFFFu;
	PrimitiveData.VisibilityFlags						= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).w) >> 16u;
	PrimitiveData.PositionHigh							= PositionHigh; 
	PrimitiveData.PrimitiveComponentId					= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 1).w);
	PrimitiveData.LocalToWorld							= MakeDFMatrix4x3(PositionHigh, LocalToWorld);
	PrimitiveData.WorldToLocal							= MakeDFInverseMatrix4x3(PositionHigh, WorldToLocal);
	PrimitiveData.PreviousLocalToWorld					= MakeDFMatrix4x3(PositionHigh, PreviousLocalToWorld);
	PrimitiveData.PreviousWorldToLocal					= MakeDFInverseMatrix4x3(PositionHigh, PreviousWorldToLocal);
	PrimitiveData.WorldToPreviousWorld					= WorldToPreviousWorld;
	PrimitiveData.InvNonUniformScale					= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 17).xyz;
	PrimitiveData.ObjectBoundsX							= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 17).w;
	PrimitiveData.ObjectRadius							= ObjectWorldPositionHighAndRadius.w;
	PrimitiveData.ObjectWorldPositionTO					= MakeLWCVector3(ObjectWorldPositionHighAndRadius.xyz, ObjectWorldPositionLow.xyz);
	PrimitiveData.ActorWorldPositionTO					= MakeLWCVector3(ActorWorldPositionHigh.xyz, ActorWorldPositionLow.xyz);
	PrimitiveData.ObjectWorldPosition					= DFFromTileOffset(PrimitiveData.ObjectWorldPositionTO);
	PrimitiveData.ActorWorldPosition					= DFFromTileOffset(PrimitiveData.ActorWorldPositionTO);
	PrimitiveData.MinMaterialDisplacement				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 19).w;
	PrimitiveData.MaxMaterialDisplacement				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 20).w;
	PrimitiveData.LightmapUVIndex						= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 21).w);
	PrimitiveData.ObjectOrientation						= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 22).xyz;
	PrimitiveData.LightmapDataIndex						= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 22).w);
	PrimitiveData.NonUniformScale						= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 23);
	PrimitiveData.PreSkinnedLocalBoundsMin				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 24).xyz;
	PrimitiveData.NaniteResourceID						= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 24).w);
	PrimitiveData.PreSkinnedLocalBoundsMax				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 25).xyz;
	PrimitiveData.NaniteHierarchyOffset					= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 25).w);
	PrimitiveData.LocalObjectBoundsMin					= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 26).xyz;
	PrimitiveData.ObjectBoundsY							= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 26).w;
	PrimitiveData.LocalObjectBoundsMax					= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 27).xyz;
	PrimitiveData.ObjectBoundsZ							= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 27).w;
	PrimitiveData.InstanceLocalBoundsCenter				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 28).xyz;
	PrimitiveData.InstancePayloadDataOffset				= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 28).w);
	PrimitiveData.InstanceLocalBoundsExtent				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 29).xyz;
	PrimitiveData.InstancePayloadDataStride				= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 29).w) & 0x00FFFFFFu;
	PrimitiveData.InstancePayloadExtensionSize			= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 29).w) >> 24;
	PrimitiveData.WireframeColor						= UnpackColorRGB24(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 30).x);
	PrimitiveData.PrimitiveColor						= UnpackColorRGB24(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 30).y);
	PrimitiveData.PackedNaniteFlags						= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 30).z);
	PrimitiveData.PersistentPrimitiveIndex				= asint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 30).w);
	PrimitiveData.InstanceDrawDistanceMinMaxSquared		= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 31).xy;
	PrimitiveData.InstanceWPODisableDistanceSquared		= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 31).z;
	PrimitiveData.NaniteRayTracingDataOffset			= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 31).w);
	PrimitiveData.MaxWPOExtent							= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 32).x;
	PrimitiveData.CustomStencilValueAndMask				= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 32).y);
	[unroll]
	for (int DataIndex = 0; DataIndex < 9u; ++DataIndex)
	{
		PrimitiveData.CustomPrimitiveData[DataIndex] = LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex,  33 + DataIndex);
	}
	return PrimitiveData;
}
float GetPrimitive_PerObjectGBufferData_FromFlags(uint Flags)
{
	const float CapsuleRepresentation = CondMask(Flags & 0x100, 1.0f, 0.0f);
	const float CastContactShadow     = CondMask(Flags & 0x200,    1.0f, 0.0f);
	return (2.0f * CapsuleRepresentation + CastContactShadow) / 3.0f;
}
float GetPrimitive_PerObjectGBufferData(uint PrimitiveId)
{
	return GetPrimitive_PerObjectGBufferData_FromFlags(GetPrimitiveData(PrimitiveId).Flags);
}
float GetPrimitive_PerObjectGBufferData(FPrimitiveSceneData Primitive)
{
	return GetPrimitive_PerObjectGBufferData_FromFlags(Primitive.Flags);
}
uint GetPrimitive_LightingChannelMask_FromFlags(uint Flags)
{
	const uint Channel0 = CondMask(Flags & 0x800, 1u, 0u);
	const uint Channel1 = CondMask(Flags & 0x1000, 1u, 0u);
	const uint Channel2 = CondMask(Flags & 0x2000, 1u, 0u);
	return (Channel0 | (Channel1 << 1u) | (Channel2 << 2u));
}
uint GetPrimitive_LightingChannelMask(uint PrimitiveId)
{
	return GetPrimitive_LightingChannelMask_FromFlags(GetPrimitiveData(PrimitiveId).Flags);
}
uint GetPrimitive_LightingChannelMask(FPrimitiveSceneData Primitive)
{
	return GetPrimitive_LightingChannelMask_FromFlags(Primitive.Flags);
}
struct FSceneDataIntermediates
{
	uint PrimitiveId;
	uint InstanceId;
	uint ViewIndex;
	uint CullingFlags;
	uint InstanceIdLoadIndex;
	FInstanceSceneData InstanceData;
	FPrimitiveSceneData Primitive;
};
struct FHairTransmittanceData
{
	bool bUseLegacyAbsorption;
	bool bUseSeparableR;
	bool bUseBacklit;
	float  OpaqueVisibility;
	float3 LocalScattering;
	float3 GlobalScattering;
	uint ScatteringComponent;
};
FHairTransmittanceData InitHairTransmittanceData(bool bMultipleScatterEnable = true)
{
	FHairTransmittanceData o;
	o.bUseLegacyAbsorption = true;
	o.bUseSeparableR = true;
	o.bUseBacklit = false;
	o.OpaqueVisibility = 1;
	o.LocalScattering = 0;
	o.GlobalScattering = 1;
	o.ScatteringComponent = 0x1u | 0x2u | 0x4u | (bMultipleScatterEnable ? 0x20u : 0);
	return o;
}
float3 HairColorToAbsorption(float3 C, float B = 0.3f)
{
	const float b2 = B * B;
	const float b3 = B * b2;
	const float b4 = b2 * b2;
	const float b5 = B * b4;
	const float D = (5.969f - 0.215f * B + 2.532f * b2 - 10.73f * b3 + 5.574f * b4 + 0.245f * b5);
	return Pow2(log(C) / D);
}
bool GetShadingModelRequiresBackfaceLighting(uint ShadingModelID)
{
	return ShadingModelID == 6;
}
float DielectricSpecularToF0(float Specular)
{
	return float(0.08f * Specular);
}
float3 ComputeF0(float Specular, float3 BaseColor, float Metallic)
{
	return lerp(DielectricSpecularToF0(Specular).xxx, BaseColor, Metallic.xxx);
}
struct FLightAccumulator
{
	float3 TotalLight;
	float ScatterableLightLuma;
	float3 ScatterableLight;
	float EstimatedCost;
	float3 TotalLightDiffuse;
	float3 TotalLightSpecular;
};
struct FDeferredLightingSplit
{
	float4 DiffuseLighting;
	float4 SpecularLighting;
};
void LightAccumulator_AddSplit(inout FLightAccumulator In, float3 DiffuseTotalLight, float3 SpecularTotalLight, float3 ScatterableLight, float3 CommonMultiplier, const bool bNeedsSeparateSubsurfaceLightAccumulation)
{
	In.TotalLight += (DiffuseTotalLight + SpecularTotalLight) * CommonMultiplier;
	if (bNeedsSeparateSubsurfaceLightAccumulation)
	{
		if (1 == 1)
		{
			if (View.bCheckerboardSubsurfaceProfileRendering == 0)
			{
				In.ScatterableLightLuma += Luminance(ScatterableLight * CommonMultiplier);
			}
		}
		else if (1 == 2)
		{
			In.ScatterableLight += ScatterableLight * CommonMultiplier;
		}
	}
	In.TotalLightDiffuse += DiffuseTotalLight * CommonMultiplier;
	In.TotalLightSpecular += SpecularTotalLight * CommonMultiplier;
}
float4 ConvertEstimatedCostToColor(float EstimatedCost)
{
	return 0.1f * float4(1.0f, 0.25f, 0.075f, 0) * EstimatedCost;
}
FDeferredLightingSplit LightAccumulator_GetResultSplit(FLightAccumulator In)
{
	float4 RetDiffuse;
	float4 RetSpecular;
	if (0 == 1)
	{
		RetDiffuse  = ConvertEstimatedCostToColor(In.EstimatedCost);
		RetSpecular = RetDiffuse;
	}
	else
	{
		RetDiffuse = float4(In.TotalLightDiffuse, 0);
		RetSpecular = float4(In.TotalLightSpecular, 0);
		if (1 == 1 )
		{
			if (View.bCheckerboardSubsurfaceProfileRendering == 0 && View.bSubsurfacePostprocessEnabled)
			{
				RetDiffuse.a = In.ScatterableLightLuma;
			}
		}
		else if (1 == 2)
		{
			RetDiffuse.a = Luminance(In.ScatterableLight);
		}
	}
	FDeferredLightingSplit Ret;
	Ret.DiffuseLighting = RetDiffuse;
	Ret.SpecularLighting = RetSpecular;
	return Ret;
}
bool UseSubsurfaceProfile(int ShadingModel)
{
	return ShadingModel == 5 || ShadingModel == 9;
}
struct FGBufferData
{
	float3 WorldNormal;
	float3 WorldTangent;
	float3 DiffuseColor;
	float3 SpecularColor;
	float3 BaseColor;
	float Metallic;
	float Specular;
	float4 CustomData;
	float GenericAO;
	float IndirectIrradiance;
	float4 PrecomputedShadowFactors;
	float Roughness;
	float Anisotropy;
	float GBufferAO;
	uint DiffuseIndirectSampleOcclusion;
	uint ShadingModelID;
	uint SelectiveOutputMask;
	float PerObjectGBufferData;
	float CustomDepth;
	uint CustomStencil;
	float Depth;
	float4 Velocity;
	float3 StoredBaseColor;
	float StoredSpecular;
	float StoredMetallic;
	float Curvature;
};
bool CastContactShadow(FGBufferData GBufferData)
{
	uint PackedAlpha = (uint)(GBufferData.PerObjectGBufferData * 3.999f);
	bool bCastContactShadowBit = PackedAlpha & 1;
	bool bShadingModelCastContactShadows = (GBufferData.ShadingModelID != 9);
	return bCastContactShadowBit && bShadingModelCastContactShadows;
}
bool CheckerFromPixelPos(uint2 PixelPos)
{
	uint TemporalAASampleIndex = uint(View.TemporalAAParams.x);
	return (PixelPos.x + PixelPos.y + TemporalAASampleIndex) % 2;
}
float3 ExtractSubsurfaceColor(FGBufferData BufferData)
{
	return Square(BufferData.CustomData.rgb);
}
uint ExtractSubsurfaceProfileInt(float ProfileNormFloat)
{
	return uint(ProfileNormFloat * 255.0f + 0.5f);
}
uint ExtractSubsurfaceProfileInt(FGBufferData BufferData)
{
	return ExtractSubsurfaceProfileInt(BufferData.CustomData.r);
}
float3 AOMultiBounce(float3 BaseColor, float AO)
{
	if (0 && !0)
	{
		return AO;
	}
	else
	{
		float3 a = 2.0404 * BaseColor - 0.3324;
		float3 b = -4.7951 * BaseColor + 0.6417;
		float3 c = 2.7552 * BaseColor + 0.6903;
		return max(AO, ((AO * a + b) * AO + c) * AO);
	}
}
struct FSubstrateData
{
	uint Dummy;
};
FSubstrateData GetInitialisedSubstrateData() { return (FSubstrateData)0; }
struct FMaterialParticleParameters
{
	float RelativeTime;
	float MotionBlurFade;
	float Random;
	float4 Velocity;
	float4 Color;
	float4 TranslatedWorldPositionAndSize;
	float4 PrevTranslatedWorldPositionAndSize;
	FLWCVector3 WorldPosition;
	FLWCVector3 PrevWorldPosition;
	float4 MacroUV;
	float4 DynamicParameter;
	FDFMatrix ParticleToWorld;
	FDFInverseMatrix WorldToParticle;
	float2 Size;
	float SpriteRotation;
};
struct FMaterialAttributes
{
	float3 BaseColor;
	float Metallic;
	float Specular;
	float Roughness;
	float Anisotropy;
	float3 EmissiveColor;
	float Opacity;
	float OpacityMask;
	float3 Normal;
	float3 Tangent;
	float3 WorldPositionOffset;
	float Displacement;
	float3 SubsurfaceColor;
	float ClearCoat;
	float ClearCoatRoughness;
	float AmbientOcclusion;
	float3 Refraction;
	float PixelDepthOffset;
	uint ShadingModel;
	float SurfaceThickness;
	FSubstrateData FrontMaterial;
	float2 CustomizedUV0;
	float2 CustomizedUV1;
	float2 CustomizedUV2;
	float2 CustomizedUV3;
	float2 CustomizedUV4;
	float2 CustomizedUV5;
	float2 CustomizedUV6;
	float2 CustomizedUV7;
	float3 BentNormal;
	float3 ClearCoatBottomNormal;
	float3 CustomEyeTangent;
	float3 TransmittanceColor;
};
struct FPixelMaterialInputs
{
	float3 EmissiveColor;
	float Opacity;
	float OpacityMask;
	float3 BaseColor;
	float Metallic;
	float Specular;
	float Roughness;
	float Anisotropy;
	float3 Normal;
	float3 Tangent;
	float4 Subsurface;
	float AmbientOcclusion;
	float3 Refraction;
	float PixelDepthOffset;
	uint ShadingModel;
	FSubstrateData FrontMaterial;
	float SurfaceThickness;
	float Displacement;
};
struct FMaterialLWCData
{
	FLWCVector3 AbsoluteWorldPosition;
	FLWCVector3 WorldPosition_NoOffsets;
	FLWCMatrix	LocalToWorld;
	FLWCInverseMatrix WorldToLocal;
	FLWCMatrix	PreviousLocalToWorld;
	FLWCInverseMatrix PreviousWorldToLocal;
	FLWCMatrix	InstanceToWorld;
	FLWCInverseMatrix WorldToInstance;
	FLWCMatrix	PreviousInstanceToWorld;
	FLWCVector3	ObjectWorldPosition;
	FLWCVector3	ActorWorldPosition;
	FLWCMatrix ParticleToWorld;
	FLWCInverseMatrix WorldToParticle;
	FLWCVector3 ParticleWorldPosition;
	FLWCVector3 PrevParticleWorldPosition;
	FLWCVector3 PreViewTranslation;
	FLWCVector3 PrevPreViewTranslation;
	FLWCVector3 WorldViewOrigin;
	FLWCVector3 PrevWorldViewOrigin;
	FLWCVector3 WorldCameraOrigin;
	FLWCVector3 PrevWorldCameraOrigin;
};
struct FMaterialPixelParameters
{
	float4 VertexColor;
	float3 WorldNormal;
	float3 WorldTangent;
	float3 ReflectionVector;
	float3 CameraVector;
	float3 LightVector;
	float4 SvPosition;
	float4 ScreenPosition;
	float2 ViewBufferUV;
	float UnMirrored;
	float TwoSidedSign;
	float3x3 TangentToWorld;
	FDFVector3 AbsoluteWorldPosition;
	float3 WorldPosition_CamRelative;
	FDFVector3 WorldPosition_NoOffsets;
	float3 WorldPosition_NoOffsets_CamRelative;
	float3 LightingPositionOffset;
	float3 WorldPosition_DDX;
	float3 WorldPosition_DDY;
	float4 VertexColor_DDX;
	float4 VertexColor_DDY;
	float4 ScreenPosition_DDX;
	float4 ScreenPosition_DDY;
	float AOMaterialMask;
	float PerInstanceRandom;
	uint PrimitiveId;
	FMaterialParticleParameters Particle;
	uint Dummy;
	FMaterialAttributes MaterialAttributes;
	FMaterialLWCData LWCData;
};
FMaterialPixelParameters MakeInitializedMaterialPixelParameters()
{
	FMaterialPixelParameters MPP;
	MPP = (FMaterialPixelParameters)0;
	MPP.TangentToWorld = float3x3(1,0,0,0,1,0,0,0,1);
	return MPP;
}
struct FMaterialVertexParameters
{
	float3 WorldPosition;
	float3x3 TangentToWorld;
	float PerInstanceRandom;
	FDFMatrix PrevFrameLocalToWorld;
	float3 PreSkinnedPosition;
	float3 PreSkinnedNormal;
	float4 VertexColor;
	FMaterialParticleParameters Particle;
	FMaterialAttributes MaterialAttributes;
	FSceneDataIntermediates SceneData;
	uint PrimitiveId;
	bool bEvaluateWorldPositionOffset;
	FMaterialLWCData LWCData;
};
FPrimitiveSceneData GetPrimitiveData(FMaterialVertexParameters Parameters)
{
	return Parameters.SceneData.Primitive;
}
FPrimitiveSceneData GetPrimitiveData(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters.PrimitiveId);
}
FDFInverseMatrix GetWorldToInstanceDF(FMaterialVertexParameters Parameters)
{
		return GetPrimitiveData(Parameters).WorldToLocal;
}
FDFInverseMatrix GetWorldToInstanceDF(FMaterialPixelParameters Parameters)
{
		return GetPrimitiveData(Parameters).WorldToLocal;
}
FDFMatrix GetInstanceToWorldDF(FMaterialVertexParameters Parameters)
{
		return GetPrimitiveData(Parameters).LocalToWorld;
}
FDFMatrix GetPrevInstanceToWorldDF(FMaterialVertexParameters Parameters)
{
	return GetPrimitiveData(Parameters).PreviousLocalToWorld;
}
FDFMatrix GetInstanceToWorldDF(FMaterialPixelParameters Parameters)
{
		return GetPrimitiveData(Parameters).LocalToWorld;
}
FDFMatrix GetPrevInstanceToWorldDF(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters).PreviousLocalToWorld;
}
FLWCVector3 GetWorldCameraOrigin(FMaterialVertexParameters Parameters)
{
	return Parameters.LWCData.WorldCameraOrigin;
}
FLWCVector3 GetWorldCameraOrigin(FMaterialPixelParameters Parameters)
{
	return Parameters.LWCData.WorldCameraOrigin;
}
FLWCVector3 GetWorldPosition(FMaterialVertexParameters Parameters)
{
	return Parameters.LWCData.AbsoluteWorldPosition;
}
FLWCVector3 GetWorldPosition(FMaterialPixelParameters Parameters)
{
	return Parameters.LWCData.AbsoluteWorldPosition;
}
float4 GetScreenPosition(FMaterialVertexParameters Parameters)
{
	return mul(float4(Parameters.WorldPosition, 1.0f), ResolvedView.TranslatedWorldToClip);
}
float4 GetScreenPosition(FMaterialPixelParameters Parameters)
{
	return Parameters.ScreenPosition;
}
float2 GetSceneTextureUV(FMaterialVertexParameters Parameters)
{
	return ScreenAlignedPosition(GetScreenPosition(Parameters));
}
float2 GetSceneTextureUV(FMaterialPixelParameters Parameters)
{
	return SvPositionToBufferUV(Parameters.SvPosition);
}
float2 GetViewportUV(FMaterialVertexParameters Parameters)
{
	return BufferUVToViewportUV(GetSceneTextureUV(Parameters));
}
float2 GetViewportUV(FMaterialPixelParameters Parameters)
{
	return SvPositionToViewportUV(Parameters.SvPosition);
}
FDFMatrix GetLocalToWorldDF(FMaterialVertexParameters Parameters)
{
	return GetPrimitiveData(Parameters).LocalToWorld;
}
FLWCMatrix GetLocalToWorld(FMaterialVertexParameters Parameters)
{
	return Parameters.LWCData.LocalToWorld;
}
FDFMatrix GetLocalToWorldDF(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters).LocalToWorld;
}
FLWCMatrix GetLocalToWorld(FMaterialPixelParameters Parameters)
{
	return Parameters.LWCData.LocalToWorld;
}
FDFMatrix GetPrevLocalToWorldDF(FMaterialVertexParameters Parameters)
{
	return GetPrimitiveData(Parameters).PreviousLocalToWorld;
}
FDFMatrix GetPrevLocalToWorldDF(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters).PreviousLocalToWorld;
}
FDFInverseMatrix GetWorldToLocalDF(FMaterialVertexParameters Parameters)
{
	return GetPrimitiveData(Parameters).WorldToLocal;
}
FLWCInverseMatrix GetWorldToLocal(FMaterialVertexParameters Parameters)
{
	return Parameters.LWCData.WorldToLocal;
}
FDFInverseMatrix GetWorldToLocalDF(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters).WorldToLocal;
}
FLWCInverseMatrix GetWorldToLocal(FMaterialPixelParameters Parameters)
{
	return Parameters.LWCData.WorldToLocal;
}
FDFInverseMatrix GetPrevWorldToLocalDF(FMaterialVertexParameters Parameters)
{
	return GetPrimitiveData(Parameters).PreviousWorldToLocal;
}
FDFInverseMatrix GetPrevWorldToLocalDF(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters).PreviousWorldToLocal;
}
FLWCVector3 TransformLocalPositionToWorld(FMaterialPixelParameters Parameters,float3 InLocalPosition)
{
	return LWCMultiply(InLocalPosition, GetLocalToWorld(Parameters));
}
FLWCVector3 TransformLocalPositionToWorld(FMaterialVertexParameters Parameters,float3 InLocalPosition)
{
	return LWCMultiply(InLocalPosition, GetLocalToWorld(Parameters));
}
FMaterialLWCData MakeMaterialLWCData(FMaterialVertexParameters Parameters)
{
	FMaterialLWCData Result = (FMaterialLWCData)0;
	Result.PreViewTranslation = ResolvedView.TileOffset.PreViewTranslation;
	Result.PrevPreViewTranslation = ResolvedView.TileOffset.PrevPreViewTranslation;
	Result.WorldViewOrigin = ResolvedView.TileOffset.WorldViewOrigin;
	Result.PrevWorldViewOrigin = ResolvedView.TileOffset.PrevWorldViewOrigin;
	Result.WorldCameraOrigin = ResolvedView.TileOffset.WorldCameraOrigin;
	Result.PrevWorldCameraOrigin = ResolvedView.TileOffset.PrevWorldCameraOrigin;
	Result.AbsoluteWorldPosition = LWCSubtract(Parameters.WorldPosition, Result.PreViewTranslation);
	Result.InstanceToWorld = DFToWS(GetInstanceToWorldDF(Parameters));
	Result.WorldToInstance = DFFastToWS(GetWorldToInstanceDF(Parameters));
	Result.PreviousInstanceToWorld = DFToWS(GetPrevInstanceToWorldDF(Parameters));
	Result.LocalToWorld = DFToWS(GetLocalToWorldDF(Parameters));
	Result.WorldToLocal = DFFastToWS(GetWorldToLocalDF(Parameters));
	Result.PreviousLocalToWorld = DFToWS(GetPrevLocalToWorldDF(Parameters));
	Result.PreviousWorldToLocal = DFFastToWS(GetPrevWorldToLocalDF(Parameters));
	Result.ObjectWorldPosition = GetPrimitiveData(Parameters).ObjectWorldPositionTO;
	Result.ActorWorldPosition = GetPrimitiveData(Parameters).ActorWorldPositionTO;
	Result.ParticleToWorld = DFFastToWS(Parameters.Particle.ParticleToWorld);
	Result.WorldToParticle = DFFastToWS(Parameters.Particle.WorldToParticle);
	Result.ParticleWorldPosition = LWCSubtract(Parameters.Particle.TranslatedWorldPositionAndSize.xyz, Result.PreViewTranslation);
	Result.PrevParticleWorldPosition = LWCSubtract(Parameters.Particle.PrevTranslatedWorldPositionAndSize.xyz, Result.PrevPreViewTranslation);
	return Result;
}
FMaterialLWCData MakeMaterialLWCData(FMaterialPixelParameters Parameters)
{
	FMaterialLWCData Result = (FMaterialLWCData)0;
	Result.PreViewTranslation = ResolvedView.TileOffset.PreViewTranslation;
	Result.PrevPreViewTranslation = ResolvedView.TileOffset.PrevPreViewTranslation;
	Result.WorldViewOrigin = ResolvedView.TileOffset.WorldViewOrigin;
	Result.PrevWorldViewOrigin = ResolvedView.TileOffset.PrevWorldViewOrigin;
	Result.WorldCameraOrigin = ResolvedView.TileOffset.WorldCameraOrigin;
	Result.PrevWorldCameraOrigin = ResolvedView.TileOffset.PrevWorldCameraOrigin;
	Result.AbsoluteWorldPosition = LWCSubtract(Parameters.WorldPosition_CamRelative, Result.PreViewTranslation);
	Result.WorldPosition_NoOffsets = LWCSubtract(Parameters.WorldPosition_NoOffsets_CamRelative, Result.PreViewTranslation);
	Result.InstanceToWorld = DFToWS(GetInstanceToWorldDF(Parameters));
	Result.WorldToInstance = DFFastToWS(GetWorldToInstanceDF(Parameters));
	Result.PreviousInstanceToWorld = DFToWS(GetPrevInstanceToWorldDF(Parameters));
	Result.LocalToWorld = DFToWS(GetLocalToWorldDF(Parameters));
	Result.WorldToLocal = DFFastToWS(GetWorldToLocalDF(Parameters));
	Result.PreviousLocalToWorld = DFToWS(GetPrevLocalToWorldDF(Parameters));
	Result.PreviousWorldToLocal = DFFastToWS(GetPrevWorldToLocalDF(Parameters));
	Result.ObjectWorldPosition = GetPrimitiveData(Parameters).ObjectWorldPositionTO;
	Result.ActorWorldPosition = GetPrimitiveData(Parameters).ActorWorldPositionTO;
	Result.ParticleToWorld = DFFastToWS(Parameters.Particle.ParticleToWorld);
	Result.WorldToParticle = DFFastToWS(Parameters.Particle.WorldToParticle);
	Result.ParticleWorldPosition = LWCSubtract(Parameters.Particle.TranslatedWorldPositionAndSize.xyz, Result.PreViewTranslation);
	Result.PrevParticleWorldPosition = LWCSubtract(Parameters.Particle.PrevTranslatedWorldPositionAndSize.xyz, Result.PrevPreViewTranslation);
	return Result;
}
float3 ReflectionAboutCustomWorldNormal(FMaterialPixelParameters Parameters, float3 WorldNormal, bool bNormalizeInputNormal)
{
	if (bNormalizeInputNormal)
	{
		WorldNormal = normalize(WorldNormal);
	}
	return -Parameters.CameraVector + WorldNormal * dot(WorldNormal, Parameters.CameraVector) * 2.0;
}
float3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs)
{
	return PixelMaterialInputs.Normal;
}
float3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs)
{
	float3 RetNormal;
	RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);
	{
		float3 OverrideNormal = ResolvedView.NormalOverrideParameter.xyz;
		RetNormal = RetNormal * ResolvedView.NormalOverrideParameter.w + OverrideNormal;
	}
	return RetNormal;
}
float3 GetMaterialEmissiveRaw(FPixelMaterialInputs PixelMaterialInputs)
{
	return PixelMaterialInputs.EmissiveColor;
}
float3 GetMaterialEmissive(FPixelMaterialInputs PixelMaterialInputs)
{
	float3 EmissiveColor = GetMaterialEmissiveRaw(PixelMaterialInputs);
	EmissiveColor = max(EmissiveColor, 0.0f);
	return EmissiveColor;
}
uint GetMaterialShadingModel(FPixelMaterialInputs PixelMaterialInputs)
{
	return PixelMaterialInputs.ShadingModel;
}
float3 GetMaterialBaseColorRaw(FPixelMaterialInputs PixelMaterialInputs)
{
	return PixelMaterialInputs.BaseColor;
}
float3 GetMaterialBaseColor(FPixelMaterialInputs PixelMaterialInputs)
{
	return saturate(GetMaterialBaseColorRaw(PixelMaterialInputs));
}
float GetMaterialMetallicRaw(FPixelMaterialInputs PixelMaterialInputs)
{
	return PixelMaterialInputs.Metallic;
}
float GetMaterialMetallic(FPixelMaterialInputs PixelMaterialInputs)
{
	return saturate(GetMaterialMetallicRaw(PixelMaterialInputs));
}
float GetMaterialSpecularRaw(FPixelMaterialInputs PixelMaterialInputs)
{
	return PixelMaterialInputs.Specular;
}
float GetMaterialSpecular(FPixelMaterialInputs PixelMaterialInputs)
{
	return saturate(GetMaterialSpecularRaw(PixelMaterialInputs));
}
float GetMaterialRoughnessRaw(FPixelMaterialInputs PixelMaterialInputs)
{
	return PixelMaterialInputs.Roughness;
}
float GetMaterialRoughness(FPixelMaterialInputs PixelMaterialInputs)
{
	float Roughness = saturate(GetMaterialRoughnessRaw(PixelMaterialInputs));
	{
		Roughness = Roughness * ResolvedView.RoughnessOverrideParameter.y + ResolvedView.RoughnessOverrideParameter.x;
	}
	return Roughness;
}
float GetMaterialAnisotropyRaw(FPixelMaterialInputs PixelMaterialInputs)
{
	return PixelMaterialInputs.Anisotropy;
}
float GetMaterialAnisotropy(FPixelMaterialInputs PixelMaterialInputs)
{
	return clamp(GetMaterialAnisotropyRaw(PixelMaterialInputs), -1.0f, 1.0f);
}
float GetMaterialOpacityMaskClipValue()
{
return 0.33330;
}
float GetMaterialOpacityRaw(FPixelMaterialInputs PixelMaterialInputs)
{
	return PixelMaterialInputs.Opacity;
}
float GetMaterialOpacity(FPixelMaterialInputs PixelMaterialInputs)
{
	return saturate(GetMaterialOpacityRaw(PixelMaterialInputs));
}
float GetMaterialAmbientOcclusionRaw(FPixelMaterialInputs PixelMaterialInputs)
{
	return PixelMaterialInputs.AmbientOcclusion;
}
float GetMaterialAmbientOcclusion(FPixelMaterialInputs PixelMaterialInputs)
{
	return saturate(GetMaterialAmbientOcclusionRaw(PixelMaterialInputs));
}
float3 TransformTangentNormalToWorld(float3x3 TangentToWorld, float3 TangentNormal)
{
	return normalize(float3(TransformTangentVectorToWorld(TangentToWorld, TangentNormal)));
}
void CalcPixelMaterialInputs(in out FMaterialPixelParameters Parameters, in out FPixelMaterialInputs PixelMaterialInputs)
{
	PixelMaterialInputs.Normal = float3(0.00000000,0.00000000,1.00000000);
	float3 MaterialNormal = GetMaterialNormal(Parameters, PixelMaterialInputs);
	MaterialNormal = normalize(MaterialNormal);
	Parameters.WorldNormal = TransformTangentNormalToWorld(Parameters.TangentToWorld, MaterialNormal);
	Parameters.WorldNormal *= Parameters.TwoSidedSign;
	Parameters.ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, Parameters.WorldNormal, false);
	Parameters.Particle.MotionBlurFade = 1.0f;
	float3 Local0 = lerp(float3(0.00000000,0.00000000,0.00000000),Material.PreshaderBuffer[0].yzw,Material.PreshaderBuffer[0].x);
	FLWCVector3 Local1 = GetWorldPosition(Parameters);
	FLWCVector3 Local2 = MakeLWCVector( LWCGetComponent(   Local1  , 0),  LWCGetComponent(   Local1  , 1),  LWCGetComponent(   Local1  , 2));
	float3 Local3 = LWCMultiply(  Local2 , GetWorldToLocal(Parameters));
	FLWCVector3 Local4 = TransformLocalPositionToWorld(Parameters,   Local3 );
	FLWCVector3 Local5 = LWCMultiply(  Local4 , ((float3)0.05000000));
	FLWCVector3 Local6 = GetWorldCameraOrigin(Parameters);
	FLWCVector3 Local7 = LWCMultiply(Local6, ((float3)Material.PreshaderBuffer[1].x));
	FLWCVector3 Local8 = LWCMultiply(Local7, ((float3)0.05000000));
	FLWCVector3 Local9 = LWCAdd(  Local5 , Local8);
	float Local10 = MaterialExpressionNoise(  Local9 ,1.00000000,1.00000000,3.00000000,1.00000000,6.00000000,-1.00000000,1.00000000,2.00000000,0.00000000,0.00000000,512.00000000);
	FLWCVector3 Local11 = LWCMultiply(Local7, ((float3)0.02000000));
	FLWCVector3 Local12 = LWCAdd(  Local5 , Local11);
	float Local13 = MaterialExpressionNoise(  Local12 ,1.00000000,1.00000000,0.00000000,1.00000000,6.00000000,-1.00000000,1.00000000,2.00000000,0.00000000,0.00000000,512.00000000);
	float Local14 = (Local10 - Local13);
	float2 Local15 = GetViewportUV(Parameters);
	float2 Local16 = (float2(0.50000000,0.50000000).rg -   Local15 );
	float2 Local17 = (  Local16  * ((float2)10.00000000));
	float3 Local18 = float3(  Local17 ,0.0f);
	float2 Local19 =   Local18 .xy;
	float3 Local20 = float3(  Local19 ,Material.PreshaderBuffer[1].y);
	PixelMaterialInputs.EmissiveColor = Local0;
	PixelMaterialInputs.Opacity = 0.20000000;
	PixelMaterialInputs.OpacityMask = 1.00000000;
	PixelMaterialInputs.BaseColor = Local14;
	PixelMaterialInputs.Metallic = 0.20000000;
	PixelMaterialInputs.Specular = 1.00000000;
	PixelMaterialInputs.Roughness = 0.00000000;
	PixelMaterialInputs.Anisotropy = 0.00000000;
	PixelMaterialInputs.Normal = float3(0.00000000,0.00000000,1.00000000);
	PixelMaterialInputs.Tangent = float3(1.00000000,0.00000000,0.00000000);
	PixelMaterialInputs.Subsurface = 0;
	PixelMaterialInputs.AmbientOcclusion = 1.00000000;
	PixelMaterialInputs.Refraction = Local20;
	PixelMaterialInputs.PixelDepthOffset = 0.00000000;
	PixelMaterialInputs.ShadingModel = 11;
	PixelMaterialInputs.FrontMaterial = GetInitialisedSubstrateData();
	PixelMaterialInputs.SurfaceThickness = 0.01000000;
	PixelMaterialInputs.Displacement = 0.50000000;
	Parameters.WorldTangent = 0;
}
void ClipLODTransition(float2 SvPosition, float DitherFactor)
{
	if (abs(DitherFactor) > .001)
	{
		float ArgCos = dot(floor(SvPosition.xy), float2(347.83451793, 3343.28371963));
		float RandCos = cos(ArgCos);
		float RandomVal = frac(RandCos * 1000.0);
		float RetVal = (DitherFactor < 0.0) ?
			(DitherFactor + 1.0 > RandomVal) :
			(DitherFactor < RandomVal);
		clip(RetVal - .001);
	}
}
void ClipLODTransition(FMaterialPixelParameters Parameters, float DitherFactor)
{
	ClipLODTransition(Parameters.SvPosition.xy, DitherFactor);
}
void ClipLODTransition(FMaterialPixelParameters Parameters)
{
}
void ClipLODTransition(float2 SvPosition)
{
}
void GetMaterialCoverageAndClipping(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs)
{
	ClipLODTransition(Parameters);
}
void CalcMaterialParametersEx(
	in out FMaterialPixelParameters Parameters,
	in out FPixelMaterialInputs PixelMaterialInputs,
	float4 SvPosition,
	float4 ScreenPosition,
	bool bIsFrontFace,
	float3 TranslatedWorldPosition,
	float3 TranslatedWorldPositionExcludingShaderOffsets)
{
	Parameters.WorldPosition_CamRelative = TranslatedWorldPosition;
	Parameters.WorldPosition_NoOffsets_CamRelative = TranslatedWorldPositionExcludingShaderOffsets;
	Parameters.LWCData = MakeMaterialLWCData(Parameters);
	Parameters.AbsoluteWorldPosition = DFMultiplyLHSAndFastTwoSum(Parameters.LWCData.AbsoluteWorldPosition.Tile, 2097152.00f, Parameters.LWCData.AbsoluteWorldPosition.Offset);
	Parameters.WorldPosition_NoOffsets = DFMultiplyLHSAndFastTwoSum(Parameters.LWCData.WorldPosition_NoOffsets.Tile, 2097152.00f, Parameters.LWCData.WorldPosition_NoOffsets.Offset);
	Parameters.SvPosition = SvPosition;
	Parameters.ScreenPosition = ScreenPosition;
	Parameters.ViewBufferUV = ScreenPositionToBufferUV(ScreenPosition);
		Parameters.CameraVector =  select_internal( IsOrthoProjection(ResolvedView) , -ResolvedView.ViewForward , normalize(-Parameters.WorldPosition_CamRelative.xyz) );
	Parameters.LightVector = 0;
	Parameters.TwoSidedSign = 1.0f;
	{
		CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);
	}
}
float3x3 AssembleTangentToWorld( float3 TangentToWorld0, float4 TangentToWorld2 )
{
	float3 TangentToWorld1 = cross(TangentToWorld2.xyz,TangentToWorld0) * TangentToWorld2.w;
	return float3x3(TangentToWorld0, TangentToWorld1, TangentToWorld2.xyz);
}
float3 GetWorldBentNormalZero(in FMaterialPixelParameters MaterialParameters)
{
	return MaterialParameters.WorldNormal;
}
struct FSharedBasePassInterpolants
{
	float4 VertexFog		: TEXCOORD7;
	float3 PixelPositionExcludingWPO : TEXCOORD9;
};
struct FShadingOcclusion
{
	float  DiffOcclusion;
	float  SpecOcclusion;
	float3 BentNormal;
};
FShadingOcclusion ApplyBentNormal(
	in float3 CameraVector, 
	in float3 WorldNormal, 
	in float3 WorldBentNormal0, 
	in float Roughness,
	in float MaterialAO)
{
	FShadingOcclusion Out;
	Out.DiffOcclusion = MaterialAO;
	Out.SpecOcclusion = MaterialAO;
	Out.BentNormal    = WorldNormal;
	return Out;
}
struct FVertexFactoryInterpolantsVSToPS
{
	float4 TangentToWorld0 : TEXCOORD10_centroid; float4	TangentToWorld2	: TEXCOORD11_centroid;
	nointerpolation uint PrimitiveId : PRIMITIVE_ID;
};
float4 GetColor(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return 0;
}
float4 GetTangentToWorld2(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.TangentToWorld2;
}
float4 GetTangentToWorld0(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.TangentToWorld0;
}
uint GetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.PrimitiveId;
}
struct FVertexFactoryIntermediatesCommon
{
	FSceneDataIntermediates SceneData;
};
struct FVertexFactoryIntermediates
{
	FVertexFactoryIntermediatesCommon Common;
	int PrimitiveLocalInstanceIndex;
	float3x3 TangentToLocal;
	float3x3 TangentToWorld;
	float TangentToWorldSign;
	float4 Color;
	bool bEvaluateWorldPositionOffset;
	float IsVisible;
	float3 PreSkinPosition;
};
FPrimitiveSceneData GetPrimitiveData(FVertexFactoryIntermediatesCommon Intermediates)
{
	return Intermediates.SceneData.Primitive;
}
FPrimitiveSceneData GetPrimitiveData(FVertexFactoryIntermediates Intermediates)
{
	return GetPrimitiveData(Intermediates.Common);
}
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
	FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();
	float3 TangentToWorld0 = GetTangentToWorld0(Interpolants).xyz;
	float4 TangentToWorld2 = GetTangentToWorld2(Interpolants);
	Result.UnMirrored = TangentToWorld2.w;
	Result.VertexColor = GetColor(Interpolants);
	Result.Particle.Color = float4(1,1,1,1);
	Result.TangentToWorld = AssembleTangentToWorld( TangentToWorld0, TangentToWorld2 );
	Result.TwoSidedSign = 1;
	Result.PrimitiveId = GetPrimitiveId(Interpolants);
	return Result;
}
float3 ComputeVolumetricLightmapBrickTextureUVs(float3 WorldPosition) 
{
	float3 IndirectionVolumeUVs = clamp(WorldPosition * View.VolumetricLightmapWorldToUVScale + View.VolumetricLightmapWorldToUVAdd, 0.0f, .99f);
	float3 IndirectionTextureTexelCoordinate = IndirectionVolumeUVs * View.VolumetricLightmapIndirectionTextureSize;
	float4 BrickOffsetAndSize = View_VolumetricLightmapIndirectionTexture.Load(int4(IndirectionTextureTexelCoordinate, 0));
	float PaddedBrickSize = View.VolumetricLightmapBrickSize + 1;
	return (BrickOffsetAndSize.xyz * PaddedBrickSize + frac(IndirectionTextureTexelCoordinate / BrickOffsetAndSize.w) * View.VolumetricLightmapBrickSize + .5f) * View.VolumetricLightmapBrickTexelSize;
}
float GetVolumetricLightmapDirectionalLightShadowing(float3 BrickTextureUVs)
{
	return Texture3DSampleLevel(View_DirectionalLightShadowingBrickTexture, View_SharedBilinearClampedSampler, BrickTextureUVs, 0).x;
}
float4 GetPrecomputedShadowMasks(float LightmapVTPageTableResult, FVertexFactoryInterpolantsVSToPS Interpolants, FMaterialPixelParameters MaterialParameters, float3 VolumetricLightmapBrickTextureUVs)
{
		float DirectionalLightShadowing = 1.0f;
		[branch]
		if ((GetPrimitiveData(MaterialParameters).Flags & 0x4) != 0)
		{
				VolumetricLightmapBrickTextureUVs = ComputeVolumetricLightmapBrickTextureUVs(LWCToFloat(GetWorldPosition(MaterialParameters)));
			DirectionalLightShadowing = GetVolumetricLightmapDirectionalLightShadowing(VolumetricLightmapBrickTextureUVs);
		}
		return float4(DirectionalLightShadowing, 1, 1, 1);
}
float4 ComputePlanarReflections(float3 TranslatedWorldPosition, float3 WorldNormal, float Roughness, SamplerState SharedClampSampler)
{
	float4 OutPlanarReflection = 0;
	float PlaneDistance = dot(TranslucentBasePass.Shared_PlanarReflection_ReflectionPlane, float4(TranslatedWorldPosition, -1));
	float DistanceFade = 1 - saturate(abs(PlaneDistance) * TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionParameters.x + TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionParameters.y);
	float3 PlaneOriginToWorldPosition = TranslatedWorldPosition - TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionOrigin.xyz;
	float XAxisDistance = dot(PlaneOriginToWorldPosition, TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionXAxis.xyz);
	float XAxisFade = saturate((TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionXAxis.w - abs(XAxisDistance)) * TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionParameters.x);
	float YAxisDistance = dot(PlaneOriginToWorldPosition, TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionYAxis.xyz);
	float YAxisFade = saturate((TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionYAxis.w - abs(YAxisDistance)) * TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionParameters.x);
	DistanceFade *= XAxisFade * YAxisFade;
	float AngleFade = saturate(dot(TranslucentBasePass.Shared_PlanarReflection_ReflectionPlane.xyz, WorldNormal) * TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionParameters2.x + TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionParameters2.y);
	float RoughnessFade = 1 - saturate((Roughness - .2f) * 10.0f);
	float FinalFade = DistanceFade * AngleFade * RoughnessFade;
	[branch]
	if (FinalFade > 0)
	{
		float3 CameraToPixel = normalize(TranslatedWorldPosition - ResolvedView.TranslatedWorldCameraOrigin);
		float3 MirroredCameraVector = reflect(CameraToPixel, -TranslucentBasePass.Shared_PlanarReflection_ReflectionPlane.xyz);
		float3 MirroredNormal = mul(WorldNormal, TranslucentBasePass.Shared_PlanarReflection_InverseTransposeMirrorMatrix).xyz;
		float3 MirroredReflectionVectorOffNormal = reflect(MirroredCameraVector, MirroredNormal);
		float3 VirtualReflectionSpherePosition = TranslatedWorldPosition + MirroredReflectionVectorOffNormal * TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionParameters.z;
		float3 ViewVirtualReflectionSpherePosition = mul(float4(VirtualReflectionSpherePosition, 1), ResolvedView.TranslatedWorldToView).xyz;
		float4 ClipVirtualReflectionSpherePosition = mul(float4(ViewVirtualReflectionSpherePosition, 1), TranslucentBasePass.Shared_PlanarReflection_ProjectionWithExtraFOV[ResolvedView.StereoPassIndex]);
		uint EyeIndex = 0;
		if (TranslucentBasePass.Shared_PlanarReflection_bIsStereo)
		{
			EyeIndex = ResolvedView.StereoPassIndex;
		}
		float2 NDC = clamp(ClipVirtualReflectionSpherePosition.xy / ClipVirtualReflectionSpherePosition.w, -TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionScreenBound, TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionScreenBound);
		float2 ViewportUV = NDC * TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionScreenScaleBias[EyeIndex].xy + TranslucentBasePass.Shared_PlanarReflection_PlanarReflectionScreenScaleBias[EyeIndex].zw;
		float4 PlanarReflectionTextureValue = Texture2DSampleLevel(
			TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionTexture,
			SharedClampSampler, 
			ViewportUV, 
			0);
		FinalFade *= PlanarReflectionTextureValue.a;
		OutPlanarReflection.rgb = PlanarReflectionTextureValue.rgb * RoughnessFade; 
		OutPlanarReflection.a = FinalFade;
	}
	return OutPlanarReflection;
}
struct BxDFContext
{
	float NoV;
	float NoL;
	float VoL;
	float NoH;
	float VoH;
	float XoV;
	float XoL;
	float XoH;
	float YoV;
	float YoL;
	float YoH;
};
void Init( inout BxDFContext Context, float3 N, float3 V, float3 L )
{
	Context.NoL = dot(N, L);
	Context.NoV = dot(N, V);
	Context.VoL = dot(V, L);
	float InvLenH = rsqrt( 2 + 2 * Context.VoL );
	Context.NoH = saturate( ( Context.NoL + Context.NoV ) * InvLenH );
	Context.VoH = saturate( InvLenH + InvLenH * Context.VoL );
	Context.XoV = 0.0f;
	Context.XoL = 0.0f;
	Context.XoH = 0.0f;
	Context.YoV = 0.0f;
	Context.YoL = 0.0f;
	Context.YoH = 0.0f;
}
void Init( inout BxDFContext Context, float3 N, float3 X, float3 Y, float3 V, float3 L )
{
	Context.NoL = dot(N, L);
	Context.NoV = dot(N, V);
	Context.VoL = dot(V, L);
	float InvLenH = rsqrt( 2 + 2 * Context.VoL );
	Context.NoH = saturate( ( Context.NoL + Context.NoV ) * InvLenH );
	Context.VoH = saturate( InvLenH + InvLenH * Context.VoL );
	Context.XoV = dot(X, V);
	Context.XoL = dot(X, L);
	Context.XoH = (Context.XoL + Context.XoV) * InvLenH;
	Context.YoV = dot(Y, V);
	Context.YoL = dot(Y, L);
	Context.YoH = (Context.YoL + Context.YoV) * InvLenH;
}
void SphereMaxNoH( inout BxDFContext Context, float SinAlpha, bool bNewtonIteration )
{
	if( SinAlpha > 0 )
	{
		float CosAlpha = sqrt( 1 - Pow2( SinAlpha ) );
		float RoL = 2 * Context.NoL * Context.NoV - Context.VoL;
		if( RoL >= CosAlpha )
		{
			Context.NoH = 1;
			Context.XoH = 0;
			Context.YoH = 0;
			Context.VoH = abs( Context.NoV );
		}
		else
		{
			float rInvLengthT = SinAlpha * rsqrt( 1 - RoL*RoL );
			float NoTr = rInvLengthT * ( Context.NoV - RoL * Context.NoL );
			float VoTr = rInvLengthT * ( 2 * Context.NoV*Context.NoV - 1 - RoL * Context.VoL );
			if (bNewtonIteration)
			{
				float NxLoV = sqrt( saturate( 1 - Pow2(Context.NoL) - Pow2(Context.NoV) - Pow2(Context.VoL) + 2 * Context.NoL * Context.NoV * Context.VoL ) );
				float NoBr = rInvLengthT * NxLoV;
				float VoBr = rInvLengthT * NxLoV * 2 * Context.NoV;
				float NoLVTr = Context.NoL * CosAlpha + Context.NoV + NoTr;
				float VoLVTr = Context.VoL * CosAlpha + 1   + VoTr;
				float p = NoBr   * VoLVTr;
				float q = NoLVTr * VoLVTr;
				float s = VoBr   * NoLVTr;
				float xNum = q * ( -0.5 * p + 0.25 * VoBr * NoLVTr );
				float xDenom = p*p + s * (s - 2*p) + NoLVTr * ( (Context.NoL * CosAlpha + Context.NoV) * Pow2(VoLVTr) + q * (-0.5 * (VoLVTr + Context.VoL * CosAlpha) - 0.5) );
				float TwoX1 = 2 * xNum / ( Pow2(xDenom) + Pow2(xNum) );
				float SinTheta = TwoX1 * xDenom;
				float CosTheta = 1.0 - TwoX1 * xNum;
				NoTr = CosTheta * NoTr + SinTheta * NoBr;
				VoTr = CosTheta * VoTr + SinTheta * VoBr;
			}
			Context.NoL = Context.NoL * CosAlpha + NoTr; 
			Context.VoL = Context.VoL * CosAlpha + VoTr;
			float InvLenH = rsqrt( 2 + 2 * Context.VoL );
			Context.NoH = saturate( ( Context.NoL + Context.NoV ) * InvLenH );
			Context.VoH = saturate( InvLenH + InvLenH * Context.VoL );
		}
	}
}
float3 Diffuse_Lambert( float3 DiffuseColor )
{
	return DiffuseColor * (1 / PI);
}
float3 Diffuse_Burley( float3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )
{
	float FD90 = 0.5 + 2 * VoH * VoH * Roughness;
	float FdV = 1 + (FD90 - 1) * Pow5( 1 - NoV );
	float FdL = 1 + (FD90 - 1) * Pow5( 1 - NoL );
	return DiffuseColor * ( (1 / PI) * FdV * FdL );
}
float D_GGX( float a2, float NoH )
{
	float d = ( NoH * a2 - NoH ) * NoH + 1;	
	return a2 / ( PI*d*d );					
}
float D_GGXaniso( float ax, float ay, float NoH, float XoH, float YoH )
{
	float a2 = ax * ay;
	float3 V = float3(ay * XoH, ax * YoH, a2 * NoH);
	float S = dot(V, V);
	return (1.0f / PI) * a2 * Square(a2 / S);
}
float Vis_SmithJointApprox( float a2, float NoV, float NoL )
{
	float a = sqrt(a2);
	float Vis_SmithV = NoL * ( NoV * ( 1 - a ) + a );
	float Vis_SmithL = NoV * ( NoL * ( 1 - a ) + a );
	return 0.5 * rcp( Vis_SmithV + Vis_SmithL );
}
float Vis_SmithJointAniso(float ax, float ay, float NoV, float NoL, float XoV, float XoL, float YoV, float YoL)
{
	float Vis_SmithV = NoL * length(float3(ax * XoV, ay * YoV, NoV));
	float Vis_SmithL = NoV * length(float3(ax * XoL, ay * YoL, NoL));
	return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
}
float3 F_Schlick( float3 SpecularColor, float VoH )
{
	float Fc = Pow5( 1 - VoH );					
	return saturate( 50.0 * SpecularColor.g ) * Fc + (1 - Fc) * SpecularColor;
}
float3 F_Schlick(float3 F0, float3 F90, float VoH)
{
	float Fc = Pow5(1 - VoH);
	return F90 * Fc + (1 - Fc) * F0;
}
void GetAnisotropicRoughness(float Alpha, float Anisotropy, out float ax, out float ay)
{
	ax = max(Alpha * (1.0 + Anisotropy), 0.001f);
	ay = max(Alpha * (1.0 - Anisotropy), 0.001f);
}
float2 GetAnisotropicRoughness(float Roughness, float Anisotropy)
{
	float2 Out = saturate(Roughness);
	Anisotropy = clamp(Anisotropy, -1.0, 1.0);
	Out.x = max(Roughness * sqrt(1.0 + Anisotropy), 0.001f);
	Out.y = max(Roughness * sqrt(1.0 - Anisotropy), 0.001f);
	return Out;
}
float2 EnvBRDFApproxLazarov(float Roughness, float NoV)
{
	const float4 c0 = { -1, -0.0275, -0.572, 0.022 };
	const float4 c1 = { 1, 0.0425, 1.04, -0.04 };
	float4 r = Roughness * c0 + c1;
	float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
	float2 AB = float2(-1.04, 1.04) * a004 + r.zw;
	return AB;
}
float3 EnvBRDFApprox( float3 SpecularColor, float Roughness, float NoV )
{
	float2 AB = EnvBRDFApproxLazarov(Roughness, NoV);
	float F90 = saturate( 50.0 * SpecularColor.g );
	return SpecularColor * AB.x + F90 * AB.y;
}
float3 EnvBRDFApprox(float3 F0, float3 F90, float Roughness, float NoV)
{
	float2 AB = EnvBRDFApproxLazarov(Roughness, NoV);
	return F0 * AB.x + F90 * AB.y;
}
void EnvBRDFApproxFullyRough(inout float3 DiffuseColor, inout float3 SpecularColor)
{
	DiffuseColor += SpecularColor * 0.45;
	SpecularColor = 0;
}
void EnvBRDFApproxFullyRough(inout float3 DiffuseColor, inout float SpecularColor)
{
	DiffuseColor += SpecularColor * 0.45;
	SpecularColor = 0;
}
void EnvBRDFApproxFullyRough(inout float3 DiffuseColor, inout float3 F0, inout float3 F90)
{
	DiffuseColor += F0 * 0.45;
	F0 = F90 = 0;
}
float D_InvGGX( float a2, float NoH )
{
	float A = 4;
	float d = ( NoH - a2 * NoH ) * NoH + a2;
	return rcp( PI * (1 + A*a2) ) * ( 1 + 4 * a2*a2 / ( d*d ) );
}
float Vis_Cloth( float NoV, float NoL )
{
	return rcp( 4 * ( NoL + NoV - NoL * NoV ) );
}
float3 SimpleClearCoatTransmittance(float NoL, float NoV, float Metallic, float3 BaseColor)
{
	float3 Transmittance = 1.0;
	float ClearCoatCoverage = Metallic;
	if (ClearCoatCoverage > 0.0)
	{
		float LayerThickness = 1.0;	
		float ThinDistance = LayerThickness * (rcp(NoV) + rcp(NoL));
		float3 TransmittanceColor = Diffuse_Lambert(BaseColor);
		float3 ExtinctionCoefficient = -log(max(TransmittanceColor,0.0001)) / (2.0 * LayerThickness);
		float3 OpticalDepth = ExtinctionCoefficient * max(ThinDistance - 2.0 * LayerThickness, 0.0);
		Transmittance = exp(-OpticalDepth);
		Transmittance = lerp(1.0, Transmittance, ClearCoatCoverage);
	}
	return Transmittance;
}
struct FCapsuleLight
{
	float3	LightPos[2];
	float	Length;
	float	Radius;
	float	SoftRadius;
	float	DistBiasSqr;
};
float3 ClosestPointLineToRay( float3 Line0, float3 Line1, float Length, float3 R )
{
	float3 L0 = Line0;
	float3 L1 = Line1;
	float3 Line01 = Line1 - Line0;
	float A = Square( Length );
	float B = dot( R, Line01 );
	float t = saturate( dot( Line0, B*R - Line01 ) / (A - B*B) );
	return Line0 + t * Line01;
}
float3 LineIrradiance( float3 N, float3 Line0, float3 Line1, float DistanceBiasSqr, out float CosSubtended, out float BaseIrradiance, out float NoL )
{
	float LengthSqr0 = dot( Line0, Line0 );
	float LengthSqr1 = dot( Line1, Line1 );
	float InvLength0 = rsqrt( LengthSqr0 );
	float InvLength1 = rsqrt( LengthSqr1 );
	float InvLength01 = InvLength0 * InvLength1;
	CosSubtended = dot( Line0, Line1 ) * InvLength01;
	BaseIrradiance = InvLength01 / ( CosSubtended * 0.5 + 0.5 + DistanceBiasSqr * InvLength01 );
	NoL = 0.5 * ( dot(N, Line0) * InvLength0 + dot(N, Line1) * InvLength1 );
	float3 VectorIrradiance = ( BaseIrradiance * 0.5 ) * ( Line0 * InvLength0 + Line1 * InvLength1 );
	return VectorIrradiance;
}
float SphereHorizonCosWrap( float NoL, float SinAlphaSqr )
{
	float SinAlpha = sqrt( SinAlphaSqr );
	if( NoL < SinAlpha )
	{
		NoL = max( NoL, -SinAlpha );
		NoL = Pow2( SinAlpha + NoL ) / ( 4 * SinAlpha );
	}
	return NoL;
}
struct FRectTexture
{
	float2 AtlasUVOffset;
	float2 AtlasUVScale;
	float  AtlasMaxLevel;
};
FRectTexture InitRectTexture()
{
	FRectTexture Out;
	Out.AtlasUVOffset = 0;
	Out.AtlasUVScale  = 0;
	Out.AtlasMaxLevel = 32;
	return Out;
}
struct FRectLightData
{
	float		 BarnCosAngle;
	float		 BarnLength;
	FRectTexture AtlasData;
};
FRectLightData UnpackRectLightData(uint In0, uint In1, uint In2)
{
	FRectLightData Out;
	Out.AtlasData.AtlasUVOffset	= float2(f16tof32(In0 & 0xFFFF), f16tof32(In0 >> 16));
	Out.AtlasData.AtlasUVScale	= float2(f16tof32(In1 & 0xFFFF), f16tof32(In1 >> 16));
	Out.BarnLength				= f16tof32(In2 & 0xFFFF);			
	Out.BarnCosAngle			= UnpackUnorm10(In2 >> 16);			
	Out.AtlasData.AtlasMaxLevel = float(In2 >> 26);					
	return Out;
}
struct FDirectionalLightData
{
	uint   HasDirectionalLight;
	uint   DirectionalLightShadowMapChannelMask;
	float2 DirectionalLightDistanceFadeMAD;
	float3 DirectionalLightColor;
	float3 DirectionalLightDirection;
	float  DirectionalLightSourceRadius;
	float  DirectionalLightSoftSourceRadius;
	float  DirectionalLightSpecularScale;
	uint  LightFunctionAtlasLightIndex;
};
struct FLocalLightData
{
	float4 LightPositionAndInvRadius;
	float4 LightColorAndIdAndFalloffExponent;
	float4 SpotAnglesAndSourceRadiusPacked;
	float4 LightDirectionAndShadowMask;
	float4 LightTangentAndIESDataAndSpecularScale;
	float3 RectData;
	bool bClusteredDeferredSupported;
	bool bManyLightsSupported;
	bool bIsSimpleLight;
	int  VirtualShadowMapId;
	int  PrevLocalLightIndex;
	int LightSceneId;
};
struct FLightShaderParameters
{
	float3 TranslatedWorldPosition;
	float  InvRadius;
	float3 Color;
	float  FalloffExponent;
	float3 Direction;
	float3 Tangent;
	float2 SpotAngles;
	float  SpecularScale;
	float  SourceRadius;
	float  SoftSourceRadius;
	float  SourceLength;
	float  RectLightBarnCosAngle;
	float  RectLightBarnLength;
	float2 RectLightAtlasUVOffset;
	float2 RectLightAtlasUVScale;
	float  RectLightAtlasMaxLevel;
	float  IESAtlasIndex;
	uint  LightFunctionAtlasLightIndex;
};
struct FDeferredLightData
{
	float3 TranslatedWorldPosition;
	float   InvRadius;
	float3 Color;
	float   FalloffExponent;
	float3 Direction;
	float3 Tangent;
	float  SoftSourceRadius;
	float2  SpotAngles;
	float  SourceRadius;
	float  SourceLength;
	float   SpecularScale;
	float  ContactShadowLength;
	float ContactShadowCastingIntensity;
	float ContactShadowNonCastingIntensity;
	float2 DistanceFadeMAD;
	float4  ShadowMapChannelMask;
	bool   ContactShadowLengthInWS;
	bool   bInverseSquared;
	bool   bRadialLight;
	bool   bSpotLight;
	bool   bRectLight;
	uint   ShadowedBits;
	FRectLightData RectLightData;
	float  IESAtlasIndex;
	uint  LightFunctionAtlasLightIndex;
	FHairTransmittanceData HairTransmittance;
};
float3 UnpackLightColor(float2 In)
{
	float3 Dir = float3(
		((asuint(In.y) >> 0) & 0x3FF),
		((asuint(In.y) >> 10) & 0x3FF),
		((asuint(In.y) >> 20) & 0x3FF));
	return In.x * Dir;
}
float4 UnpackShadowMapChannelMask(uint In)
{
	return float4((In & 0x1), (In & 0x2) >> 1, (In & 0x4) >> 2, (In & 0x8) >> 3);
}
uint UnpackLightingChannelMask(uint In)
{
	return (In >> 8) & 0x7;
}
uint UnpackLightingChannelMask(FLocalLightData In)
{
	const uint LightTypeAndPackedShadowMapChannelMask = asuint(In.LightDirectionAndShadowMask.w);
	return UnpackLightingChannelMask(LightTypeAndPackedShadowMapChannelMask);
}
uint UnpackLightType(uint InShadowMapChannelMaskPacked)
{
	return (InShadowMapChannelMaskPacked >> 16) & 0x3;
}
uint UnpackLightFunctionAtlasIndex(uint InShadowMapChannelMaskPacked)
{
	return ((InShadowMapChannelMaskPacked >> 20) & 0xFF);
}
uint UnpackLightFunctionAtlasIndex(FLocalLightData In)
{
	const uint LightTypeAndPackedShadowMapChannelMask = asuint(In.LightDirectionAndShadowMask.w);
	return UnpackLightFunctionAtlasIndex(LightTypeAndPackedShadowMapChannelMask);
}
float UnpackLightSourceRadius(FLocalLightData In)
{
	return f16tof32(asuint(In.SpotAnglesAndSourceRadiusPacked.z) & 0xFFFF);
}
float UnpackLightSoftSourceRadius(FLocalLightData In)
{
	return f16tof32(asuint(In.SpotAnglesAndSourceRadiusPacked.z) >> 16);
}
float UnpackLightSourceLength(FLocalLightData In)
{
	return f16tof32(asuint(In.SpotAnglesAndSourceRadiusPacked.w));
}
float2 GetLightSpotAngles(FLocalLightData In)
{
	return In.SpotAnglesAndSourceRadiusPacked.xy;
}
float UnpackLightSpecularScale(FLocalLightData In)
{
	return f16tof32(asuint(In.LightTangentAndIESDataAndSpecularScale.w) & 0xFFFF);
}
float UnpackLigthIESAtlasIndex(FLocalLightData In)
{
	return f16tof32(asuint(In.LightTangentAndIESDataAndSpecularScale.w) >> 16);
}
FRectTexture ConvertToRectTexture(FDeferredLightData In)
{
	FRectTexture Output;
	Output.AtlasUVOffset = In.RectLightData.AtlasData.AtlasUVOffset;
	Output.AtlasUVScale  = In.RectLightData.AtlasData.AtlasUVScale;
	Output.AtlasMaxLevel = In.RectLightData.AtlasData.AtlasMaxLevel;
	return Output;
}
FDeferredLightData ConvertToDeferredLight(
	const FLocalLightData In, 
	float InSpecularScale, 
	inout float4 OutPreviewShadowMapChannelMask,
	inout uint  OutLightingChannelMask)
{
	FDeferredLightData Out = (FDeferredLightData)0;
	const uint LightTypeAndPackedShadowMapChannelMask = asuint(In.LightDirectionAndShadowMask.w);
	const uint LightType = UnpackLightType(LightTypeAndPackedShadowMapChannelMask);
	Out.TranslatedWorldPosition = In.LightPositionAndInvRadius.xyz;
	Out.InvRadius				= In.LightPositionAndInvRadius.w;
	Out.Color					= UnpackLightColor(In.LightColorAndIdAndFalloffExponent.xy);
	Out.FalloffExponent			= In.LightColorAndIdAndFalloffExponent.w;
	Out.Direction				= In.LightDirectionAndShadowMask.xyz;
	Out.SpotAngles				= GetLightSpotAngles(In);
	Out.SourceRadius			= UnpackLightSourceRadius(In);
	Out.SourceLength			= UnpackLightSourceLength(In);
	Out.Tangent					= In.LightTangentAndIESDataAndSpecularScale.xyz;
	Out.SoftSourceRadius		= UnpackLightSoftSourceRadius(In);
	Out.bInverseSquared			= Out.FalloffExponent == 0;
	Out.SpecularScale			= UnpackLightSpecularScale(In) * InSpecularScale;
	Out.bRadialLight			= true;
	Out.bSpotLight				= LightType == 2;
	Out.bRectLight				= LightType == 3;
	Out.HairTransmittance		= InitHairTransmittanceData();
	Out.RectLightData			= UnpackRectLightData(
									asuint(In.RectData.x),
									asuint(In.RectData.y),
									asuint(In.RectData.z));
	Out.IESAtlasIndex			= UnpackLigthIESAtlasIndex(In);
	Out.LightFunctionAtlasLightIndex = UnpackLightFunctionAtlasIndex(In);
	Out.ShadowedBits				= (LightTypeAndPackedShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
	Out.ShadowMapChannelMask		= UnpackShadowMapChannelMask(LightTypeAndPackedShadowMapChannelMask);
	OutPreviewShadowMapChannelMask	= UnpackShadowMapChannelMask(LightTypeAndPackedShadowMapChannelMask >> 4);
	OutLightingChannelMask			= UnpackLightingChannelMask(LightTypeAndPackedShadowMapChannelMask);
	return Out;
}
FDeferredLightData ConvertToDeferredLight(const FLocalLightData In)
{
	float4 OutPreviewShadowMapChannelMask = 0;
	uint OutLightingChannelMask = 0x7;
	return ConvertToDeferredLight(In, 1.0f, OutPreviewShadowMapChannelMask, OutLightingChannelMask);
}
FDeferredLightData ConvertToDeferredLight(
	FDirectionalLightData In, 
	float InSpecularScale, 
	inout float4 OutPreviewShadowMapChannelMask,
	inout uint OutLightingChannelMask)
{
	FDeferredLightData Out	= (FDeferredLightData)0;
	Out.Color				= In.DirectionalLightColor;
	Out.FalloffExponent		= 0;
	Out.Direction			= In.DirectionalLightDirection;
	Out.DistanceFadeMAD		= In.DirectionalLightDistanceFadeMAD;
	Out.bRadialLight		= false;
	Out.SpecularScale		= In.DirectionalLightSpecularScale * InSpecularScale;
	Out.ShadowedBits		= (In.DirectionalLightShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
	Out.HairTransmittance	= InitHairTransmittanceData();
	Out.SourceRadius		= In.DirectionalLightSourceRadius;
	Out.SoftSourceRadius	= In.DirectionalLightSoftSourceRadius;
	Out.LightFunctionAtlasLightIndex = In.LightFunctionAtlasLightIndex;
	Out.ShadowMapChannelMask		= UnpackShadowMapChannelMask(In.DirectionalLightShadowMapChannelMask);
	OutPreviewShadowMapChannelMask	= UnpackShadowMapChannelMask(In.DirectionalLightShadowMapChannelMask >> 4);
	OutLightingChannelMask			= UnpackLightingChannelMask(In.DirectionalLightShadowMapChannelMask);
	return Out;
}
FDeferredLightData ConvertToDeferredLight(FLightSceneData In)
{
	FDeferredLightData Out = (FDeferredLightData)0;
	const uint LightType = UnpackLightType(In.LightTypeAndShadowMapChannelMaskPacked);
	Out.TranslatedWorldPosition = DFFastAddDemote(In.WorldPosition, GetPrimaryView().PreViewTranslation);
	Out.InvRadius				= In.InvRadius;
	Out.Color					= In.Color.xyz;
	Out.FalloffExponent			= In.FalloffExponent;
	Out.Direction				= In.Direction;
	Out.SpotAngles				= In.SpotAngles;
	Out.SourceRadius			= In.SourceRadius;
	Out.SourceLength			= In.SourceLength;
	Out.Tangent					= In.Tangent;
	Out.SoftSourceRadius		= In.SoftSourceRadius;
	Out.bInverseSquared			= In.FalloffExponent == 0;
	Out.SpecularScale			= In.SpecularScale;
	Out.bRadialLight			= true;
	Out.bSpotLight				= LightType == 2;
	Out.bRectLight				= LightType == 3;
	Out.HairTransmittance		= InitHairTransmittanceData();
	Out.RectLightData.BarnCosAngle = In.RectLightBarnCosAngle;
	Out.RectLightData.BarnLength = In.RectLightBarnLength;
	Out.RectLightData.AtlasData.AtlasMaxLevel = In.RectLightAtlasMaxLevel;
	Out.RectLightData.AtlasData.AtlasUVOffset = In.RectLightAtlasUVOffset;
	Out.RectLightData.AtlasData.AtlasUVScale = In.RectLightAtlasUVScale;
	Out.IESAtlasIndex					= In.IESAtlasIndex;
	Out.LightFunctionAtlasLightIndex	= UnpackLightFunctionAtlasIndex(In.LightTypeAndShadowMapChannelMaskPacked);
	Out.ShadowedBits				= (In.LightTypeAndShadowMapChannelMaskPacked & 0xFF) != 0 ? 1 : 0;
	Out.ShadowMapChannelMask		= UnpackShadowMapChannelMask(In.LightTypeAndShadowMapChannelMaskPacked);
	return Out;
}
struct FRect
{
	float3		Origin;
	float3x3	Axis;
	float2		Extent;
	float2		FullExtent;
	float2		Offset;
};
float3 SampleRectTexture(FRectTexture RectTexture, float2 RectUV, float Level, bool bIsReference = false)
{
	const bool bIsValid = RectTexture.AtlasMaxLevel < 32;
	const float2 RectTextureSize = RectTexture.AtlasUVScale * View.RectLightAtlasSizeAndInvSize.xy;
	Level += log2(min(RectTextureSize.x, RectTextureSize.y)) - 2.f;
	Level  = min(Level, RectTexture.AtlasMaxLevel);
	RectUV = saturate(RectUV) * RectTexture.AtlasUVScale + RectTexture.AtlasUVOffset;
	return bIsValid ? View_RectLightAtlasTexture.SampleLevel(View_SharedTrilinearClampedSampler, RectUV, bIsReference ? 0 : Level).rgb : 1.f;
}
float3 RectIrradianceLambert( float3 N, FRect Rect, out float BaseIrradiance, out float NoL )
{
	float3 LocalPosition;
	LocalPosition.x = dot( Rect.Axis[0], Rect.Origin );		
	LocalPosition.y = dot( Rect.Axis[1], Rect.Origin );		
	LocalPosition.z = dot( Rect.Axis[2], Rect.Origin );		
	float x0 = LocalPosition.x - Rect.Extent.x;
	float x1 = LocalPosition.x + Rect.Extent.x;
	float y0 = LocalPosition.y - Rect.Extent.y;
	float y1 = LocalPosition.y + Rect.Extent.y;
	float z0 = LocalPosition.z;
	float z0Sqr = z0 * z0;
	float3 v0 = float3( x0, y0, z0 );
	float3 v1 = float3( x1, y0, z0 );
	float3 v2 = float3( x1, y1, z0 );
	float3 v3 = float3( x0, y1, z0 );
	float3 L0 = v0 * rsqrt( dot( v0.xy, v0.xy ) + z0Sqr );	
	float3 L1 = v1 * rsqrt( dot( v1.xy, v1.xy ) + z0Sqr );	
	float3 L2 = v2 * rsqrt( dot( v2.xy, v2.xy ) + z0Sqr );	
	float3 L3 = v3 * rsqrt( dot( v3.xy, v3.xy ) + z0Sqr );	
	float c01 = dot( L0, L1 );
	float c12 = dot( L1, L2 );
	float c23 = dot( L2, L3 );
	float c30 = dot( L3, L0 );
	float w01 = ( 1.5708 - 0.175 * c01 ) * rsqrt( c01 + 1 );	
	float w12 = ( 1.5708 - 0.175 * c12 ) * rsqrt( c12 + 1 );	
	float w23 = ( 1.5708 - 0.175 * c23 ) * rsqrt( c23 + 1 );	
	float w30 = ( 1.5708 - 0.175 * c30 ) * rsqrt( c30 + 1 );	
	float3 L;
	L  = cross( L1, -w01 * L0 +  w12 * L2 );	
	L += cross( L3,  w30 * L0 + -w23 * L2 );	
	L = L.x * Rect.Axis[0] + L.y * Rect.Axis[1] + L.z * Rect.Axis[2];	
	float LengthSqr = dot( L, L );
	float InvLength = rsqrt( LengthSqr );
	float Length = LengthSqr * InvLength;
	L *= InvLength;
	BaseIrradiance = 0.5 * Length;
	float SinAlphaSqr = BaseIrradiance * (1.0 / PI);
	NoL = SphereHorizonCosWrap( dot( N, L ), SinAlphaSqr );
	return L;
}
float3 SampleSourceTexture( float3 L, FRect Rect, FRectTexture RectTexture)
{
	L += Rect.Axis[2] * saturate( 0.001 - dot( Rect.Axis[2], L ) );
	float DistToPlane = dot( Rect.Axis[2], Rect.Origin ) / dot( Rect.Axis[2], L );
	float3 PointOnPlane = L * DistToPlane;
	float2 PointInRect;
	PointInRect.x = dot( Rect.Axis[0], PointOnPlane - Rect.Origin );
	PointInRect.y = dot( Rect.Axis[1], PointOnPlane - Rect.Origin );
    float2 RectUV = (PointInRect + Rect.Offset) / max(0.0001f, Rect.FullExtent) * float2(0.5, -0.5) + 0.5;
	float Level = log2( DistToPlane * rsqrt( max(0.0001f, Rect.FullExtent.x * Rect.FullExtent.y) ) );
    return SampleRectTexture(RectTexture, RectUV, Level);
}
float IntegrateEdge( float3 L0, float3 L1 )
{
	float c01 = dot( L0, L1 );
	float w01 = ( 0.8543985 + (0.4965155 + 0.0145206 * abs(c01)) * abs(c01) ) /
				( 3.4175940 + (4.1616724 + abs(c01)) * abs(c01) );
	w01 = c01 > 0 ? w01 : 0.5 * rsqrt( 1 - c01 * c01 ) - w01;
	return w01;
}
float3 PolygonIrradiance( float3 Poly[4] )
{
	float3 L0 = normalize( Poly[0] );	
	float3 L1 = normalize( Poly[1] );	
	float3 L2 = normalize( Poly[2] );	
	float3 L3 = normalize( Poly[3] );	
	float w01 = IntegrateEdge( L0, L1 );
	float w12 = IntegrateEdge( L1, L2 );
	float w23 = IntegrateEdge( L2, L3 );
	float w30 = IntegrateEdge( L3, L0 );
	float3 L;
	L  = cross( L1, -w01 * L0 +  w12 * L2 );	
	L += cross( L3,  w30 * L0 + -w23 * L2 );	
	return L;
}
struct FRectLTC
{
	float3x3 LTC;
	float3x3 InvLTC;
	float3 IrradianceScale;
};
FRectLTC GetRectLTC_GGX( float Roughness, float3 SpecularColor, float NoV)
{
	const float3 F0  = SpecularColor;
	const float3 F90 = saturate(50.0 * SpecularColor);
	float2 UV = float2( Roughness, sqrt( 1 - NoV ) );
	UV = UV * (63.0 / 64.0) + (0.5 / 64.0);
	float4 LTCMat = View_GGXLTCMatTexture.SampleLevel( View_GGXLTCMatSampler, UV, 0 );
	float4 LTCAmp = View_GGXLTCAmpTexture.SampleLevel( View_GGXLTCAmpSampler, UV, 0 );
	float3x3 LTC = {
		float3( LTCMat.x, 0, LTCMat.z ),
		float3(        0, 1,        0 ),
		float3( LTCMat.y, 0, LTCMat.w )
	};
	float LTCDet = LTCMat.x * LTCMat.w - LTCMat.y * LTCMat.z;
	float4 InvLTCMat = LTCMat / LTCDet;
	float3x3 InvLTC = {
		float3( InvLTCMat.w, 0,-InvLTCMat.z ),
		float3(	          0, 1,           0 ),
		float3(-InvLTCMat.y, 0, InvLTCMat.x )
	};
	FRectLTC Out = (FRectLTC)0;
	Out.LTC = LTC;
	Out.InvLTC = InvLTC;
	Out.IrradianceScale = F90 * LTCAmp.y + ( LTCAmp.x - LTCAmp.y ) * F0;
	return Out;
}
float3 RectApproxLTC(FRectLTC In, float3 N, float3 V, FRect Rect, FRectTexture RectTexture, inout float3 OutMeanLightWorldDirection)
{	
	if (Rect.Extent.x == 0 || Rect.Extent.y == 0) return 0;
	float3 T1 = normalize( V - N * dot( N, V ) );
	float3 T2 = cross( N, T1 );
	float3x3 TangentBasis = float3x3( T1, T2, N );
	In.LTC = mul( In.LTC, TangentBasis );
	In.InvLTC = mul( transpose( TangentBasis ), In.InvLTC );
	float3 Poly[4];
	Poly[0] = mul( In.LTC, Rect.Origin - Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y );
	Poly[1] = mul( In.LTC, Rect.Origin + Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y );
	Poly[2] = mul( In.LTC, Rect.Origin + Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y );
	Poly[3] = mul( In.LTC, Rect.Origin - Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y );
	float3 L = PolygonIrradiance( Poly );
	float LengthSqr = dot( L, L );
	float InvLength = rsqrt( LengthSqr );
	float Length = LengthSqr * InvLength;
	L *= InvLength;
	float SinAlphaSqr = Length;
	float NoL = SphereHorizonCosWrap( L.z, SinAlphaSqr );
	float Irradiance = SinAlphaSqr * NoL;
	Irradiance = -min(-Irradiance, 0.0);
	L = mul( In.InvLTC, L );
	OutMeanLightWorldDirection = L;
	float3 LightColor = SampleSourceTexture( L, Rect, RectTexture );
	return LightColor * Irradiance * In.IrradianceScale;
}
float3 RectGGXApproxLTC( float Roughness, float3 SpecularColor, float3 N, float3 V, FRect Rect, FRectTexture RectTexture, inout float3 OutMeanLightWorldDirection)
{
	if (Rect.Extent.x == 0 || Rect.Extent.y == 0) return 0;
	const float NoV = saturate( abs( dot(N, V) ) + 1e-5 );
	const FRectLTC LTC = GetRectLTC_GGX(Roughness, SpecularColor, NoV);
	return RectApproxLTC(LTC, N, V, Rect, RectTexture, OutMeanLightWorldDirection);
}
float3 RectGGXApproxLTC(float Roughness, float3 SpecularColor, float3 N, float3 V, FRect Rect, FRectTexture RectTexture)
{
	float3 MeanLightWorldDirection = 0.0f;
	return RectGGXApproxLTC(Roughness, SpecularColor, N, V, Rect, RectTexture, MeanLightWorldDirection);
}
struct FSphericalRect
{
	float3x3	Axis;
	float		x0;
	float		x1;
	float		y0;
	float		y1;
	float		z0;
	float		b0;
	float		b1;
	float		k;
	float		SolidAngle;
};
FSphericalRect BuildSphericalRect( FRect Rect )
{
	FSphericalRect SphericalRect;
	SphericalRect.Axis = Rect.Axis;
	float3 LocalPosition;
	LocalPosition.x = dot( Rect.Axis[0], Rect.Origin );
	LocalPosition.y = dot( Rect.Axis[1], Rect.Origin );
	LocalPosition.z = dot( Rect.Axis[2], Rect.Origin );
	SphericalRect.x0 = LocalPosition.x - Rect.Extent.x;
	SphericalRect.x1 = LocalPosition.x + Rect.Extent.x;
	SphericalRect.y0 = LocalPosition.y - Rect.Extent.y;
	SphericalRect.y1 = LocalPosition.y + Rect.Extent.y;
	SphericalRect.z0 = -abs( LocalPosition.z );
	SphericalRect.Axis[2] *= LocalPosition.z > 0 ? -1 : 1;
	float3 v0 = float3( SphericalRect.x0, SphericalRect.y0, SphericalRect.z0 );
	float3 v1 = float3( SphericalRect.x1, SphericalRect.y0, SphericalRect.z0 );
	float3 v2 = float3( SphericalRect.x1, SphericalRect.y1, SphericalRect.z0 );
	float3 v3 = float3( SphericalRect.x0, SphericalRect.y1, SphericalRect.z0 );
	float3 n0 = normalize( cross( v0, v1 ) );
	float3 n1 = normalize( cross( v1, v2 ) );
	float3 n2 = normalize( cross( v2, v3 ) );
	float3 n3 = normalize( cross( v3, v0 ) );
	float g0 = acos( -dot( n0, n1 ) );
	float g1 = acos( -dot( n1, n2 ) );
	float g2 = acos( -dot( n2, n3 ) );
	float g3 = acos( -dot( n3, n0 ) );
	SphericalRect.b0 = n0.z;
	SphericalRect.b1 = n2.z;
	SphericalRect.k = 2*PI - g2 - g3;
	SphericalRect.SolidAngle = g0 + g1 - SphericalRect.k;
	return SphericalRect;
}
struct FSphericalRectSample {
	float3 Direction;
	float2 UV;
};
FSphericalRectSample UniformSampleSphericalRectWithUV(float2 E, FSphericalRect Rect)
{
	float au = E.x * Rect.SolidAngle + Rect.k;
	float fu = (cos(au) * Rect.b0 - Rect.b1) / sin(au);
	float cu = rsqrt(fu * fu + Rect.b0 * Rect.b0) * (fu > 0 ? 1 : -1);
	cu = clamp(cu, -1, 1);				
	float xu = -(cu * Rect.z0) * rsqrt(1 - cu * cu);
	xu = clamp(xu, Rect.x0, Rect.x1);	
	float d = sqrt(xu * xu + Rect.z0 * Rect.z0);
	float h0 = Rect.y0 * rsqrt(d * d + Rect.y0 * Rect.y0);
	float h1 = Rect.y1 * rsqrt(d * d + Rect.y1 * Rect.y1);
	float hv = h0 + E.y * (h1 - h0);
	float yv = (hv * hv < 1 - 1e-6) ? (hv * d) * rsqrt(1 - hv * hv) : Rect.y1;
	FSphericalRectSample Result;
	Result.Direction = mul(float3(xu, yv, Rect.z0), Rect.Axis);
	Result.UV = float2(xu - Rect.x0, yv - Rect.y0) / float2(Rect.x1 - Rect.x0, Rect.y1 - Rect.y0);
	return Result;
}
float3 UniformSampleSphericalRect( float2 E, FSphericalRect Rect )
{
	return UniformSampleSphericalRectWithUV(E, Rect).Direction;
}
FRect GetRect(
	float3 ToLight, 
	float3 LightDataDirection, 
	float3 LightDataTangent, 
	float LightDataSourceRadius, 
	float LightDataSourceLength, 
	float LightDataRectLightBarnCosAngle, 
	float LightDataRectLightBarnLength,
	bool bComputeVisibleRect)
{
	FRect Rect;
	Rect.Origin = ToLight;
	Rect.Axis[1] = LightDataTangent;
	Rect.Axis[2] = LightDataDirection;
	Rect.Axis[0] = cross( Rect.Axis[1], Rect.Axis[2] );
	Rect.Extent = float2(LightDataSourceRadius, LightDataSourceLength);
	Rect.FullExtent = Rect.Extent;
	Rect.Offset = 0;
	if (bComputeVisibleRect && LightDataRectLightBarnCosAngle > 0.035f)
	{
		const float3 LightdPdv = -Rect.Axis[1];
		const float3 LightdPdu = -Rect.Axis[0];
		const float2 LightExtent = float2(LightDataSourceRadius, LightDataSourceLength);
		const float BarnLength = LightDataRectLightBarnLength;
		float3 S_Light = mul(Rect.Axis, ToLight);
		const float CosTheta = LightDataRectLightBarnCosAngle;
		const float SinTheta = sqrt(1 - CosTheta * CosTheta);
		const float BarnDepth = min(S_Light.z, CosTheta * BarnLength);
		const float S_ratio = BarnDepth / max(0.0001f, CosTheta * BarnLength);
		const float D_B = SinTheta * BarnLength * S_ratio;
		const float2 SignS = sign(S_Light.xy);
		S_Light.xy = SignS * max(abs(S_Light.xy), LightExtent + D_B.xx);
		const float3 C = float3(SignS * (LightExtent + D_B.xx), BarnDepth);
		const float3 SProj = S_Light - C;
		const float CosEta = max(SProj.z, 0.001f);
		const float2 SinEta = abs(SProj.xy);
		const float2 TanEta = abs(SProj.xy) / CosEta;
		const float2 D_S = BarnDepth * TanEta;
		const float2 MinXY = clamp(-LightExtent + (D_S - D_B.xx) * max(0, -SignS), -LightExtent, LightExtent);
		const float2 MaxXY = clamp( LightExtent - (D_S - D_B.xx) * max(0,  SignS), -LightExtent, LightExtent);
		const float2 RectOffset = 0.5f * (MinXY + MaxXY);
		Rect.Extent = 0.5f * (MaxXY - MinXY);
		Rect.Origin = Rect.Origin + LightdPdu * RectOffset.x + LightdPdv * RectOffset.y;
		Rect.Offset = -RectOffset;
		Rect.FullExtent = LightExtent;
	}
	return Rect;
}
FRect GetRect(FLightShaderParameters In, float3 TranslatedWorldPosition)
{
	return GetRect(In.TranslatedWorldPosition - TranslatedWorldPosition,
		In.Direction,
		In.Tangent,
		In.SourceRadius,
		In.SourceLength,
		In.RectLightBarnCosAngle,
		In.RectLightBarnLength,
		true);
}
bool IsRectVisible(FRect Rect)
{
	return Rect.Extent.x != 0 && Rect.Extent.y != 0;
}
struct FAreaLight
{
	float		SphereSinAlpha;
	float		SphereSinAlphaSoft;
	float		LineCosSubtended;
	float3		FalloffColor;
	FRect		Rect;
	FRectTexture Texture;
	uint		IsRectAndDiffuseMicroReflWeight;
};
struct FAreaLightIntegrateContext
{
	FAreaLight AreaLight;
	float3 L;
	float NoL;
	float Falloff;
};
void SetIsRectLight(inout FAreaLight AreaLight, bool bIsRectLight)
{
	AreaLight.IsRectAndDiffuseMicroReflWeight = (AreaLight.IsRectAndDiffuseMicroReflWeight & 0xFFFFFFFE) | (bIsRectLight ? 0x1 : 0x0);
}
bool IsRectLight(FAreaLight AreaLight)
{
	return (AreaLight.IsRectAndDiffuseMicroReflWeight & 0x00000001) == 0x1;
}
void SetAreaLightDiffuseMicroReflWeight(inout FAreaLight AreaLight, float Weight)
{
	AreaLight.IsRectAndDiffuseMicroReflWeight = (AreaLight.IsRectAndDiffuseMicroReflWeight & 0x00000001) | (asuint(Weight) << 1);
}
FAreaLightIntegrateContext InitAreaLightIntegrateContext()
{
	FAreaLightIntegrateContext Out;
	Out.AreaLight.SphereSinAlpha = 0;
	Out.AreaLight.SphereSinAlphaSoft = 0;
	Out.AreaLight.LineCosSubtended = 0;
	Out.AreaLight.FalloffColor = 0;
	Out.AreaLight.Rect = (FRect)0;
	Out.AreaLight.IsRectAndDiffuseMicroReflWeight = 0;
	Out.AreaLight.Texture = InitRectTexture();
	Out.L = 0;
	Out.NoL = 0;
	Out.Falloff = 0;
	return Out;
}
float4 GetSubsurfaceProfileTexture(uint SampleIndex, uint SubsurfaceProfileInt)
{
	return View_SSProfilesTexture.Load(int3(SampleIndex, SubsurfaceProfileInt, 0));
}
float4 GetSubsurfaceProfileTexture(Texture2D InSSProfilesTexture, SamplerState InSSProfilesSampler, float4 InSSProfilesTextureSizeAndInvSize, uint SampleIndex, uint SubsurfaceProfileInt)
{
	return InSSProfilesTexture.Load(int3(SampleIndex, SubsurfaceProfileInt, 0));
}
void GetSubsurfaceProfileDualSpecular(uint SubsurfaceProfileInt, float Roughness, float Opacity, out float LobeRoughness0, out float LobeRoughness1, out float LobeMix)
{
	const float4 Data = GetSubsurfaceProfileTexture((((((0+1)+1)+1)+1)+1), SubsurfaceProfileInt);
	float MaterialRoughnessToLobeRoughness0 = lerp(1.0f, Data.x * 2.0f, saturate((Opacity - 0.10) * 10.0f));
	float MaterialRoughnessToLobeRoughness1 = lerp(1.0f, Data.y * 2.0f, saturate((Opacity - 0.10) * 10.0f));
	LobeMix = Data.z;
	LobeRoughness0 = max(saturate(Roughness * MaterialRoughnessToLobeRoughness0), 0.02f);
	LobeRoughness1 = saturate(Roughness * MaterialRoughnessToLobeRoughness1);
}
float GetSubSurfaceTransmission( float OccluderDistance, float SubsurfaceDensity) { return saturate(FastExp(-OccluderDistance * SubsurfaceDensity)); }
float4 GetSubSurfaceTransmission( float4 OccluderDistance, float SubsurfaceDensity) { return saturate(FastExp(-OccluderDistance * SubsurfaceDensity)); }
float Hair_g(float B, float Theta)
{
	return exp(-0.5 * Pow2(Theta) / (B * B)) / (sqrt(2 * PI) * B);
}
float Hair_F(float CosTheta)
{
	const float n = 1.55;
	const float F0 = Pow2((1 - n) / (1 + n));
	return F0 + (1 - F0) * Pow5(1 - CosTheta);
}
float3 KajiyaKayDiffuseAttenuation(FGBufferData GBuffer, float3 L, float3 V, float3 N, float Shadow)
{
	float KajiyaDiffuse = 1 - abs(dot(N, L));
	float3 FakeNormal = normalize(V - N * dot(V, N));
	N = FakeNormal;
	float MinValue = 0.0001f;
	float Wrap = 1;
	float NoL = saturate((dot(N, L) + Wrap) / Square(1 + Wrap));
	float DiffuseScatter = (1 / PI) * lerp(NoL, KajiyaDiffuse, 0.33) * GBuffer.Metallic;
	float Luma = Luminance(GBuffer.BaseColor);
    float3 BaseOverLuma = abs(GBuffer.BaseColor / max(Luma, MinValue));
	float3 ScatterTint = Shadow < 1 ? pow(BaseOverLuma, 1 - Shadow) : 1;
	return sqrt(abs(GBuffer.BaseColor)) * DiffuseScatter * ScatterTint;
}
float3 EvaluateHairMultipleScattering(
	const FHairTransmittanceData TransmittanceData,
	const float Roughness,
	const float3 Fs)
{
	return TransmittanceData.GlobalScattering * (Fs + TransmittanceData.LocalScattering) * TransmittanceData.OpaqueVisibility;
}
float3 HairShading( FGBufferData GBuffer, float3 L, float3 V, float3 N, float Shadow, FHairTransmittanceData HairTransmittance, float InBacklit, float Area, uint2 Random )
{
	float ClampedRoughness = clamp(GBuffer.Roughness, 1/255.0f, 1.0f);
	const float Backlit	= min(InBacklit, HairTransmittance.bUseBacklit ? GBuffer.CustomData.z : 1);
	const float VoL       = dot(V,L);                                                      
	const float SinThetaL = clamp(dot(N,L), -1.f, 1.f);
	const float SinThetaV = clamp(dot(N,V), -1.f, 1.f);
	float CosThetaD = cos( 0.5 * abs( asinFast( SinThetaV ) - asinFast( SinThetaL ) ) );
	const float3 Lp = L - SinThetaL * N;
	const float3 Vp = V - SinThetaV * N;
	const float CosPhi = dot(Lp,Vp) * rsqrt( dot(Lp,Lp) * dot(Vp,Vp) + 1e-4 );
	const float CosHalfPhi = sqrt( saturate( 0.5 + 0.5 * CosPhi ) );
	float n = 1.55;
	float n_prime = 1.19 / CosThetaD + 0.36 * CosThetaD;
	float Shift = 0.035;
	float Alpha[] =
	{
		-Shift * 2,
		Shift,
		Shift * 4,
	};	
	float B[] =
	{
		Area + Pow2(ClampedRoughness),
		Area + Pow2(ClampedRoughness) / 2,
		Area + Pow2(ClampedRoughness) * 2,
	};
	float3 S = 0;
	if (HairTransmittance.ScatteringComponent & 0x1u)
	{
		const float sa = sin(Alpha[0]);
		const float ca = cos(Alpha[0]);
		float ShiftR = 2 * sa * (ca * CosHalfPhi * sqrt(1 - SinThetaV * SinThetaV) + sa * SinThetaV);
		float BScale = HairTransmittance.bUseSeparableR ? sqrt(2.0) * CosHalfPhi : 1;
		float Mp = Hair_g(B[0] * BScale, SinThetaL + SinThetaV - ShiftR);
		float Np = 0.25 * CosHalfPhi;
		float Fp = Hair_F(sqrt(saturate(0.5 + 0.5 * VoL)));
		S += Mp * Np * Fp * (GBuffer.Specular * 2) * lerp(1, Backlit, saturate(-VoL));
	}
	if (HairTransmittance.ScatteringComponent & 0x2u)
	{
		float Mp = Hair_g( B[1], SinThetaL + SinThetaV - Alpha[1] );
		float a = 1 / n_prime;
		float h = CosHalfPhi * ( 1 + a * ( 0.6 - 0.8 * CosPhi ) );
		float f = Hair_F( CosThetaD * sqrt( saturate( 1 - h*h ) ) );
		float Fp = Pow2(1 - f);
		float3 Tp = 0;
		if (HairTransmittance.bUseLegacyAbsorption)
		{
			Tp = pow(abs(GBuffer.BaseColor), 0.5 * sqrt(1 - Pow2(h * a)) / CosThetaD);
		}
		else
		{
			const float3 AbsorptionColor = HairColorToAbsorption(GBuffer.BaseColor);
			Tp = exp(-AbsorptionColor * 2 * abs(1 - Pow2(h * a) / CosThetaD));
		}
		float Np = exp( -3.65 * CosPhi - 3.98 );
		S += Mp * Np * Fp * Tp * Backlit;
	}
	if (HairTransmittance.ScatteringComponent & 0x4u)
	{
		float Mp = Hair_g( B[2], SinThetaL + SinThetaV - Alpha[2] );
		float f = Hair_F( CosThetaD * 0.5 );
		float Fp = Pow2(1 - f) * f;
		float3 Tp = pow(abs(GBuffer.BaseColor), 0.8 / CosThetaD );
		float Np = exp( 17 * CosPhi - 16.78 );
		S += Mp * Np * Fp * Tp;
	}
	if (HairTransmittance.ScatteringComponent & 0x20u)
	{
		S  = EvaluateHairMultipleScattering(HairTransmittance, ClampedRoughness, S);
		S += KajiyaKayDiffuseAttenuation(GBuffer, L, V, N, Shadow);
	}
	S = -min(-S, 0.0);
	return S;
}
float3   GetF0F90RGB(float3 InF0)
{
	return InF0;
}
struct   FBxDFEnergyTermsRGB
{
	float3 W; 
	float3 E; 
};
FBxDFEnergyTermsRGB   ComputeGGXSpecEnergyTermsRGB(float Roughness, float NoV, float3 F0, float3 F90)
{
	  FBxDFEnergyTermsRGB Out;
	{
		Out.W = 1.0f;
		Out.E =   GetF0F90RGB(F0);
	}
	return Out;
}
FBxDFEnergyTermsRGB   ComputeGGXSpecEnergyTermsRGB(float Roughness, float NoV, float3 F0)
{
	const float F90 = saturate(50.0 * F0.g); 
	return   ComputeGGXSpecEnergyTermsRGB(Roughness, NoV, F0, F90);
}
float ComputeEnergyPreservation(  FBxDFEnergyTermsRGB EnergyTerms)
{
	return 1.0f;
}
float3 ComputeEnergyConservation(  FBxDFEnergyTermsRGB EnergyTerms)
{
	return EnergyTerms.W;
}
struct   FBxDFEnergyTermsA
{
	float W; 
	float E; 
};
FBxDFEnergyTermsA   ComputeClothEnergyTermsA(float Roughness, float NoV)
{
	  FBxDFEnergyTermsA Out;
	{
		Out.W = 1.0f;
		Out.E = 1.0f;
	}
	return Out;
}
float ComputeEnergyPreservation(  FBxDFEnergyTermsA EnergyTerms)
{
	return 1.0f;
}
float ComputeEnergyConservation(  FBxDFEnergyTermsA EnergyTerms)
{
	return EnergyTerms.W;
}
float3 TransmittanceToExtinction(in float3 TransmittanceColor, in float ThicknessMeters)
{
	return -log(clamp(TransmittanceColor, 0.000000000001f, 1.0f)) / max(0.000000000001f, ThicknessMeters);
}
float3 ExtinctionToTransmittance(in float3 Extinction, in float ThicknessMeters)
{
	return exp(-Extinction * ThicknessMeters);
}
float Luminance( float3 LinearColor, float3 LuminanceFactors )
{
	return dot( LinearColor, LuminanceFactors );
}
float3 HUE_2_LinearRGB(in float H)
{
	float R = abs(H * 6 - 3) - 1;
	float G = 2 - abs(H * 6 - 2);
	float B = 2 - abs(H * 6 - 4);
	return saturate(float3(R, G, B));
}
float3 HSV_2_LinearRGB(in float3 HSV)
{
	float3 RGB = HUE_2_LinearRGB(HSV.x);
	return ((RGB - 1) * HSV.y + 1) * HSV.z;
}
float3 RGB_2_HCV(in float3 RGB)
{
	float4 P = (RGB.g < RGB.b)	? float4(RGB.bg, -1.0f, 2.0f / 3.0f): float4(RGB.gb, 0.0f, -1.0f / 3.0f);
	float4 Q = (RGB.r < P.x)	? float4(P.xyw, RGB.r)				: float4(RGB.r, P.yzx);
	float Chroma = Q.x - min(Q.w, Q.y);
	float Hue = abs((Q.w - Q.y) / (6.0f * Chroma + 1e-10f) + Q.z);
	return float3(Hue, Chroma, Q.x);
}
float3 LinearRGB_2_HSV(in float3 RGB)
{
	float3 HCV = RGB_2_HCV(RGB);
	float s = HCV.y / (HCV.z + 1e-10f);
	return float3(HCV.x, s, HCV.z);
}
struct FDirectLighting
{
	float3	Diffuse;
	float3	Specular;
	float3	Transmission;
};
struct FShadowTerms
{
	float	SurfaceShadow;
	float	TransmissionShadow;
	float	TransmissionThickness;
	FHairTransmittanceData HairTransmittance;
};
FDirectLighting HairBxDF(FGBufferData GBuffer, float3 N, float3 V, float3 L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow)
{
	const float3 BsdfValue = HairShading(GBuffer, L, V, N, Shadow.TransmissionShadow, Shadow.HairTransmittance, 1, 0, uint2(0, 0));
	FDirectLighting Lighting;
	Lighting.Diffuse = 0;
	Lighting.Specular = 0;
	Lighting.Transmission = AreaLight.FalloffColor * Falloff * BsdfValue;
	return Lighting;
}
float New_a2( float a2, float SinAlpha, float VoH )
{
	return a2 + 0.25 * SinAlpha * (3.0 * sqrtFast(a2) + SinAlpha) / ( VoH + 0.001 );
}
float EnergyNormalization( inout float a2, float VoH, FAreaLight AreaLight )
{
	if( AreaLight.SphereSinAlphaSoft > 0 )
	{
		a2 = saturate( a2 + Pow2( AreaLight.SphereSinAlphaSoft ) / ( VoH * 3.6 + 0.4 ) );
	}
	float Sphere_a2 = a2;
	float Energy = 1;
	if( AreaLight.SphereSinAlpha > 0 )
	{
		Sphere_a2 = New_a2( a2, AreaLight.SphereSinAlpha, VoH );
		Energy = a2 / Sphere_a2;
	}
	if( AreaLight.LineCosSubtended < 1 )
	{
		float LineCosTwoAlpha = AreaLight.LineCosSubtended;
		float LineTanAlpha = sqrt( ( 1.0001 - LineCosTwoAlpha ) / ( 1 + LineCosTwoAlpha ) );
		float Line_a2 = New_a2( Sphere_a2, LineTanAlpha, VoH );
		Energy *= sqrt( Sphere_a2 / Line_a2 );
	}
	return Energy;
}
float3 SpecularGGX(float Roughness, float Anisotropy, float3 SpecularColor, BxDFContext Context, float NoL, FAreaLight AreaLight)
{
	float Alpha = Roughness * Roughness;
	float a2 = Alpha * Alpha;
	FAreaLight Punctual = AreaLight;
	Punctual.SphereSinAlpha = 0;
	Punctual.SphereSinAlphaSoft = 0;
	Punctual.LineCosSubtended = 1;
	Punctual.Rect = (FRect)0;
	Punctual.IsRectAndDiffuseMicroReflWeight = 0;
	float Energy = EnergyNormalization(a2, Context.VoH, Punctual);
	float ax = 0;
	float ay = 0;
	GetAnisotropicRoughness(Alpha, Anisotropy, ax, ay);
	float3 D = D_GGXaniso(ax, ay, Context.NoH, Context.XoH, Context.YoH) * Energy;
	float3 Vis = Vis_SmithJointAniso(ax, ay, Context.NoV, NoL, Context.XoV, Context.XoL, Context.YoV, Context.YoL);
	float3 F = F_Schlick( SpecularColor, Context.VoH );
	return (D * Vis) * F;
}
float3 SpecularGGX( float Roughness, float3 SpecularColor, BxDFContext Context, float NoL, FAreaLight AreaLight )
{
	float a2 = Pow4( Roughness );
	float Energy = EnergyNormalization( a2, Context.VoH, AreaLight );
	float D = D_GGX( a2, Context.NoH ) * Energy;
	float Vis = Vis_SmithJointApprox( a2, Context.NoV, NoL );
	float3 F = F_Schlick( SpecularColor, Context.VoH );
	return (D * Vis) * F;
}
float3 DualSpecularGGX(float AverageRoughness, float Lobe0Roughness, float Lobe1Roughness, float LobeMix, float3 SpecularColor, BxDFContext Context, float NoL, FAreaLight AreaLight)
{
	float AverageAlpha2 = Pow4(AverageRoughness);
	float Lobe0Alpha2 = Pow4(Lobe0Roughness);
	float Lobe1Alpha2 = Pow4(Lobe1Roughness);
	float Lobe0Energy = EnergyNormalization(Lobe0Alpha2, Context.VoH, AreaLight);
	float Lobe1Energy = EnergyNormalization(Lobe1Alpha2, Context.VoH, AreaLight);
	float D = lerp(D_GGX(Lobe0Alpha2, Context.NoH) * Lobe0Energy, D_GGX(Lobe1Alpha2, Context.NoH) * Lobe1Energy, LobeMix);
	float Vis = Vis_SmithJointApprox(AverageAlpha2, Context.NoV, NoL); 
	float3 F = F_Schlick(SpecularColor, Context.VoH);
	return (D * Vis) * F;
}
FDirectLighting DefaultLitBxDF( FGBufferData GBuffer, float3 N, float3 V, float3 L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	BxDFContext Context;
	FDirectLighting Lighting;
	bool bHasAnisotropy = false;
	float NoV, VoH, NoH;
	[branch]
	if (bHasAnisotropy)
	{
		float3 X = GBuffer.WorldTangent;
		float3 Y = normalize(cross(N, X));
		Init(Context, N, X, Y, V, L);
		NoV = Context.NoV;
		VoH = Context.VoH;
		NoH = Context.NoH;
	}
	else
	{
		Init(Context, N, V, L);
		NoV = Context.NoV;
		VoH = Context.VoH;
		NoH = Context.NoH;
		SphereMaxNoH(Context, AreaLight.SphereSinAlpha, true);
	}
	Context.NoV = saturate(abs( Context.NoV ) + 1e-5);
	Lighting.Diffuse = Diffuse_Lambert(GBuffer.DiffuseColor);
	Lighting.Diffuse *= AreaLight.FalloffColor * (Falloff * NoL);
	[branch]
	if (bHasAnisotropy)
	{
		Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * SpecularGGX(GBuffer.Roughness, GBuffer.Anisotropy, GBuffer.SpecularColor, Context, NoL, AreaLight);
	}
	else
	{
		if( IsRectLight(AreaLight) )
		{
			Lighting.Specular = RectGGXApproxLTC(GBuffer.Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture);
		}
		else
		{
			Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * SpecularGGX(GBuffer.Roughness, GBuffer.SpecularColor, Context, NoL, AreaLight);
		}
	}
	FBxDFEnergyTermsRGB EnergyTerms = ComputeGGXSpecEnergyTermsRGB(GBuffer.Roughness, Context.NoV, GBuffer.SpecularColor);
	Lighting.Diffuse *= ComputeEnergyPreservation(EnergyTerms);
	Lighting.Specular *= ComputeEnergyConservation(EnergyTerms);
	Lighting.Transmission = 0;
	return Lighting;
}
float RefractBlendClearCoatApprox(float VoH)
{
	return (0.63 - 0.22 * VoH) * VoH - 0.745;
}
BxDFContext RefractClearCoatContext(BxDFContext Context)
{
	BxDFContext RefractedContext = Context;
	float Eta = 1.0 / 1.5;
	float RefractionBlendFactor = RefractBlendClearCoatApprox(Context.VoH);
	float RefractionProjectionTerm = RefractionBlendFactor * Context.NoH;
	RefractedContext.NoV = clamp(Eta * Context.NoV - RefractionProjectionTerm, 0.001, 1.0); 
	RefractedContext.NoL = clamp(Eta * Context.NoL - RefractionProjectionTerm, 0.001, 1.0); 
	RefractedContext.VoH = saturate(Eta * Context.VoH - RefractionBlendFactor);
	RefractedContext.VoL = 2.0 * RefractedContext.VoH * RefractedContext.VoH - 1.0;
	RefractedContext.NoH = Context.NoH;
	return RefractedContext;
}
FDirectLighting ClearCoatBxDF( FGBufferData GBuffer, float3 N, float3 V, float3 L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	const float ClearCoat			= GBuffer.CustomData.x;
	const float ClearCoatRoughness	= max(GBuffer.CustomData.y, 0.02f);
	FDirectLighting Lighting = {
		float3(0.0, 0.0, 0.0),
		float3(0.0, 0.0, 0.0),
		float3(0.0, 0.0, 0.0)
	};
	BxDFContext Context;
	float3 Nspec = N;
	if (0)
	{
		Nspec = GBuffer.WorldNormal;
	}
	bool bHasAnisotropy = false;
	float3 X = 0;
	float3 Y = 0;
	Init(Context, Nspec, V, L);
	float SphereSinAlpha = AreaLight.SphereSinAlpha;
	float RoughnessCompensation = 1 - Pow2(GBuffer.Roughness);
	float Alpha = ClearCoatRoughness * ClearCoatRoughness;
	RoughnessCompensation = RoughnessCompensation > 0.0 ? (1 - Alpha) / RoughnessCompensation : 0.0;
	AreaLight.SphereSinAlpha = saturate(AreaLight.SphereSinAlpha * RoughnessCompensation);
	SphereMaxNoH(Context, AreaLight.SphereSinAlpha, 0 == 0);
	Context.NoV = saturate(abs(Context.NoV) + 1e-5);
	const bool bIsRect = IsRectLight(AreaLight);
	Context.VoH = bIsRect ? Context.NoV : Context.VoH;
	float F0 = 0.04;
	float Fc = Pow5(1 - Context.VoH);
	float F = Fc + (1 - Fc) * F0;
	FBxDFEnergyTermsRGB EnergyTermsCoat   = ComputeGGXSpecEnergyTermsRGB(ClearCoatRoughness, Context.NoV, F0);
	if (bIsRect)
	{
		Lighting.Specular = ClearCoat * RectGGXApproxLTC(ClearCoatRoughness, F0, Nspec, V, AreaLight.Rect, AreaLight.Texture);
	}
	else
	{
		float a2 = Pow2(Alpha);
		float ClearCoatEnergy = EnergyNormalization(a2, Context.VoH, AreaLight);
		float Vis = Vis_SmithJointApprox(a2, Context.NoV, NoL);
		float D = D_GGX(a2, Context.NoH) * ClearCoatEnergy;
		float Fr1 = (D * Vis) * F;
		Lighting.Specular = ClearCoat * AreaLight.FalloffColor * (Falloff * NoL * Fr1);
	}
	Lighting.Specular *= ComputeEnergyConservation(EnergyTermsCoat);
	AreaLight.SphereSinAlpha = SphereSinAlpha;
	Alpha = Pow2(GBuffer.Roughness);
	float FresnelCoeff = 1.0 - F;
	FresnelCoeff *= FresnelCoeff;
	if (0)
	{
		BxDFContext TempContext;
		[branch]
		if (bHasAnisotropy)
		{
			Init(TempContext, N, X, Y, V, L);
		}
		else
		{
			Init(TempContext, Nspec, V, L);
		}
		float3 H = normalize(V + L);
		Context.NoH = saturate(dot(N, H));
		Context.NoV = saturate(dot(N, V));
		Context.NoL = saturate(dot(N, L));
		Context.VoL = saturate(dot(V, L));
		Context.VoH = saturate(dot(V, H));
		Context.XoV = TempContext.XoV;
		Context.XoL = TempContext.XoL;
		Context.XoH = TempContext.XoH;
		Context.YoV = TempContext.YoV;
		Context.YoL = TempContext.YoL;
		Context.YoH = TempContext.YoH;
		if (!bHasAnisotropy)
		{
			bool bNewtonIteration = true;
			SphereMaxNoH(Context, AreaLight.SphereSinAlpha, bNewtonIteration);
		}
		Context.NoV = saturate(abs(Context.NoV) + 1e-5);
	}
	if (bHasAnisotropy)
	{
		X = GBuffer.WorldTangent;
		Y = normalize(cross(N, X));
		Init(Context, Nspec, X, Y, V, L);
	}
	BxDFContext BottomContext = RefractClearCoatContext(Context);
	BottomContext.VoH = bIsRect ? BottomContext.NoV : BottomContext.VoH;
	FBxDFEnergyTermsRGB EnergyTermsBottom = ComputeGGXSpecEnergyTermsRGB(GBuffer.Roughness, BottomContext.NoV, GBuffer.SpecularColor);
	float3 Transmission = SimpleClearCoatTransmittance(BottomContext.NoL, BottomContext.NoV, GBuffer.Metallic, GBuffer.BaseColor);
	float3 DefaultDiffuse = (Falloff * NoL) * AreaLight.FalloffColor * Diffuse_Lambert(GBuffer.DiffuseColor) * ComputeEnergyPreservation(EnergyTermsBottom);
	float3 RefractedDiffuse = FresnelCoeff * Transmission * DefaultDiffuse;
	Lighting.Diffuse = lerp(DefaultDiffuse, RefractedDiffuse, ClearCoat);
	if (!bHasAnisotropy && bIsRect)
	{
		float3 DefaultSpecular = RectGGXApproxLTC(GBuffer.Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture);
		float3 RefractedSpecular = FresnelCoeff * Transmission * DefaultSpecular;
		Lighting.Specular += lerp(DefaultSpecular, RefractedSpecular, ClearCoat);
	}
	else
	{
		float a2 = Pow4(GBuffer.Roughness);
		float D2 = 0;
		float Vis2 = 0;
		[branch]
		if (bHasAnisotropy)
		{
			float ax = 0;
			float ay = 0;
			GetAnisotropicRoughness(Alpha, GBuffer.Anisotropy, ax, ay); 
			D2 = D_GGXaniso(ax, ay, Context.NoH, Context.XoH, Context.YoH);
			Vis2 = Vis_SmithJointAniso(ax, ay, BottomContext.NoV, BottomContext.NoL, BottomContext.XoV, BottomContext.XoL, BottomContext.YoV, BottomContext.YoL);
		}
		else
		{
			Vis2 = Vis_SmithJointApprox(a2, BottomContext.NoV, NoL);
			D2 = D_GGX(a2, BottomContext.NoH);
		}
		float3 F_Bot = F_Schlick(GBuffer.SpecularColor, BottomContext.VoH);
		float3 F_DefaultLit = F_Schlick(GBuffer.SpecularColor, Context.VoH);
		float Energy = 0;
		[branch]
		if (bHasAnisotropy)
		{
			FAreaLight Punctual = AreaLight;
			Punctual.SphereSinAlpha = 0;
			Punctual.SphereSinAlphaSoft = 0;
			Punctual.LineCosSubtended = 1;
			Punctual.Rect = (FRect)0;
			Punctual.IsRectAndDiffuseMicroReflWeight = 0;
			Energy = EnergyNormalization(a2, Context.VoH, Punctual);
		}
		else
		{
			Energy = EnergyNormalization(a2, Context.VoH, AreaLight);
		}
		float3 CommonSpecular = (Energy * Falloff * NoL * D2 * Vis2) * AreaLight.FalloffColor;
		float3 DefaultSpecular = F_DefaultLit;
		float3 RefractedSpecular = FresnelCoeff * Transmission * F_Bot;
		Lighting.Specular += CommonSpecular * lerp(DefaultSpecular, RefractedSpecular, ClearCoat);
	}
	return Lighting;
}
void GetProfileDualSpecular(uint SubsurfaceProfileInt, float Roughness, float Opacity, out float LobeRoughness0, out float LobeRoughness1, out float LobeMix)
{
	GetSubsurfaceProfileDualSpecular(SubsurfaceProfileInt, Roughness, Opacity, LobeRoughness0, LobeRoughness1, LobeMix);
}
FDirectLighting SubsurfaceProfileBxDF( FGBufferData GBuffer, float3 N, float3 V, float3 L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	BxDFContext Context;
	Init( Context, N, V, L );
	SphereMaxNoH( Context, AreaLight.SphereSinAlpha, true );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );
	uint SubsurfaceProfileId = ExtractSubsurfaceProfileInt(GBuffer);
	float Opacity = GBuffer.CustomData.a;
	float Roughness = GBuffer.Roughness;
	float Lobe0Roughness = 0;
	float Lobe1Roughness = 0;
	float LobeMix = 0;
	GetProfileDualSpecular(SubsurfaceProfileId, Roughness, Opacity, Lobe0Roughness, Lobe1Roughness, LobeMix);
	float AverageRoughness = lerp(Lobe0Roughness, Lobe1Roughness, LobeMix);
	const FBxDFEnergyTermsRGB EnergyTerms = ComputeGGXSpecEnergyTermsRGB(AverageRoughness, Context.NoV, GBuffer.SpecularColor);
	FDirectLighting Lighting;
	const float3 DiffuseReflection = Diffuse_Burley(GBuffer.DiffuseColor, GBuffer.Roughness, Context.NoV, NoL, Context.VoH);
	Lighting.Diffuse  = AreaLight.FalloffColor * (Falloff * NoL) * DiffuseReflection;
	if (IsRectLight(AreaLight))
	{
		float3 Lobe0Specular = RectGGXApproxLTC(Lobe0Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture);
		float3 Lobe1Specular = RectGGXApproxLTC(Lobe1Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture);
		Lighting.Specular = lerp(Lobe0Specular, Lobe1Specular, LobeMix);
	}
	else
	{
		Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * DualSpecularGGX(AverageRoughness, Lobe0Roughness, Lobe1Roughness, LobeMix, GBuffer.SpecularColor, Context, NoL, AreaLight);
	}
	Lighting.Diffuse  *= ComputeEnergyPreservation(EnergyTerms);
	Lighting.Specular *= ComputeEnergyConservation(EnergyTerms);
	Lighting.Transmission = 0;
	return Lighting;
}
FDirectLighting ClothBxDF( FGBufferData GBuffer, float3 N, float3 V, float3 L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	const float3 FuzzColor	= ExtractSubsurfaceColor(GBuffer);
	const float  Cloth		= saturate(GBuffer.CustomData.a);
	BxDFContext Context;
	Init( Context, N, V, L );
	SphereMaxNoH( Context, AreaLight.SphereSinAlpha, true );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );
	float3 Spec1;
	if(IsRectLight(AreaLight))
		Spec1 = RectGGXApproxLTC( GBuffer.Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture );
	else
		Spec1 = AreaLight.FalloffColor * (Falloff * NoL) * SpecularGGX( GBuffer.Roughness, GBuffer.SpecularColor, Context, NoL, AreaLight );
	const FBxDFEnergyTermsRGB EnergyTerms1 = ComputeGGXSpecEnergyTermsRGB(GBuffer.Roughness, Context.NoV, GBuffer.SpecularColor);
	Spec1 *= ComputeEnergyConservation(EnergyTerms1);
	float D2 = D_InvGGX( Pow4( GBuffer.Roughness ), Context.NoH );
	float Vis2 = Vis_Cloth( Context.NoV, NoL );
	float3 F2 = F_Schlick( FuzzColor, Context.VoH );
	float3 Spec2 = AreaLight.FalloffColor * (Falloff * NoL) * (D2 * Vis2) * F2;
	const FBxDFEnergyTermsA EnergyTerms2 = ComputeClothEnergyTermsA(GBuffer.Roughness, Context.NoV);
	Spec2 *= ComputeEnergyConservation(EnergyTerms2);
	FDirectLighting Lighting;
	Lighting.Diffuse  = AreaLight.FalloffColor * (Falloff * NoL) * Diffuse_Lambert( GBuffer.DiffuseColor ); 
	Lighting.Specular = lerp( Spec1, Spec2, Cloth );
	Lighting.Transmission = 0;
	Lighting.Diffuse *= lerp(ComputeEnergyPreservation(EnergyTerms1), ComputeEnergyPreservation(EnergyTerms2), Cloth);
	return Lighting;
}
FDirectLighting SubsurfaceBxDF(FGBufferData GBuffer, float3 N, float3 V, float3 L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	FDirectLighting Lighting = DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow);
	float3 SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);
	float Opacity = GBuffer.CustomData.a;
	float InScatter = pow(saturate(dot(L, -V)), 12) * lerp(3, .1f, Opacity);
	const float WrappedDiffuse = pow(saturate(dot(N, L) * (1.f / 1.5f) + (0.5f / 1.5f)), 1.5f) * (2.5f / 1.5f);
	const float NormalContribution = lerp(1.f, WrappedDiffuse, Opacity);
	const float BackScatter = GBuffer.GBufferAO * NormalContribution / (PI * 2);
	const float3 ExtinctionCoefficients = TransmittanceToExtinction(SubsurfaceColor, View.SubSurfaceColorAsTransmittanceAtDistanceInMeters);
	const float3 RawTransmittedColor = ExtinctionToTransmittance(ExtinctionCoefficients, 1.0f );
	const float3 TransmittedColor = HSV_2_LinearRGB(float3(LinearRGB_2_HSV(RawTransmittedColor).xy, LinearRGB_2_HSV(SubsurfaceColor).z));
	Lighting.Transmission = AreaLight.FalloffColor * (Falloff * lerp(BackScatter, 1, InScatter)) * lerp(TransmittedColor, SubsurfaceColor, Shadow.TransmissionThickness);
	return Lighting;
}
FDirectLighting TwoSidedBxDF( FGBufferData GBuffer, float3 N, float3 V, float3 L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	FDirectLighting Lighting = DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
	float3 SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);
	float Wrap = 0.5;
	float WrapNoL = saturate( ( -dot(N, L) + Wrap ) / Square( 1 + Wrap ) );
	float VoL = dot(V, L);
	float Scatter = D_GGX( 0.6*0.6, saturate( -VoL ) );
	Lighting.Transmission = AreaLight.FalloffColor * (Falloff * WrapNoL * Scatter) * SubsurfaceColor;
	return Lighting;
}
FDirectLighting EyeBxDF( FGBufferData GBuffer, float3 N, float3 V, float3 L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	const float3 IrisNormal		= OctahedronToUnitVector( GBuffer.CustomData.yz * 2 - 1 );
	const float  IrisDistance	= GBuffer.StoredMetallic;
	const float  IrisMask		= 1.0f - GBuffer.CustomData.w;
	const float3 CausticNormal = normalize(lerp(IrisNormal, -N, IrisMask*IrisDistance));
	BxDFContext Context;
	Init( Context, N, V, L );
	SphereMaxNoH( Context, AreaLight.SphereSinAlpha, false );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );
	const bool bIsRect = IsRectLight(AreaLight);
	Context.VoH = bIsRect ? Context.NoV : Context.VoH;
	float F0 = GBuffer.Specular * 0.08;
	float Fc = Pow5( 1 - Context.VoH );
	float F = Fc + (1 - Fc) * F0;
	const FBxDFEnergyTermsRGB EnergyTerms = ComputeGGXSpecEnergyTermsRGB(GBuffer.Roughness, Context.NoV, F0);
	FDirectLighting Lighting;
	if( bIsRect )
	{
		Lighting.Specular = RectGGXApproxLTC( GBuffer.Roughness, F0, N, V, AreaLight.Rect, AreaLight.Texture );
	}
	else
	{
		float a2 = Pow4( GBuffer.Roughness );
		float Energy = EnergyNormalization( a2, Context.VoH, AreaLight );
		float Vis = Vis_SmithJointApprox(a2, Context.NoV, NoL);
		float D = D_GGX(a2, Context.NoH) * Energy;
		Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * D * Vis * F;
	}
	float IrisNoL = saturate( dot( IrisNormal, L ) );
	float Power = lerp( 12, 1, IrisNoL );
	float Caustic = 0.8 + 0.2 * ( Power + 1 ) * pow( saturate( dot( CausticNormal, L ) ), Power );
	float Iris = IrisNoL * Caustic;
	float Sclera = NoL;
	Lighting.Specular *= ComputeEnergyConservation(EnergyTerms);
	const float EnergyPreservation = 1.0f - F;
	Lighting.Diffuse = 0;
	Lighting.Transmission = AreaLight.FalloffColor * ( Falloff * lerp( Sclera, Iris, IrisMask ) * EnergyPreservation ) * Diffuse_Lambert( GBuffer.DiffuseColor );
	return Lighting;
}
FDirectLighting PreintegratedSkinBxDF( FGBufferData GBuffer, float3 N, float3 V, float3 L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	FDirectLighting Lighting = DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
	float3 SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);
	float Opacity = GBuffer.CustomData.a;
	float3 PreintegratedBRDF = Texture2DSampleLevel(View_PreIntegratedBRDF, View_PreIntegratedBRDFSampler, float2(saturate(dot(N, L) * .5 + .5), 1 - Opacity), 0).rgb;
	Lighting.Transmission = AreaLight.FalloffColor * Falloff * PreintegratedBRDF * SubsurfaceColor;
	return Lighting;
}
FDirectLighting IntegrateBxDF( FGBufferData GBuffer, float3 N, float3 V, float3 L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	switch( GBuffer.ShadingModelID )
	{
		case 1:
		case 10:
		case 11:
			return DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case 2:
			return SubsurfaceBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case 3:
			return PreintegratedSkinBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case 4:
			return ClearCoatBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case 5:
			return SubsurfaceProfileBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case 6:
			return TwoSidedBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case 7:
			return HairBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case 8:
			return ClothBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case 9:
			return EyeBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		default:
			return (FDirectLighting)0;
	}
}
FDirectLighting EvaluateBxDF( FGBufferData GBuffer, float3 N, float3 V, float3 L, float NoL, FShadowTerms Shadow )
{
	FAreaLight AreaLight;
	AreaLight.SphereSinAlpha = 0;
	AreaLight.SphereSinAlphaSoft = 0;
	AreaLight.LineCosSubtended = 1;
	AreaLight.FalloffColor = 1;
	AreaLight.Rect = (FRect)0;
	AreaLight.IsRectAndDiffuseMicroReflWeight = 0;
	AreaLight.Texture = InitRectTexture();
	return IntegrateBxDF( GBuffer, N, V, L, 1, NoL, AreaLight, Shadow );
}
float GetStepScreenFactorToClipAtScreenEdge(float2 RayStartScreen, float2 RayStepScreen)
{
	const float RayStepScreenInvFactor = 0.5 * length(RayStepScreen);
	const float2 S = 1 - max(abs(RayStepScreen + RayStartScreen * RayStepScreenInvFactor) - RayStepScreenInvFactor, 0.0f) / abs(RayStepScreen);
	const float RayStepFactor = min(S.x, S.y) / RayStepScreenInvFactor;
	return RayStepFactor;
}
struct FSSRTRay
{
	float3 RayStartScreen;
	float3 RayStepScreen;
	float CompareTolerance;
};
FSSRTRay InitScreenSpaceRayFromWorldSpace(
	float3 RayOriginTranslatedWorld,
	float3 WorldRayDirection,
	float WorldTMax,
	float SceneDepth,
	float SlopeCompareToleranceScale,
	const bool bExtendRayToScreenBorder,
	out bool bRayWasClipped)
{
	WorldTMax = min(WorldTMax, 1000000);
	float3 ViewRayDirection = mul(float4(WorldRayDirection, 0.0), View.TranslatedWorldToView).xyz;
	float RayEndWorldDistance = ViewRayDirection.z < 0.0 ? min(-0.95 * SceneDepth / ViewRayDirection.z, WorldTMax) : WorldTMax;
	float3 RayEndWorld = RayOriginTranslatedWorld + WorldRayDirection * RayEndWorldDistance;
	float4 RayStartClip = mul(float4(RayOriginTranslatedWorld, 1.0), View.TranslatedWorldToClip);
	float4 RayEndClip = mul(float4(RayEndWorld, 1.0), View.TranslatedWorldToClip);
	float3 RayStartScreen = RayStartClip.xyz * rcp(RayStartClip.w);
	float3 RayEndScreen = RayEndClip.xyz * rcp(RayEndClip.w);
	float4 RayDepthClip = RayStartClip + mul(float4(0, 0, RayEndWorldDistance, 0), View.ViewToClip);
	float3 RayDepthScreen = RayDepthClip.xyz * rcp(RayDepthClip.w);
	FSSRTRay Ray;
	Ray.RayStartScreen = RayStartScreen;
	Ray.RayStepScreen = RayEndScreen - RayStartScreen;
	float ClipToScreenFactor = GetStepScreenFactorToClipAtScreenEdge(RayStartScreen.xy, Ray.RayStepScreen.xy);
	if (!bExtendRayToScreenBorder)
	{
		bRayWasClipped = ClipToScreenFactor < 1.0 || RayEndWorldDistance != WorldTMax;
		ClipToScreenFactor = min(ClipToScreenFactor, 1.0);
	}
	else
	{
		bRayWasClipped = true;
	}
	Ray.RayStepScreen *= ClipToScreenFactor;
	if (IsOrthoProjection())
	{
		Ray.CompareTolerance = max(0, (RayStartScreen.z - RayDepthScreen.z) * SlopeCompareToleranceScale);
	}
	else
	{
		Ray.CompareTolerance = max(abs(Ray.RayStepScreen.z), (RayStartScreen.z - RayDepthScreen.z) * SlopeCompareToleranceScale);
	}
	return Ray;
}
struct FSSRTTileInfos
{
	float Directionality[8];
	float ClosestDeviceZ;
	uint2 Coord;
	float _Padding[5];
};
struct FSSRTCastingSettings
{
	bool bStopWhenUncertain;
	bool bUseTileInfo;
	FSSRTTileInfos TileInfos;
};
FSSRTCastingSettings CreateDefaultCastSettings()
{
	FSSRTCastingSettings Settings;
	Settings.bUseTileInfo = false;
	Settings.bStopWhenUncertain = false;
	Settings.TileInfos = (FSSRTTileInfos)0;
	return Settings;
}
uint ComputeRayDirectionId(FSSRTRay Ray)
{
	float2 RayStepPixel = Ray.RayStepScreen.xy * View.ViewSizeAndInvSize.xy;
	RayStepPixel.y = -RayStepPixel.y;
	float RayDirection = atan2(-RayStepPixel.y, -RayStepPixel.x) + PI;
	uint DirectionId;
	[flatten]
	if (RayDirection < (0.5 * 2 * PI / 8) || RayDirection >(7.5 * 2 * PI / 8))
	{
		DirectionId = 0;
	}
	else if (RayDirection < (1.5 * 2 * PI / 8))
	{
		DirectionId = 1;
	}
	else if (RayDirection < (2.5 * 2 * PI / 8))
	{
		DirectionId = 2;
	}
	else if (RayDirection < (3.5 * 2 * PI / 8))
	{
		DirectionId = 3;
	}
	else if (RayDirection < (4.5 * 2 * PI / 8))
	{
		DirectionId = 4;
	}
	else if (RayDirection < (5.5 * 2 * PI / 8))
	{
		DirectionId = 5;
	}
	else if (RayDirection < (6.5 * 2 * PI / 8))
	{
		DirectionId = 6;
	}
	else
	{
		DirectionId = 7;
	}
	return DirectionId;
}
void CastScreenSpaceRay(
	Texture2D Texture, SamplerState Sampler,
	float StartMipLevel,
	FSSRTCastingSettings CastSettings,
	FSSRTRay Ray,
	float Roughness,
	uint NumSteps, float StepOffset,
	float4 HZBUvFactorAndInvFactor, 
	bool bDebugPrint,
	out float3 DebugOutput,
	out float3 OutHitUVz,
	out float Level,
	out bool bFoundHit,
	out bool bUncertain)
{
	DebugOutput = 0;
	const float3 RayStartScreen = Ray.RayStartScreen;
	const float3 RayStepScreen = Ray.RayStepScreen;
	float3 RayStartUVz = float3( (RayStartScreen.xy * float2( 0.5, -0.5 ) + 0.5) * HZBUvFactorAndInvFactor.xy, RayStartScreen.z );
	float3 RayStepUVz  = float3(  RayStepScreen.xy  * float2( 0.5, -0.5 )		 * HZBUvFactorAndInvFactor.xy, RayStepScreen.z );
	const float Step = 1.0 / NumSteps;
	float CompareTolerance = Ray.CompareTolerance * Step;
	float LastDiff = 0;
	Level = StartMipLevel;
	RayStepUVz *= Step;
	float3 RayUVz = RayStartUVz + RayStepUVz * StepOffset;
	float4 MultipleSampleDepthDiff;
	bool4 bMultipleSampleHit; 
	uint MaxIteration = NumSteps;
	if (CastSettings.bUseTileInfo)
	{
		uint DirectionId = ComputeRayDirectionId(Ray);
		float DirectionAndle = float(DirectionId) * (2 * PI * rcp(float(8)));
		float2 RayPixelDirection = float2(cos(DirectionAndle), sin(DirectionAndle));
		float2 cr = ScreenPosToViewportUV(RayStartScreen.xy) * View.ViewSizeAndInvSize.xy;
		float2 cre = ScreenPosToViewportUV(RayStartScreen.xy + RayStepScreen.xy) * View.ViewSizeAndInvSize.xy;
		float xr = dot(cr, RayPixelDirection) * View.ViewSizeAndInvSize.z;
		float xre = dot(cre, RayPixelDirection) * View.ViewSizeAndInvSize.z;
		float dr = RayStartScreen.z;
		float ar = RayStepScreen.z * View.ViewSizeAndInvSize.x / dot(RayStepScreen.xy * float2(0.5, -0.5) * View.ViewSizeAndInvSize.xy, RayPixelDirection);
		float2 cc = CastSettings.TileInfos.Coord * 8 + 8 / 2;
		float2 c0 = cc - sign(RayPixelDirection) * float(8 / 2);
		float2 c1 = cc + sign(RayPixelDirection) * float(8 / 2);
		float x0 = dot(c0, RayPixelDirection) * View.ViewSizeAndInvSize.z;
		float x1 = dot(c1, RayPixelDirection) * View.ViewSizeAndInvSize.z;
		float af = CastSettings.TileInfos.Directionality[DirectionId];
		float df = CastSettings.TileInfos.ClosestDeviceZ;
		float xf = af > 0.0 ? x0 : x1;
		uint UsefulMaxIteration;
		{
			float adiff = ar - af;
			[flatten]
			if (ar > af)
			{
				float x = (df - dr + xr * ar - xf * af) / adiff;
				float UseFulPercent = saturate((x - xr) / (xre - xr));
				UsefulMaxIteration = clamp(uint(NumSteps * UseFulPercent), 0, NumSteps);
			}
			else
			{
				UsefulMaxIteration = NumSteps;
			}
		}
			MaxIteration = UsefulMaxIteration;
		DebugOutput.x = float(MaxIteration) / float(NumSteps);
	}
	uint i;
	bFoundHit = false;
	bUncertain = false;
	[loop]
	for (i = 0; i < MaxIteration; i += 4)
	{
		float2 SamplesUV[4];
		float4 SamplesZ;
		float4 SamplesMip;
		{
			 [unroll( 4 )]
			for (uint j = 0; j < 4; j++)
			{
				SamplesUV[j] = RayUVz.xy + (float(i) + float(j + 1)) * RayStepUVz.xy;
				SamplesZ[j] = RayUVz.z + (float(i) + float(j + 1)) * RayStepUVz.z;
			}
			SamplesMip.xy = Level;
			Level += (8.0 / NumSteps) * Roughness;
			SamplesMip.zw = Level;
			Level += (8.0 / NumSteps) * Roughness;
		}
		float4 SampleDepth;
		{
			 [unroll( 4 )]
			for (uint j = 0; j < 4; j++)
			{
				SampleDepth[j] = Texture.SampleLevel(Sampler, SamplesUV[j], SamplesMip[j]).r;
			}
		}
		MultipleSampleDepthDiff = SamplesZ - SampleDepth;
		bMultipleSampleHit = abs(MultipleSampleDepthDiff + CompareTolerance) < CompareTolerance;
		{
			bool4 bMultipleSampleUncertain = (MultipleSampleDepthDiff + CompareTolerance) < -CompareTolerance;
			 [unroll( 4 )]
			for (uint j = 0; j < 4; j++)
			{
				bFoundHit = bFoundHit || bMultipleSampleHit[j];
				bool bLocalMultisampleUncertain = bMultipleSampleUncertain[i];
				bUncertain = bUncertain || (bLocalMultisampleUncertain && !bFoundHit);
			}
		}
		[branch]
		if (bFoundHit || (CastSettings.bStopWhenUncertain && bUncertain))
		{
			break;
		}
		LastDiff = MultipleSampleDepthDiff.w;
	} 
	[branch]
	if (bFoundHit)
    {
        {
            float DepthDiff0 = MultipleSampleDepthDiff[2];
            float DepthDiff1 = MultipleSampleDepthDiff[3];
            float Time0 = 3;
            [flatten]
            if (bMultipleSampleHit[2])
            {
                DepthDiff0 = MultipleSampleDepthDiff[1];
                DepthDiff1 = MultipleSampleDepthDiff[2];
                Time0 = 2;
            }
            [flatten]
            if (bMultipleSampleHit[1])
            {
                DepthDiff0 = MultipleSampleDepthDiff[0];
                DepthDiff1 = MultipleSampleDepthDiff[1];
                Time0 = 1;
            }
            [flatten]
            if (bMultipleSampleHit[0])
            {
                DepthDiff0 = LastDiff;
                DepthDiff1 = MultipleSampleDepthDiff[0];
                Time0 = 0;
            }
			Time0 += float(i);
            float Time1 = Time0 + 1;
            float TimeLerp = saturate(DepthDiff0 / (DepthDiff0 - DepthDiff1));
            float IntersectTime = Time0 + TimeLerp;
            OutHitUVz = RayUVz + RayStepUVz * IntersectTime;
        }
    }
	else
    {
        OutHitUVz = RayUVz + RayStepUVz * i;
    }
	OutHitUVz.xy *= HZBUvFactorAndInvFactor.zw;
	OutHitUVz.xy = OutHitUVz.xy * float2( 2, -2 ) + float2( -1, 1 );
	OutHitUVz.xy = OutHitUVz.xy * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;
}
bool RayCast(
	Texture2D Texture, SamplerState Sampler,
	float3 RayOriginTranslatedWorld, float3 RayDirection,
	float Roughness, float SceneDepth,
	uint NumSteps, float StepOffset,
	float4 HZBUvFactorAndInvFactor, 
	bool bDebugPrint,
	out float3 OutHitUVz,
	out float Level)
{
		float SlopeCompareToleranceScale = 4.0f;
	bool bRayWasClipped;
	FSSRTRay Ray = InitScreenSpaceRayFromWorldSpace(
		RayOriginTranslatedWorld, RayDirection,
		 SceneDepth,
		 SceneDepth,
		 SlopeCompareToleranceScale,
		 true,
		 bRayWasClipped);
	bool bHit;
	bool bUncertain;
	float3 DebugOutput;
	CastScreenSpaceRay(
		Texture, Sampler,
		 1.0,
		CreateDefaultCastSettings(),
		Ray,
		Roughness, NumSteps, StepOffset,
		HZBUvFactorAndInvFactor, bDebugPrint,
		 DebugOutput,
		 OutHitUVz,
		 Level,
		 bHit,
		 bUncertain);
	return bHit;
}
float ComputeHitVignetteFromScreenPos(float2 ScreenPos)
{
	float2 Vignette = saturate(abs(ScreenPos) * 5 - 4);
	return SafeSaturate(1.0 - dot(Vignette, Vignette));
}
void ReprojectHit(float4 PrevScreenPositionScaleBias, float3 HitUVz, out float2 OutPrevUV, out float OutVignette)
{
	float2 ThisScreen = (HitUVz.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
	float4 ThisClip = float4( ThisScreen, HitUVz.z, 1 );
	float4 PrevClip = mul( ThisClip, View.ClipToPrevClip );
	float2 PrevScreen = PrevClip.xy / PrevClip.w;
	float2 PrevUV = PrevScreen.xy * PrevScreenPositionScaleBias.xy + PrevScreenPositionScaleBias.zw;
	OutVignette = min(ComputeHitVignetteFromScreenPos(ThisScreen), ComputeHitVignetteFromScreenPos(PrevScreen));
	OutPrevUV = PrevUV;
}
void ReprojectHit(float4 PrevScreenPositionScaleBias, Texture2D Texture, SamplerState Sampler, float3 HitUVz, out float2 OutPrevUV, out float OutVignette)
{
	float2 ThisScreen = (HitUVz.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
	float4 ThisClip = float4( ThisScreen, HitUVz.z, 1 );
	float4 PrevClip = mul( ThisClip, View.ClipToPrevClip );
	float2 PrevScreen = PrevClip.xy / PrevClip.w;
	float4 EncodedVelocity = Texture.SampleLevel(Sampler, HitUVz.xy, 0);
	if( EncodedVelocity.x > 0.0 )
	{
		PrevScreen = ThisClip.xy - DecodeVelocityFromTexture(EncodedVelocity).xy;
	}
	float2 PrevUV = PrevScreen.xy * PrevScreenPositionScaleBias.xy + PrevScreenPositionScaleBias.zw;
	OutVignette = min(ComputeHitVignetteFromScreenPos(ThisScreen), ComputeHitVignetteFromScreenPos(PrevScreen));
	OutPrevUV = PrevUV;
}
float4 SampleScreenColor(Texture2D Texture, SamplerState Sampler, float2 UV)
{
	float4 OutColor;
	OutColor.rgb = Texture.SampleLevel( Sampler, UV, 0 ).rgb;
	OutColor.rgb = -min(-OutColor.rgb, 0.0);
	OutColor.a = 1;
	return OutColor;
}
float4 CombineVolumetricFog(float4 GlobalFog, float3 VolumeUV, uint EyeIndex, float SceneDepth)
{
	float4 VolumetricFogLookup = float4(0, 0, 0, 1);
	if (View.RenderingReflectionCaptureMask == 0.0f && ! (( View.EnvironmentComponentsFlags [0] & 0x20)  > 0))
	{
		return VolumetricFogLookup;
	}
	float VolFogStartDistance = 0.0f;
	if (TranslucentBasePass.Shared_Fog_ApplyVolumetricFog > 0)
	{
		VolFogStartDistance = TranslucentBasePass.Shared_Fog_VolumetricFogStartDistance;
		VolumetricFogLookup = Texture3DSampleLevel(TranslucentBasePass_Shared_Fog_IntegratedLightScattering, View_SharedBilinearClampedSampler, VolumeUV, 0);
		VolumetricFogLookup.rgb *= View.OneOverPreExposure;
	}
	VolumetricFogLookup = lerp(float4(0, 0, 0, 1), VolumetricFogLookup, saturate((SceneDepth - VolFogStartDistance) * 100000000.0f));
	return float4(VolumetricFogLookup.rgb + GlobalFog.rgb * VolumetricFogLookup.a, VolumetricFogLookup.a * GlobalFog.a);
}
float ComputeNormalizedZSliceFromDepth(float SceneDepth)
{
	return log2(SceneDepth * View.VolumetricFogGridZParams.x + View.VolumetricFogGridZParams.y) * View.VolumetricFogGridZParams.z * View.VolumetricFogInvGridSize.z;
}
float3 ComputeVolumeUVFromNDC(float4 NDCPosition)
{
	NDCPosition.xy /= NDCPosition.w;
	float3 VolumeUV = float3(NDCPosition.xy * float2(.5f, -.5f) + .5f, ComputeNormalizedZSliceFromDepth(NDCPosition.w));
	return min(VolumeUV * float3(View.VolumetricFogScreenToResourceUV.xy, 1.0), float3(View.VolumetricFogUVMax, 1.0));
}
float3 ComputeVolumeUV(FDFVector3 WorldPosition, FDFInverseMatrix WorldToClip)
{
	float4 NDCPosition = DFMultiplyDemote(MakeDFVector(WorldPosition, 1.0f), WorldToClip);
	return ComputeVolumeUVFromNDC(NDCPosition);
}
float GetSkyLightCubemapBrightness()
{
	return View_SkyIrradianceEnvironmentMap[7].x; 
}
float ComputeReflectionCaptureMipFromRoughness(float Roughness, float CubemapMaxMip)
{
	float LevelFrom1x1 = 1 - 1.2 * log2(max(Roughness, 0.001));
	return CubemapMaxMip - 1 - LevelFrom1x1;
}
float3 GetSkyLightReflection(float3 ReflectionVector, float Roughness, out float OutSkyAverageBrightness)
{
	float AbsoluteSpecularMip = ComputeReflectionCaptureMipFromRoughness(Roughness, TranslucentBasePass.Shared_Reflection_SkyLightParameters.x);
	float3 Reflection = TextureCubeSampleLevel(TranslucentBasePass_Shared_Reflection_SkyLightCubemap, TranslucentBasePass_Shared_Reflection_SkyLightCubemapSampler, ReflectionVector, AbsoluteSpecularMip).rgb;
	OutSkyAverageBrightness = GetSkyLightCubemapBrightness() * Luminance(View.SkyLightColor.rgb);
	return Reflection * View.SkyLightColor.rgb;
}
float3 GetSkySHDiffuse(float3 Normal)
{
	float4 NormalVector = float4(Normal, 1.0f); 
	float3 Intermediate0, Intermediate1, Intermediate2;
	Intermediate0.x = dot(View_SkyIrradianceEnvironmentMap[0], NormalVector);
	Intermediate0.y = dot(View_SkyIrradianceEnvironmentMap[1], NormalVector);
	Intermediate0.z = dot(View_SkyIrradianceEnvironmentMap[2], NormalVector);
	float4 vB = NormalVector.xyzz * NormalVector.yzzx;
	Intermediate1.x = dot(View_SkyIrradianceEnvironmentMap[3], vB);
	Intermediate1.y = dot(View_SkyIrradianceEnvironmentMap[4], vB);
	Intermediate1.z = dot(View_SkyIrradianceEnvironmentMap[5], vB);
	float vC = NormalVector.x * NormalVector.x - NormalVector.y * NormalVector.y;
	Intermediate2 = View_SkyIrradianceEnvironmentMap[6].xyz * vC;
	return max(0, Intermediate0 + Intermediate1 + Intermediate2);
}
float3 GetLookupVectorForBoxCapture(float3 ReflectionVector, float3 WorldPosition, float4 BoxCapturePositionAndRadius, float4x4 RelativeWorldToBox, float4 BoxScales, float3 LocalCaptureOffset, out float DistanceAlpha)
{
	float3 LocalRayStart		= mul(float4(WorldPosition - BoxCapturePositionAndRadius.xyz, 1), RelativeWorldToBox).xyz;
	float3 LocalRayDirection	= mul(float4(ReflectionVector,  0), RelativeWorldToBox).xyz;
	float3 InvRayDir = rcp(LocalRayDirection);
	float3 FirstPlaneIntersections = -InvRayDir - LocalRayStart * InvRayDir;
	float3 SecondPlaneIntersections = InvRayDir - LocalRayStart * InvRayDir;
	float3 FurthestPlaneIntersections = max(FirstPlaneIntersections, SecondPlaneIntersections);
	float Intersection = min(FurthestPlaneIntersections.x, min(FurthestPlaneIntersections.y, FurthestPlaneIntersections.z));
	float3 IntersectPosition = WorldPosition + Intersection * ReflectionVector;
	float3 ProjectedCaptureVector = IntersectPosition - (BoxCapturePositionAndRadius.xyz + LocalCaptureOffset);
	float BoxDistance = ComputeDistanceFromBoxToPoint(-(BoxScales.xyz - .5f * BoxScales.w), BoxScales.xyz - .5f * BoxScales.w, LocalRayStart * BoxScales.xyz);
	DistanceAlpha = 1.0 - smoothstep(0, .7f * BoxScales.w, BoxDistance);
	return ProjectedCaptureVector;
}
float3 GetLookupVectorForSphereCapture(float3 ReflectionVector, float3 WorldPosition, float4 SphereCapturePositionAndRadius, float NormalizedDistanceToCapture, float3 LocalCaptureOffset, inout float DistanceAlpha)
{
	float3 ProjectedCaptureVector = ReflectionVector;
	float ProjectionSphereRadius = SphereCapturePositionAndRadius.w;
	float SphereRadiusSquared = ProjectionSphereRadius * ProjectionSphereRadius;
	float3 LocalPosition = WorldPosition - SphereCapturePositionAndRadius.xyz;
	float LocalPositionSqr = dot(LocalPosition, LocalPosition);
	float3 QuadraticCoef;
	QuadraticCoef.x = 1;
	QuadraticCoef.y = dot(ReflectionVector, LocalPosition);
	QuadraticCoef.z = LocalPositionSqr - SphereRadiusSquared;
	float Determinant = QuadraticCoef.y * QuadraticCoef.y - QuadraticCoef.z;
	[flatten]
	if (Determinant >= 0)
	{
		float FarIntersection = sqrt(Determinant) - QuadraticCoef.y;
		float3 LocalIntersectionPosition = LocalPosition + FarIntersection * ReflectionVector;
		ProjectedCaptureVector = LocalIntersectionPosition - LocalCaptureOffset;
		float x = saturate( 2.5 * NormalizedDistanceToCapture - 1.5 );
		DistanceAlpha = 1 - x*x*(3 - 2*x);
	}
	return ProjectedCaptureVector;
}
float ComputeMixingWeight(float IndirectIrradiance, float AverageBrightness, float Roughness)
{
	float MixingAlpha = smoothstep(0, 1, saturate(Roughness * View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.x + View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.y));
	float MixingWeight = IndirectIrradiance / max(AverageBrightness, .0001f);
	MixingWeight = min(MixingWeight, View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.z);
	return lerp(1.0f, MixingWeight, MixingAlpha);
}
float GetRadianceProbeTMin(uint ClipmapIndex)
{
	return TranslucentBasePass.RadianceProbeSettings[ClipmapIndex].x; 
}
float GetWorldPositionToRadianceProbeCoordScale(uint ClipmapIndex)
{
	return TranslucentBasePass.RadianceProbeSettings[ClipmapIndex].y; 
}
float GetRadianceProbeCoordToWorldPositionScale(uint ClipmapIndex)
{
	return TranslucentBasePass.RadianceProbeSettings[ClipmapIndex].z; 
}
float3 GetWorldPositionToRadianceProbeCoordBias(uint ClipmapIndex)
{
	return TranslucentBasePass.PaddedWorldPositionToRadianceProbeCoordBias[ClipmapIndex].xyz; 
}
float3 GetRadianceProbeCoordToWorldPositionBias(uint ClipmapIndex)
{
	return TranslucentBasePass.PaddedRadianceProbeCoordToWorldPositionBias[ClipmapIndex].xyz; 
}
float3 GetProbeWorldPosition(uint3 ProbeCoord, uint ClipmapIndex, uint ProbeIndex)
{
	float3 ProbeWorldPosition = ProbeCoord * GetRadianceProbeCoordToWorldPositionScale(ClipmapIndex) + GetRadianceProbeCoordToWorldPositionBias(ClipmapIndex);
	return ProbeWorldPosition + TranslucentBasePass_ProbeWorldOffset[ProbeIndex].xyz;
}
uint GetRadianceProbeClipmap(float3 WorldSpacePosition, float ClipmapDitherRandom)
{
	uint ClipmapIndex = 0;
	for (; ClipmapIndex < TranslucentBasePass.NumRadianceProbeClipmaps; ++ClipmapIndex)
	{
		float3 ProbeCoordFloat = WorldSpacePosition * GetWorldPositionToRadianceProbeCoordScale(ClipmapIndex) + GetWorldPositionToRadianceProbeCoordBias(ClipmapIndex);
		float3 BottomEdgeFades = saturate((ProbeCoordFloat - .5f) * TranslucentBasePass.InvClipmapFadeSize);
		float3 TopEdgeFades = saturate(((float3)TranslucentBasePass.RadianceProbeClipmapResolution - .5f - ProbeCoordFloat) * TranslucentBasePass.InvClipmapFadeSize);
		float EdgeFade = min(min3(BottomEdgeFades.x, BottomEdgeFades.y, BottomEdgeFades.z), min3(TopEdgeFades.x, TopEdgeFades.y, TopEdgeFades.z));
		if (EdgeFade > ClipmapDitherRandom)
		{
			return ClipmapIndex;
		}
	}
	return TranslucentBasePass.NumRadianceProbeClipmaps;
}
struct FRadianceCacheCoverage
{
	uint ClipmapIndex;
	float MinTraceDistanceBeforeInterpolation;
	bool bValid;
};
FRadianceCacheCoverage InitRadianceCacheCoverage()
{
	FRadianceCacheCoverage Out;
	Out.ClipmapIndex = 0;
	Out.MinTraceDistanceBeforeInterpolation = 10000000.0f;
	Out.bValid = false;
	return Out;
}
FRadianceCacheCoverage GetRadianceCacheCoverage(float3 RayOrigin, float3 RayDirection, float ClipmapDitherRandom)
{
	FRadianceCacheCoverage Coverage = InitRadianceCacheCoverage();
	Coverage.ClipmapIndex = GetRadianceProbeClipmap(RayOrigin, ClipmapDitherRandom);
	if (Coverage.ClipmapIndex < TranslucentBasePass.NumRadianceProbeClipmaps)
	{
		Coverage.bValid = true;
		float CellOcclusionDistance = GetRadianceProbeCoordToWorldPositionScale(Coverage.ClipmapIndex) * sqrt(3.0f);
		Coverage.MinTraceDistanceBeforeInterpolation = GetRadianceProbeTMin(Coverage.ClipmapIndex) + CellOcclusionDistance;
	}
	return Coverage;
}
float3 SampleRadianceCacheProbe(uint ProbeIndex, float3 WorldSpaceDirection, float MipLevel)
{
	float2 ProbeUV = InverseEquiAreaSphericalMapping(WorldSpaceDirection);
	uint2 ProbeAtlasCoord = TranslucentBasePass.FinalProbeResolution * uint2(ProbeIndex & TranslucentBasePass.ProbeAtlasResolutionModuloMask, ProbeIndex >> TranslucentBasePass.ProbeAtlasResolutionDivideShift);
	float2 ProbeTexelCoord = ProbeUV * TranslucentBasePass.RadianceProbeResolution + (1u << TranslucentBasePass.FinalRadianceAtlasMaxMip);
	float2 ProbeAtlasUV = (ProbeAtlasCoord + ProbeTexelCoord) * TranslucentBasePass.InvProbeFinalRadianceAtlasResolution;
	float3 UnmappedDebugColor = 0.0f;
	return ProbeIndex == 0xFFFFFFFF ? UnmappedDebugColor : TranslucentBasePass_RadianceCacheFinalRadianceAtlas.SampleLevel( D3DStaticBilinearClampedSampler, ProbeAtlasUV, MipLevel);
}
uint GetProbeIndexFromIndirectionTexture(uint3 ProbeCoord, uint ClipmapIndex)
{
	uint3 ProbeIndirectionTextureCoord = uint3(ProbeCoord.x + ClipmapIndex * TranslucentBasePass.RadianceProbeClipmapResolution, ProbeCoord.yz);
	return TranslucentBasePass_RadianceProbeIndirectionTexture.Load(uint4(ProbeIndirectionTextureCoord, 0));
}
float3 SampleRadianceCacheProbeWithParallaxCorrection(uint3 ProbeCoord, uint ProbeClipmapIndex, float3 WorldSpacePosition, float3 WorldSpaceDirection, float MipLevel)
{
	float ProbeTMin = GetRadianceProbeTMin(ProbeClipmapIndex);
	uint ProbeIndex = GetProbeIndexFromIndirectionTexture(ProbeCoord, ProbeClipmapIndex);
	float3 ProbeWorldPosition = GetProbeWorldPosition(ProbeCoord, ProbeClipmapIndex, ProbeIndex);
	float3 ReprojectedDirection = WorldSpaceDirection;
	float CorrectionFactor = 1.0f;
	float ReprojectionRadius = TranslucentBasePass.ReprojectionRadiusScale * ProbeTMin;
	float T = RayIntersectSphere(WorldSpacePosition, WorldSpaceDirection, float4(ProbeWorldPosition, ReprojectionRadius)).y;
	float3 IntersectionPosition = WorldSpacePosition + WorldSpaceDirection * T;
	ReprojectedDirection = IntersectionPosition - ProbeWorldPosition;
	CorrectionFactor = T * T / (ReprojectionRadius * dot(ReprojectedDirection, WorldSpaceDirection));
	return SampleRadianceCacheProbe(ProbeIndex, ReprojectedDirection, MipLevel) * CorrectionFactor;
}
float3 SampleRadianceCacheInterpolated(FRadianceCacheCoverage Coverage, float3 WorldSpacePosition, float3 WorldSpaceDirection, float ConeHalfAngle)
{
	float3 ProbeCoordFloat = WorldSpacePosition * GetWorldPositionToRadianceProbeCoordScale(Coverage.ClipmapIndex) + GetWorldPositionToRadianceProbeCoordBias(Coverage.ClipmapIndex);
	float NumTexels = sqrt(1.0f - cos(ConeHalfAngle)) * TranslucentBasePass.RadianceProbeResolution;
	float MipLevel = clamp(log2(NumTexels), 0, (float)TranslucentBasePass.FinalRadianceAtlasMaxMip);
	float3 CornerProbeCoordFloat = ProbeCoordFloat - 0.5f;
	int3 CornerProbeCoord = floor(CornerProbeCoordFloat);
	float3 LerpAlphas = frac(CornerProbeCoordFloat);
	float3 Lighting000 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 0, 0), Coverage.ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
	float3 Lighting001 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 0, 1), Coverage.ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
	float3 Lighting010 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 1, 0), Coverage.ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
	float3 Lighting011 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 1, 1), Coverage.ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
	float3 Lighting100 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 0, 0), Coverage.ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
	float3 Lighting101 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 0, 1), Coverage.ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
	float3 Lighting110 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 1, 0), Coverage.ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
	float3 Lighting111 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 1, 1), Coverage.ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
	float3 ZLerp00 = lerp(Lighting000, Lighting001, LerpAlphas.z);
	float3 ZLerp01 = lerp(Lighting010, Lighting011, LerpAlphas.z);
	float3 ZLerp10 = lerp(Lighting100, Lighting101, LerpAlphas.z);
	float3 ZLerp11 = lerp(Lighting110, Lighting111, LerpAlphas.z);
	float3 YLerp0 = lerp(ZLerp00, ZLerp01, LerpAlphas.y);
	float3 YLerp1 = lerp(ZLerp10, ZLerp11, LerpAlphas.y);
	return lerp(YLerp0, YLerp1, LerpAlphas.x);
}
bool IsLumenTranslucencyGIEnabled()
{
	return TranslucentBasePass.TranslucencyGIGridSize.z > 0;
}
float3 ComputeTranslucencyGIVolumeUV(FDFVector3 WorldPosition, FDFInverseMatrix WorldToClip) 
{
	float4 NDCPosition = DFMultiplyDemote(MakeDFVector(WorldPosition, 1.0f), WorldToClip);
	NDCPosition.xy /= NDCPosition.w;
	float NormalizedZSlice = log2(NDCPosition.w * TranslucentBasePass.TranslucencyGIGridZParams.x + TranslucentBasePass.TranslucencyGIGridZParams.y) * TranslucentBasePass.TranslucencyGIGridZParams.z / (float)TranslucentBasePass.TranslucencyGIGridSize.z;
	return float3(NDCPosition.xy * float2(.5f, -.5f) + .5f, NormalizedZSlice);
}
FTwoBandSHVectorRGB GetTranslucencyGIVolumeLighting(FDFVector3 WorldPosition, FDFInverseMatrix WorldToClip, bool bTemporalFiltered)
{
	float3 VolumeUV = ComputeTranslucencyGIVolumeUV(WorldPosition, WorldToClip);
	float3 AmbientLightingVector;
	float3 DirectionalLightingVector;
	if (bTemporalFiltered)
	{
		AmbientLightingVector = Texture3DSampleLevel(TranslucentBasePass_TranslucencyGIVolumeHistory0, TranslucentBasePass_TranslucencyGIVolumeSampler, VolumeUV, 0).xyz;
		DirectionalLightingVector = Texture3DSampleLevel(TranslucentBasePass_TranslucencyGIVolumeHistory1, TranslucentBasePass_TranslucencyGIVolumeSampler, VolumeUV, 0).xyz;
	}
	else
	{
		AmbientLightingVector = Texture3DSampleLevel(TranslucentBasePass_TranslucencyGIVolume0, TranslucentBasePass_TranslucencyGIVolumeSampler, VolumeUV, 0).xyz;
		DirectionalLightingVector = Texture3DSampleLevel(TranslucentBasePass_TranslucencyGIVolume1, TranslucentBasePass_TranslucencyGIVolumeSampler, VolumeUV, 0).xyz;
	}
	FTwoBandSHVectorRGB TranslucentLighting;
	TranslucentLighting.R.V.x = AmbientLightingVector.r;
	TranslucentLighting.G.V.x = AmbientLightingVector.g;
	TranslucentLighting.B.V.x = AmbientLightingVector.b;
	float3 NormalizedAmbientColor = AmbientLightingVector.rgb / ( Luminance( AmbientLightingVector.rgb ) + 0.00001f );
	TranslucentLighting.R.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.r;
	TranslucentLighting.G.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.g;
	TranslucentLighting.B.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.b;
	return TranslucentLighting;
}
bool UseFrontLayerReflection(float2 BufferUV, float SceneDepth)
{
	bool bValid = false;
	if (TranslucentBasePass.Enabled > 0)
	{
		float SingleLayerDeviceZ = Texture2DSampleLevel(TranslucentBasePass_SceneDepth,  D3DStaticPointClampedSampler, BufferUV, 0.0f).x;
		float DeviceZ = ConvertToDeviceZ(SceneDepth);
		if (abs(asint(SingleLayerDeviceZ) - asint(DeviceZ)) <= TranslucentBasePass.RelativeDepthThreshold)
		{
			bValid = true;
		}
	}
	return bValid;
}
float3 SampleFrontLayerReflection(float2 BufferUV)
{
	const float3 Radiance = Texture2DArraySample(TranslucentBasePass_Radiance,  D3DStaticPointClampedSampler, float3(BufferUV, 0.0f)).xyz * View.OneOverPreExposure;
	return (pow(Radiance * (1.f / 0.18f), TranslucentBasePass.Contrast) * 0.18f) * TranslucentBasePass.SpecularScale;
}
void SetGBufferForShadingModel(
	in out FGBufferData GBuffer, 
	in out FMaterialPixelParameters MaterialParameters,
	const float Opacity,
	const float3 BaseColor,
	const float  Metallic,
	const float  Specular,
	const float Roughness,
	const float Anisotropy,
	const float3 SubsurfaceColor,
	const float SubsurfaceProfile,
	const float Dither,
	const uint ShadingModel)
{
	GBuffer.WorldNormal = MaterialParameters.WorldNormal;
	GBuffer.WorldTangent = MaterialParameters.WorldTangent;
	GBuffer.BaseColor = BaseColor;
	GBuffer.Metallic = Metallic;
	GBuffer.Specular = Specular;
	GBuffer.Roughness = Roughness;
	GBuffer.Anisotropy = Anisotropy;
	GBuffer.ShadingModelID = ShadingModel;
	if (false)
	{
	}
}
void AccumulateThinTranslucentModel(inout float3 DualBlendSurfaceLuminancePostCoverage,
								inout float3 DualBlendSurfaceTransmittancePreCoverage,
								inout float DualBlendSurfaceCoverage,
								FMaterialPixelParameters MaterialParams,
								FGBufferData GBuffer,
								float3 DiffuseColor,
								float3 SpecularColor,
								float3 EmissiveColor,
								float TopMaterialCoverage)
{
	const float3 N = MaterialParams.WorldNormal;
	const float3 V = MaterialParams.CameraVector;
	const float NoV = saturate( abs( dot(N, V) ) + 1e-5 );
	float3 Transmittance = float3(1.0,1.0,1.0);
	float3 SurfaceColor = float3(0.0f,0.0f,0.0f);
	float3 TransmittanceColor = GetThinTranslucentMaterialOutput0(MaterialParams);
	float PathLength = rcp(NoV);
	float3 NegativeAbsorptionCoefficient = log(TransmittanceColor);
	float3 ColorTopMaterialCoverage = exp(NegativeAbsorptionCoefficient * PathLength);
	const float3 FresnelRatio = F_Schlick(GBuffer.SpecularColor, NoV);
	Transmittance = Transmittance * (1-FresnelRatio);
	Transmittance = Transmittance * ColorTopMaterialCoverage;
	Transmittance = Transmittance * (1-FresnelRatio);
	float3 DefaultLitColor = DiffuseColor + EmissiveColor;
	SurfaceColor += DefaultLitColor * TopMaterialCoverage;
	Transmittance *= (1.0f - TopMaterialCoverage);
	SurfaceColor += SpecularColor;
	DualBlendSurfaceCoverage = 1.0f;
	DualBlendSurfaceLuminancePostCoverage = SurfaceColor * DualBlendSurfaceCoverage;
	DualBlendSurfaceTransmittancePreCoverage = Transmittance;
}
float RadialAttenuationMask(float3 WorldLightVector)
{
	float NormalizeDistanceSquared = dot(WorldLightVector, WorldLightVector);
	return 1.0f - saturate(NormalizeDistanceSquared);
}
float RadialAttenuation(float3 WorldLightVector, float FalloffExponent)
{
	return pow(RadialAttenuationMask(WorldLightVector), FalloffExponent);
}
float SpotAttenuationMask(float3 L, float3 SpotDirection, float2 SpotAngles)
{
	return saturate((dot(L, -SpotDirection) - SpotAngles.x) * SpotAngles.y);
}
float SpotAttenuation(float3 L, float3 SpotDirection, float2 SpotAngles)
{
	float ConeAngleFalloff = Square(SpotAttenuationMask(L, SpotDirection, SpotAngles));
	return ConeAngleFalloff;
}
float SqrtOneMinusX(float x)
{
	return x < 0.01 ? 1 - x * (0.5 + x * 0.125) : sqrt(1 - x);
}
struct FCapsuleSphericalBounds
{
	FSphericalRect SphericalRect;
	float3 ConeAxis;
	float ConeSinThetaMax2;
	float ConeSolidAngle;
};
float GetCapsuleBoundsSolidAngle(FCapsuleSphericalBounds Bounds)
{
	return min(Bounds.SphericalRect.SolidAngle, Bounds.ConeSolidAngle);
}
float4 SampleCapsuleBounds(FCapsuleSphericalBounds Bounds, float2 E)
{
	if (Bounds.ConeSolidAngle < Bounds.SphericalRect.SolidAngle)
	{
		return float4(TangentToWorld(UniformSampleConeRobust(E, Bounds.ConeSinThetaMax2).xyz, Bounds.ConeAxis), Bounds.ConeSolidAngle);
	}
	else
	{
		return float4(normalize(UniformSampleSphericalRect(E, Bounds.SphericalRect)), Bounds.SphericalRect.SolidAngle);
	}
}
FCapsuleSphericalBounds CapsuleGetSphericalBounds(float3 Origin, float3 Axis, float Radius, float Length)
{
	float h = dot(Axis, Origin);
	float3 ClosestPointOnAxis = Origin - Axis * h;
	float DistanceToAxisSqr = dot(ClosestPointOnAxis, ClosestPointOnAxis);
	float RadiusSqr = Pow2(Radius);
	if (DistanceToAxisSqr <= RadiusSqr)
	{
		float3 CapCenter = Origin - Axis * Length * 0.5 * sign(h);
		float LightDistanceSquared = dot(CapCenter, CapCenter);
		float SinThetaMax2 = saturate(RadiusSqr / LightDistanceSquared);
		FCapsuleSphericalBounds Result;
		Result.SphericalRect = (FSphericalRect)0;
		Result.SphericalRect.SolidAngle = (asfloat(0x7F800000)); 
		Result.ConeAxis = normalize(CapCenter);
		Result.ConeSinThetaMax2 = SinThetaMax2;
		Result.ConeSolidAngle = UniformConeSolidAngle(SinThetaMax2);
		return Result;
	}
	FRect Rect;
	Rect.Origin = Origin;
	Rect.Axis[1] = Axis;
	Rect.Axis[2] = normalize(-ClosestPointOnAxis);
	Rect.Axis[0] = cross(Rect.Axis[1], Rect.Axis[2]);
	float SinCylinderAngle = Radius * rsqrt(DistanceToAxisSqr);
	float RectRadius = Radius * rsqrt(1 - Pow2(SinCylinderAngle));
	float Extension[2];
	for (int i = 0; i < 2; i++)
	{
		float hi = Length * (i > 0 ? 0.5 : -0.5);
		float3 PointPos = Origin + Axis * hi;
		float InverseDist = rsqrt(dot(PointPos, PointPos));
		float SinSphereAngle = saturate(Radius * InverseDist);
		float CosSphereAngle = SqrtOneMinusX(Pow2(SinSphereAngle));
		float CosAxisAngle = -dot(Axis, PointPos) * InverseDist;
		CosAxisAngle = sign(CosAxisAngle * hi) * saturate(abs(CosAxisAngle));
		float SinAxisAngle = SqrtOneMinusX(Pow2(CosAxisAngle));
		float CosExtension = SinAxisAngle * CosSphereAngle + CosAxisAngle * SinSphereAngle;
		Extension[i] = Radius / CosExtension;
	}
	float Translate = 0.5 * (Extension[1] - Extension[0]);
	float Extend = 0.5 * (Extension[0] + Extension[1]);
	Rect.Origin += Translate * Rect.Axis[1];
	Rect.Extent = float2(RectRadius, 0.5 * Length + Extend);
	float3 R0 = Rect.Origin - Rect.Axis[1] * Rect.Extent.y;
	float3 R1 = Rect.Origin + Rect.Axis[1] * Rect.Extent.y;
	float InvDistR0 = rsqrt(dot(R0, R0));
	float InvDistR1 = rsqrt(dot(R1, R1));
	FCapsuleSphericalBounds Result;
	Result.SphericalRect = BuildSphericalRect(Rect);
	Result.ConeAxis = normalize(lerp(R0, R1, saturate(InvDistR1 / (InvDistR0 + InvDistR1))));
	Result.ConeSinThetaMax2 = saturate(0.5 - 0.5 * dot(R0, R1) * InvDistR0 * InvDistR1); 
	Result.ConeSolidAngle = UniformConeSolidAngle(Result.ConeSinThetaMax2);
	return Result;
}
float CapsuleTest(float3 Rd, float3 Center, float3 Axis, float Radius2, float Length)
{
	float B = dot(Rd, Axis);
	float t = clamp(dot(Center, B * Rd - Axis) / (1 - B * B), -0.5 * Length, 0.5 * Length);
	float3 ToSphere = Center + t * Axis;
	float3 C = cross(Rd, ToSphere);
	return dot(C, C) <= Radius2 ? length(ToSphere) : -1.0;
}
FAreaLightIntegrateContext CreateCapsuleIntegrateContext(float Roughness, float3 N, float3 V, FCapsuleLight Capsule, bool bInverseSquared )
{
	FAreaLightIntegrateContext Out = InitAreaLightIntegrateContext();
	float NoL;
	float Falloff;
	float LineCosSubtended = 1;
	[branch]
	if( Capsule.Length > 0 )
	{
		LineIrradiance( N, Capsule.LightPos[0], Capsule.LightPos[1], Capsule.DistBiasSqr, LineCosSubtended, Falloff, NoL );
	}
	else
	{
		float DistSqr = dot( Capsule.LightPos[0], Capsule.LightPos[0] );
		Falloff = rcp( DistSqr + Capsule.DistBiasSqr );
		float3 L = Capsule.LightPos[0] * rsqrt( DistSqr );
		NoL = dot( N, L );
	}
	if( Capsule.Radius > 0 )
	{
		float SinAlphaSqr = saturate( Pow2( Capsule.Radius ) * Falloff );
		NoL = SphereHorizonCosWrap( NoL, SinAlphaSqr );
	}
	NoL = saturate( NoL );
	Falloff = bInverseSquared ? Falloff : 1;
	float3 ToLight = Capsule.LightPos[0];
	if( Capsule.Length > 0 )
	{
		float3 R = reflect( -V, N );
		ToLight = ClosestPointLineToRay( Capsule.LightPos[0], Capsule.LightPos[1], Capsule.Length, R );
	}
	float DistSqr = dot( ToLight, ToLight );
	float InvDist = rsqrt( DistSqr );
	float3 L = ToLight * InvDist;
	Roughness = max( Roughness, View.MinRoughness );
	float a = Pow2( Roughness );
	const float SizeFadesOutDiffuseMicroRefl = 20.0;
	Out.AreaLight.SphereSinAlpha = saturate( Capsule.Radius * InvDist * (1 - a) );
	Out.AreaLight.SphereSinAlphaSoft = saturate( Capsule.SoftRadius * InvDist );
	Out.AreaLight.LineCosSubtended = LineCosSubtended;
	Out.AreaLight.FalloffColor = 1;
	Out.AreaLight.Rect = (FRect)0;
	Out.AreaLight.Texture = InitRectTexture();
	Out.AreaLight.IsRectAndDiffuseMicroReflWeight = 0;
	SetIsRectLight(Out.AreaLight, false);
	SetAreaLightDiffuseMicroReflWeight(Out.AreaLight, saturate(1.0f - max(Capsule.Length, Capsule.Radius) / SizeFadesOutDiffuseMicroRefl));
	Out.NoL = NoL;
	Out.Falloff = Falloff;	
	Out.L = L;
	return Out;
}
FDirectLighting IntegrateBxDF( FGBufferData GBuffer, float3 N, float3 V, FCapsuleLight Capsule, FShadowTerms Shadow, bool bInverseSquared )
{
	GBuffer.Roughness = max( GBuffer.Roughness, View.MinRoughness );
	FAreaLightIntegrateContext Context = CreateCapsuleIntegrateContext(GBuffer.Roughness, N, V, Capsule, bInverseSquared);
	return IntegrateBxDF( GBuffer, N, V, Context.L, Context.Falloff, Context.NoL, Context.AreaLight, Shadow );
}
FDirectLighting IntegrateBxDF( FGBufferData GBuffer, float3 N, float3 V, FCapsuleLight Capsule, FShadowTerms Shadow, uint2 SVPos )
{
	FDirectLighting Lighting = (FDirectLighting)0;
	Capsule.Radius = max( 1, Capsule.Radius );
	const float SphereArea = (4*PI) * Pow2( Capsule.Radius );
	const float CylinderArea = (2*PI) * Capsule.Radius * Capsule.Length;
	const float SurfaceArea = SphereArea + CylinderArea;
	const float SurfaceColor = 4.0 / SurfaceArea;
	float3 ToLight = 0.5 * ( Capsule.LightPos[0] + Capsule.LightPos[1] );
	float3 CapsuleAxis = normalize( Capsule.LightPos[1] - Capsule.LightPos[0] );
	float DistanceSqr = dot( ToLight, ToLight );
	float3 ConeAxis = ToLight * rsqrt( DistanceSqr );
	float SineConeSqr = saturate(Pow2(Capsule.Radius) / DistanceSqr);
	FCapsuleSphericalBounds CapsuleBounds = CapsuleGetSphericalBounds(ToLight, CapsuleAxis, Capsule.Radius, Capsule.Length);
	const uint NumSets = 3;
	const uint NumSamples[ NumSets ] =
	{
		0,	
		16,	
		16,	
	};
	uint2 SobolBase = SobolPixel( SVPos );
	uint2 SobolFrame = SobolIndex( SobolBase, View.StateFrameIndexMod8, 3 );
	[unroll]
	for( uint Set = 0; Set < NumSets; Set++ )
	{
		[loop]
		for( uint i = 0; i < NumSamples[ Set ]; i++ )
		{
			uint2 Random = Rand3DPCG16( uint3( SVPos.xy, View.Random ^ Set ) ).xy;
			float2 E = float2( SobolIndex( SobolFrame, i << 3 ) ) / 0x10000;
			float3 L, H;
			if( Set == 0 )
			{
				L = TangentToWorld( CosineSampleHemisphere( E ).xyz, N );
				H = normalize(V + L);
			}
			else if( Set == 1 )
			{
				H = TangentToWorld( ImportanceSampleGGX( E, Pow4(GBuffer.Roughness) ).xyz, N );
				L = 2 * dot( V, H ) * H - V;
			}
			else
			{
				if( Capsule.Length > 0 )
				{
					float3 ToArea = SampleCapsuleBounds(CapsuleBounds, E).xyz;
					L = normalize( ToArea );
					H = normalize( V + L );
				}
				else
				{
					L = TangentToWorld( UniformSampleConeRobust( E, SineConeSqr).xyz, ConeAxis );
					H = normalize(V + L);
				}
			}
			float NoL = saturate( dot(N, L) );
			float NoH = saturate( dot(N, H) );
			float VoH = saturate( dot(V, H) );
			if( NoL > 0 && VoH > 0 )
			{
				{
					if (CapsuleTest(L, ToLight, CapsuleAxis, Pow2(Capsule.Radius), Capsule.Length) > 0)
					{
						continue;
					}
				}
				float PDF[] =
				{
					NoL / PI,
					D_GGX(Pow4(GBuffer.Roughness), NoH) * NoH / (4 * VoH),
					1.0 / GetCapsuleBoundsSolidAngle(CapsuleBounds)
				};
				if( Capsule.Length == 0 )
				{
					PDF[2] = 1.0 / UniformConeSolidAngle(SineConeSqr);
				}
				float InvWeight = 0;
				[unroll] for( uint j = 0; j < NumSets; j++ )
				{
					InvWeight += Square( PDF[j] * NumSamples[j] );
				}
				float Weight = rcp( InvWeight ) * PDF[Set] * NumSamples[Set];
				FDirectLighting LightingSample = EvaluateBxDF( GBuffer, N, V, L, NoL, Shadow );
				Lighting.Diffuse		+= SurfaceColor * Weight * LightingSample.Diffuse;
				Lighting.Specular		+= SurfaceColor * Weight * LightingSample.Specular;
				Lighting.Transmission	+= SurfaceColor * Weight * LightingSample.Transmission;
			}
		}
	}
	return Lighting;
}
FAreaLightIntegrateContext CreateRectIntegrateContext( float Roughness, float3 N, float3 V, FRect Rect, FRectTexture SourceTexture )
{
	float NoL = 0;
	float Falloff = 0;
	FAreaLightIntegrateContext Out = InitAreaLightIntegrateContext();
	float3 L = RectIrradianceLambert( N, Rect, Falloff, NoL );
	float3 FalloffColor = SampleSourceTexture( L, Rect, SourceTexture );
	Out.AreaLight.SphereSinAlpha = 0;
	Out.AreaLight.SphereSinAlphaSoft = 0;
	Out.AreaLight.LineCosSubtended = 1;
	Out.AreaLight.FalloffColor = FalloffColor;
	Out.AreaLight.Rect = Rect;
	Out.AreaLight.Texture = SourceTexture;
	Out.AreaLight.IsRectAndDiffuseMicroReflWeight = 0;
	SetIsRectLight(Out.AreaLight, true);
	SetAreaLightDiffuseMicroReflWeight(Out.AreaLight, 0.0);
	Out.L = L;
	Out.NoL = NoL;
	Out.Falloff = Falloff;
	return Out;
}
FDirectLighting IntegrateBxDF(FGBufferData GBuffer, float3 N, float3 V, FRect Rect, FShadowTerms Shadow, FRectTexture SourceTexture)
{
	FDirectLighting Out = (FDirectLighting)0;
	if (IsRectVisible(Rect))
	{
		FAreaLightIntegrateContext Context = CreateRectIntegrateContext(GBuffer.Roughness, N, V, Rect, SourceTexture);
		GBuffer.Roughness = max(GBuffer.Roughness, 0.02);
		Out = IntegrateBxDF(GBuffer, N, V, Context.L, Context.Falloff, Context.NoL, Context.AreaLight, Shadow);
	}
	return Out;
}
FDirectLighting IntegrateBxDF( FGBufferData GBuffer, float3 N, float3 V, FRect Rect, FShadowTerms Shadow, FRectTexture SourceTexture, uint2 SVPos )
{
	FDirectLighting Lighting = (FDirectLighting)0;
	const float SurfaceArea = 4 * Rect.Extent.x * Rect.Extent.y;
	const float SurfaceColor = 2.0 / SurfaceArea;
	if( dot( Rect.Axis[2], Rect.Origin ) < 0 )
		return Lighting;
	if (!IsRectVisible(Rect))
		return Lighting;
	FSphericalRect SphericalRect = BuildSphericalRect( Rect );
	const uint NumSets = 4;
	const uint NumSamples[ NumSets ] =
	{
		0,	
		16,	
		0,	
		16,	
	};
	uint2 SobolBase = SobolPixel( SVPos );
	uint2 SobolFrame = SobolIndex( SobolBase, View.StateFrameIndexMod8, 3 );
	[unroll]
	for( uint Set = 0; Set < NumSets; Set++ )
	{
		[loop]
		for( uint i = 0; i < NumSamples[ Set ]; i++ )
		{
			uint2 Random = Rand3DPCG16( uint3( SVPos.xy, View.Random ^ Set ) ).xy;
			float2 E = float2( SobolIndex( SobolFrame, i << 3 ) ) / 0x10000;
			float3 L, H;
			switch( Set )
			{
				case 0:
				{
					L = TangentToWorld( CosineSampleHemisphere( E ).xyz, N );
					H = normalize( V + L );
					break;
				}
				case 1:
				{
					H = TangentToWorld( ImportanceSampleGGX( E, Pow4(GBuffer.Roughness) ).xyz, N );
					L = 2 * dot( V, H ) * H - V;
					break;
				}
				case 2:
				{
					float3 ToArea = Rect.Origin;
					ToArea += (E.x * 2 - 1) * Rect.Axis[0] * Rect.Extent.x;
					ToArea += (E.y * 2 - 1) * Rect.Axis[1] * Rect.Extent.y;
					L = normalize( ToArea );
					H = normalize( V + L );
					break;
				}
				case 3:
				{
					float3 ToArea = UniformSampleSphericalRect( E, SphericalRect );
					L = normalize( ToArea );
					H = normalize( V + L );
					break;
				}
			}
			float NoL = saturate( dot(N, L) );
			float NoH = saturate( dot(N, H) );
			float VoH = saturate( dot(V, H) );
			if( NoL > 0 && VoH > 0 )
			{
				float t = dot( Rect.Axis[2], Rect.Origin ) / dot( Rect.Axis[2], L );
				float3 PointOnPlane = L * t;
				float2 PointInRect;
				PointInRect.x = dot( Rect.Axis[0], PointOnPlane - Rect.Origin );
				PointInRect.y = dot( Rect.Axis[1], PointOnPlane - Rect.Origin );
				float2 RectUV = PointInRect / Rect.Extent * float2( 0.5, -0.5 ) + 0.5;
				float3 LightColor = SampleRectTexture(SourceTexture, RectUV, 0, true);
				if( Set == 0 || Set == 1 )
				{
					bool InExtentX = abs( PointInRect.x ) <= Rect.Extent.x;
					bool InExtentY = abs( PointInRect.y ) <= Rect.Extent.y;
					[branch]
					if( t < 0 || !InExtentX || !InExtentY )
					{
						continue;
					}
				}
				float PDF[] =
				{
					NoL * (1 / PI),
					D_GGX( Pow4(GBuffer.Roughness), NoH ) * NoH / (4 * VoH),
					dot( PointOnPlane, PointOnPlane ) / ( SurfaceArea * abs( dot( L, Rect.Axis[2] ) ) ),
					1.0 / SphericalRect.SolidAngle,
				};
				float InvWeight = 0;
				[unroll] for( uint j = 0; j < NumSets; j++ )
				{
					InvWeight += Square( PDF[j] * NumSamples[j] );
				}
				float Weight = rcp( InvWeight ) * PDF[Set] * NumSamples[Set];
				FDirectLighting LightingSample = EvaluateBxDF( GBuffer, N, V, L, NoL, Shadow );
				Lighting.Diffuse		+= ( LightColor * Weight ) * LightingSample.Diffuse;
				Lighting.Specular		+= ( LightColor * Weight ) * LightingSample.Specular;
				Lighting.Transmission	+= ( LightColor * Weight ) * LightingSample.Transmission;
			}
		}
	}
	return Lighting;
}
float DistanceFromCameraFade(float SceneDepth, FDeferredLightData LightData)
{
	float Fade = saturate(SceneDepth * LightData.DistanceFadeMAD.x + LightData.DistanceFadeMAD.y);
	return Fade * Fade;
}
void GetShadowTermsBase(
	float SceneDepth, 
	float4 PrecomputedShadowFactors, 
	FDeferredLightData LightData, 
	float4 LightAttenuation, 
	inout FShadowTerms OutShadow)
{
	[branch]
	if (LightData.ShadowedBits)
	{
		float UsesStaticShadowMap = dot(LightData.ShadowMapChannelMask, float4(1, 1, 1, 1));
		float StaticShadowing = lerp(1, dot(PrecomputedShadowFactors, LightData.ShadowMapChannelMask), UsesStaticShadowMap);
		if (LightData.bRadialLight || 0)
		{
			OutShadow.SurfaceShadow = LightAttenuation.z * StaticShadowing;
			OutShadow.TransmissionShadow = LightAttenuation.w * StaticShadowing;
			OutShadow.TransmissionThickness = LightAttenuation.w;
		}
		else
		{
			float DynamicShadowFraction = DistanceFromCameraFade(SceneDepth, LightData);
			OutShadow.SurfaceShadow = lerp(LightAttenuation.x, StaticShadowing, DynamicShadowFraction);
			OutShadow.TransmissionShadow = min(lerp(LightAttenuation.y, StaticShadowing, DynamicShadowFraction), LightAttenuation.w);
			OutShadow.SurfaceShadow *= LightAttenuation.z;
			OutShadow.TransmissionShadow *= LightAttenuation.z;
			OutShadow.TransmissionThickness = min(LightAttenuation.y, LightAttenuation.w);
		}
	}
	OutShadow.HairTransmittance = LightData.HairTransmittance;
	OutShadow.HairTransmittance.OpaqueVisibility = OutShadow.SurfaceShadow;
}
void ApplyContactShadowWithShadowTerms(
	float SceneDepth, 
	uint ShadingModelID, 
	float ContactShadowOpacity, 
	FDeferredLightData LightData, 
	float3 TranslatedWorldPosition, 
	float3 L, 
	float Dither, 
	inout FShadowTerms OutShadow)
{
}
void GetShadowTerms(
	float SceneDepth,
	float4 PrecomputedShadowFactors,
	uint ShadingModelID,
	float ContactShadowOpacity,
	FDeferredLightData LightData,
	float3 TranslatedWorldPosition,
	float3 L,
	float4 LightAttenuation,
	float Dither,
	inout FShadowTerms OutShadow)
{
	GetShadowTermsBase(SceneDepth, PrecomputedShadowFactors, LightData, LightAttenuation, OutShadow);
	ApplyContactShadowWithShadowTerms (SceneDepth, ShadingModelID, ContactShadowOpacity, LightData, TranslatedWorldPosition, L, Dither, OutShadow);
}
float GetLocalLightAttenuation(
	float3 TranslatedWorldPosition, 
	FDeferredLightData LightData, 
	inout float3 ToLight, 
	inout float3 L)
{
	ToLight = LightData.TranslatedWorldPosition - TranslatedWorldPosition;
	float DistanceSqr = dot( ToLight, ToLight );
	L = ToLight * rsqrt( DistanceSqr );
	float LightMask;
	if (LightData.bInverseSquared)
	{
		LightMask = Square( saturate( 1 - Square( DistanceSqr * Square(LightData.InvRadius) ) ) );
	}
	else
	{
		LightMask = RadialAttenuation(ToLight * LightData.InvRadius, LightData.FalloffExponent);
	}
	if (LightData.bSpotLight)
	{
		LightMask *= SpotAttenuation(L, -LightData.Direction, LightData.SpotAngles);
	}
	if( LightData.bRectLight )
	{
		LightMask = dot( LightData.Direction, L ) < 0 ? 0 : LightMask;
	}
	return LightMask;
}
FRect GetRect(float3 ToLight, FDeferredLightData LightData)
{
	return GetRect(
		ToLight, 
		LightData.Direction, 
		LightData.Tangent, 
		LightData.SourceRadius, 
		LightData.SourceLength, 
		LightData.RectLightData.BarnCosAngle, 
		LightData.RectLightData.BarnLength,
		1);
}
FCapsuleLight GetCapsule( float3 ToLight, FDeferredLightData LightData )
{
	FCapsuleLight Capsule;
	Capsule.Length = LightData.SourceLength;
	Capsule.Radius = LightData.SourceRadius;
	Capsule.SoftRadius = LightData.SoftSourceRadius;
	Capsule.DistBiasSqr = 1;
	Capsule.LightPos[0] = ToLight - 0.5 * Capsule.Length * LightData.Tangent;
	Capsule.LightPos[1] = ToLight + 0.5 * Capsule.Length * LightData.Tangent;
	return Capsule;
}
FLightAccumulator AccumulateDynamicLighting(
	float3 TranslatedWorldPosition, float3 CameraVector, FGBufferData GBuffer, float AmbientOcclusion, uint ShadingModelID,
	FDeferredLightData LightData, float4 LightAttenuation, float Dither, uint2 SVPos, 
	inout float SurfaceShadow)
{
	FLightAccumulator LightAccumulator = (FLightAccumulator)0;
	float3 V = -CameraVector;
	float3 N = GBuffer.WorldNormal;
	[branch] if( GBuffer.ShadingModelID == 4 && 0)
	{
		const float2 oct1 = ((float2(GBuffer.CustomData.a, GBuffer.CustomData.z) * 4) - (512.0/255.0)) + UnitVectorToOctahedron(GBuffer.WorldNormal);
		N = OctahedronToUnitVector(oct1);			
	}
	float3 L = LightData.Direction;	
	float3 ToLight = L;
	float3 MaskedLightColor = LightData.Color;
	float LightMask = 1;
	if (LightData.bRadialLight)
	{
		LightMask = GetLocalLightAttenuation( TranslatedWorldPosition, LightData, ToLight, L );
		MaskedLightColor *= LightMask;
	}
	LightAccumulator.EstimatedCost += 0.3f;		
	[branch]
	if( LightMask > 0 )
	{
		FShadowTerms Shadow;
		Shadow.SurfaceShadow = AmbientOcclusion;
		Shadow.TransmissionShadow = 1;
		Shadow.TransmissionThickness = 1;
		Shadow.HairTransmittance.OpaqueVisibility = 1;
		const float ContactShadowOpacity = GBuffer.CustomData.a;
		GetShadowTerms(GBuffer.Depth, GBuffer.PrecomputedShadowFactors, GBuffer.ShadingModelID, ContactShadowOpacity,
			LightData, TranslatedWorldPosition, L, LightAttenuation, Dither, Shadow);
		SurfaceShadow = Shadow.SurfaceShadow;
		LightAccumulator.EstimatedCost += 0.3f;		
		[branch]
		if( Shadow.SurfaceShadow + Shadow.TransmissionShadow > 0 )
		{
			const bool bNeedsSeparateSubsurfaceLightAccumulation = UseSubsurfaceProfile(GBuffer.ShadingModelID);
			FDirectLighting Lighting;
			if (LightData.bRectLight)
			{
				FRect Rect = GetRect( ToLight, LightData );
				const FRectTexture SourceTexture = ConvertToRectTexture(LightData);
					Lighting = IntegrateBxDF( GBuffer, N, V, Rect, Shadow, SourceTexture);
			}
			else
			{
				FCapsuleLight Capsule = GetCapsule( ToLight, LightData );
					Lighting = IntegrateBxDF( GBuffer, N, V, Capsule, Shadow, LightData.bInverseSquared );
			}
			Lighting.Specular *= LightData.SpecularScale;
			LightAccumulator_AddSplit( LightAccumulator, Lighting.Diffuse, Lighting.Specular, Lighting.Diffuse, MaskedLightColor * Shadow.SurfaceShadow, bNeedsSeparateSubsurfaceLightAccumulation );
			LightAccumulator_AddSplit( LightAccumulator, Lighting.Transmission, 0.0f, Lighting.Transmission, MaskedLightColor * Shadow.TransmissionShadow, bNeedsSeparateSubsurfaceLightAccumulation );
			LightAccumulator.EstimatedCost += 0.4f;		
		}
	}
	return LightAccumulator;
}
FDeferredLightingSplit GetDynamicLightingSplit(
	float3 TranslatedWorldPosition, float3 CameraVector, FGBufferData GBuffer, float AmbientOcclusion, uint ShadingModelID, 
	FDeferredLightData LightData, float4 LightAttenuation, float Dither, uint2 SVPos, 
	inout float SurfaceShadow)
{
	FLightAccumulator LightAccumulator = AccumulateDynamicLighting(TranslatedWorldPosition, CameraVector, GBuffer, AmbientOcclusion, ShadingModelID, LightData, LightAttenuation, Dither, SVPos, SurfaceShadow);
	return LightAccumulator_GetResultSplit(LightAccumulator);
}
uint GetCulledLightDataGrid(uint GridIndex)
{
	return TranslucentBasePass_Shared_Forward_CulledLightDataGrid16Bit[GridIndex];
}
struct FLightGridData
{
	uint LightGridPixelSizeShift;
	float3 LightGridZParams;
	int3 CulledGridSize;
};
FLightGridData GetLightGridData(uint EyeIndex)
{
	FLightGridData Result;
		Result.LightGridPixelSizeShift = TranslucentBasePass.Shared_Forward_LightGridPixelSizeShift;
		Result.LightGridZParams = TranslucentBasePass.Shared_Forward_LightGridZParams;
		Result.CulledGridSize = TranslucentBasePass.Shared_Forward_CulledGridSize;
	return Result;
}
uint3 ComputeLightGridCellCoordinate(uint2 PixelPos, float SceneDepth, uint EyeIndex)
{
	const FLightGridData GridData = GetLightGridData(EyeIndex);
	uint ZSlice = (uint)(max(0, log2(SceneDepth * GridData.LightGridZParams.x + GridData.LightGridZParams.y) * GridData.LightGridZParams.z));
	ZSlice = min(ZSlice, (uint)(GridData.CulledGridSize.z - 1));
	return uint3(PixelPos >> GridData.LightGridPixelSizeShift, ZSlice);
}
uint ComputeLightGridCellIndex(uint3 GridCoordinate, uint EyeIndex)
{
	const FLightGridData GridData = GetLightGridData(EyeIndex);
	return (GridCoordinate.z * GridData.CulledGridSize.y + GridCoordinate.y) * GridData.CulledGridSize.x + GridCoordinate.x;
}
uint ComputeLightGridCellIndex(uint2 PixelPos, float SceneDepth, uint EyeIndex)
{
	return ComputeLightGridCellIndex(ComputeLightGridCellCoordinate(PixelPos, SceneDepth, EyeIndex), EyeIndex);
}
uint ComputeLightGridCellIndex(uint2 PixelPos, float SceneDepth)
{
	return ComputeLightGridCellIndex(PixelPos, SceneDepth, 0);
}
uint GetMaxLightsPerCell(uint EyeIndex)
{
	return TranslucentBasePass.Shared_Forward_MaxCulledLightsPerCell ;
}
struct FCulledLightsGridData
{
	uint NumLights;
	uint DataStartIndex;
};
FCulledLightsGridData GetCulledLightsGrid(uint GridIndex, uint EyeIndex)
{
	FCulledLightsGridData Result;
		Result.NumLights = min(TranslucentBasePass_Shared_Forward_NumCulledLightsGrid[GridIndex * 2 + 0], TranslucentBasePass.Shared_Forward_NumLocalLights);
		Result.DataStartIndex = TranslucentBasePass_Shared_Forward_NumCulledLightsGrid[GridIndex * 2 + 1];
	return Result;
}
FDirectionalLightData GetDirectionalLightData(uint EyeIndex)
{
	FDirectionalLightData Result;
		Result.HasDirectionalLight					= TranslucentBasePass.Shared_Forward_HasDirectionalLight;
		Result.DirectionalLightShadowMapChannelMask = TranslucentBasePass.Shared_Forward_DirectionalLightShadowMapChannelMask;
		Result.DirectionalLightDistanceFadeMAD		= TranslucentBasePass.Shared_Forward_DirectionalLightDistanceFadeMAD;
		Result.DirectionalLightColor				= TranslucentBasePass.Shared_Forward_DirectionalLightColor;
		Result.DirectionalLightDirection			= TranslucentBasePass.Shared_Forward_DirectionalLightDirection;
		Result.DirectionalLightSourceRadius			= TranslucentBasePass.Shared_Forward_DirectionalLightSourceRadius;
		Result.DirectionalLightSoftSourceRadius		= TranslucentBasePass.Shared_Forward_DirectionalLightSoftSourceRadius;
		Result.DirectionalLightSpecularScale		= TranslucentBasePass.Shared_Forward_DirectionalLightSpecularScale;
		Result.LightFunctionAtlasLightIndex			= TranslucentBasePass.Shared_Forward_LightFunctionAtlasLightIndex;
	return Result;
}
FLocalLightData GetLocalLightData_Internal(
	uint LocalLightIndex,
	uint ClusteredDeferredSupportedEndIndex,
	uint ManyLightsSupportedStartIndex,
	uint SimpleLightsEndIndex,
	float4 InData0, float4 InData1, float4 InData2, float4 InData3, float4 InData4, float4 InData5)
{
	FLocalLightData Out = (FLocalLightData)0;
	Out.bClusteredDeferredSupported				= LocalLightIndex <  ClusteredDeferredSupportedEndIndex;
	Out.bManyLightsSupported					= LocalLightIndex >= ManyLightsSupportedStartIndex;
	Out.bIsSimpleLight							= LocalLightIndex <  SimpleLightsEndIndex;
	Out.LightPositionAndInvRadius				= InData0;
	Out.LightColorAndIdAndFalloffExponent		= InData1;
	Out.LightDirectionAndShadowMask				= InData2;
	Out.SpotAnglesAndSourceRadiusPacked			= InData3;
	Out.LightTangentAndIESDataAndSpecularScale	= InData4;
	Out.RectData								= InData5.xyz;
	Out.VirtualShadowMapId						= int(InData5.w);
	Out.PrevLocalLightIndex						= -1;
	Out.LightSceneId							= int(Out.LightColorAndIdAndFalloffExponent.z);
	return Out;
}
FLocalLightData GetLocalLightData(uint GridIndex, uint EyeIndex)
{
	FLocalLightData Out;
		uint LocalLightIndex = GetCulledLightDataGrid(GridIndex);
		uint LocalLightBaseIndex = LocalLightIndex * 6;
		Out = GetLocalLightData_Internal(
			LocalLightIndex, 
			TranslucentBasePass.Shared_Forward_ClusteredDeferredSupportedEndIndex,
			TranslucentBasePass.Shared_Forward_ManyLightsSupportedStartIndex,
			TranslucentBasePass.Shared_Forward_SimpleLightsEndIndex,
			TranslucentBasePass_Shared_Forward_ForwardLocalLightBuffer[LocalLightBaseIndex + 0],
			TranslucentBasePass_Shared_Forward_ForwardLocalLightBuffer[LocalLightBaseIndex + 1],
			TranslucentBasePass_Shared_Forward_ForwardLocalLightBuffer[LocalLightBaseIndex + 2],
			TranslucentBasePass_Shared_Forward_ForwardLocalLightBuffer[LocalLightBaseIndex + 3],
			TranslucentBasePass_Shared_Forward_ForwardLocalLightBuffer[LocalLightBaseIndex + 4],
			TranslucentBasePass_Shared_Forward_ForwardLocalLightBuffer[LocalLightBaseIndex + 5]);
	return Out;
}
struct FPCFSamplerSettings
{
	Texture2D		ShadowDepthTexture;
	SamplerState	ShadowDepthTextureSampler;
	float4			ShadowBufferSize;
	float			SceneDepth;
	float			TransitionScale;
	bool			bSubsurface;
	bool			bTreatMaxDepthUnshadowed;
	float			DensityMulConstant;
	float2			ProjectionDepthBiasParameters;
};
float PCF1x1(float2 Fraction, float4 Values00)
{
	float2 HorizontalLerp00 = lerp(Values00.wx, Values00.zy, Fraction.xx);
	return lerp(HorizontalLerp00.x, HorizontalLerp00.y, Fraction.y);
}
float4 CalculateOcclusion(float4 ShadowmapDepth, FPCFSamplerSettings Settings)
{
	if (Settings.bSubsurface)
	{
		float4 OccluderDistance = max(Settings.SceneDepth - ShadowmapDepth, 0);
		float4 Occlusion = GetSubSurfaceTransmission(OccluderDistance, Settings.DensityMulConstant);
		return  select_internal( ShadowmapDepth > .99f , 1.0f , Occlusion );
	}
	else
	{
		float TransitionScale = Settings.TransitionScale;
		float ConstantFactor = (Settings.SceneDepth * TransitionScale - 1);
		float4 ShadowFactor = saturate(ShadowmapDepth * TransitionScale - ConstantFactor);
		[flatten]
		if (Settings.bTreatMaxDepthUnshadowed)
		{
			ShadowFactor = saturate(ShadowFactor + (ShadowmapDepth > .99f));
		}
		return ShadowFactor;
	}
}
float3 CalculateOcclusion(float3 ShadowmapDepth, FPCFSamplerSettings Settings)
{
	if (Settings.bSubsurface)
	{
		float3 Thickness = max(Settings.SceneDepth - ShadowmapDepth, 0);
		float3 Occlusion = saturate(FastExp(-Thickness * Settings.DensityMulConstant));
		return  select_internal( ShadowmapDepth > .99f , 1.0 , Occlusion );
	}
	else
	{
		float TransitionScale = Settings.TransitionScale;
		float ConstantFactor = (Settings.SceneDepth * TransitionScale - 1);
		float3 ShadowFactor = saturate(ShadowmapDepth * TransitionScale - ConstantFactor);
		[flatten]
		if (Settings.bTreatMaxDepthUnshadowed)
		{
			ShadowFactor = saturate(ShadowFactor + (ShadowmapDepth > .99f));
		}
		return ShadowFactor;
	}
}
float Manual1x1PCF(float2 ShadowPosition, FPCFSamplerSettings Settings)
{
	float2 TexelPos = ShadowPosition * Settings.ShadowBufferSize.xy - 0.5f;	
	float2 Fraction = frac(TexelPos);
	float4 Samples;
	float2 QuadCenter = floor(TexelPos) + 1.0f;	
	Samples = Settings.ShadowDepthTexture.Gather(Settings.ShadowDepthTextureSampler, QuadCenter * Settings.ShadowBufferSize.zw);
	float4 Values00 = CalculateOcclusion(Samples, Settings);
	return PCF1x1(Fraction, Values00);
}
float ComputeDirectionalLightStaticShadowing(float3 TranslatedWorldPosition)
{
	float ShadowFactor = 1;
	[branch]
	if (TranslucentBasePass.Shared_Forward_DirectionalLightUseStaticShadowing > 0)
	{
		float4 HomogeneousShadowPosition = mul(float4(TranslatedWorldPosition, 1), TranslucentBasePass.Shared_Forward_DirectionalLightTranslatedWorldToStaticShadow);
		float2 ShadowUVs = HomogeneousShadowPosition.xy / HomogeneousShadowPosition.w;
		if (all( and_internal( ShadowUVs >= 0 , ShadowUVs <= 1 )))
		{
				float ShadowDepth = Texture2DSampleLevel(TranslucentBasePass_Shared_Forward_DirectionalLightStaticShadowmap, TranslucentBasePass_Shared_Forward_StaticShadowmapSampler, ShadowUVs, 0).x;
				ShadowFactor = HomogeneousShadowPosition.z < ShadowDepth || ShadowDepth > .99f;
		}
	}
	return ShadowFactor;
}
uint GetForwardLightingCascadeIndex(float4 CascadeEndDepths, float SceneDepth)
{
	float4 Count = float4(SceneDepth.xxxx >= CascadeEndDepths);
	return uint(Count.x + Count.y + Count.z + Count.w);
}
float ComputeDirectionalLightDynamicShadowing(float3 TranslatedWorldPosition, float SceneDepth, inout bool bShadowingFromValidUVArea)
{
	float ShadowFactor = 1;
	bShadowingFromValidUVArea = false;
	const uint NumCascades = TranslucentBasePass.Shared_Forward_NumDirectionalLightCascades;
	if (NumCascades > 0)
	{
		uint CascadeIndex = GetForwardLightingCascadeIndex(TranslucentBasePass.Shared_Forward_CascadeEndDepths, SceneDepth);
		if (CascadeIndex < NumCascades)
		{
			float4 HomogeneousShadowPosition = mul(float4(TranslatedWorldPosition, 1), TranslucentBasePass.Shared_Forward_DirectionalLightTranslatedWorldToShadowMatrix[CascadeIndex]);
			float2 ShadowUVs = HomogeneousShadowPosition.xy / HomogeneousShadowPosition.w;
			float4 ShadowmapMinMax = TranslucentBasePass.Shared_Forward_DirectionalLightShadowmapMinMax[CascadeIndex];
			if (all( and_internal( ShadowUVs >= ShadowmapMinMax.xy , ShadowUVs <= ShadowmapMinMax.zw )))
			{
				FPCFSamplerSettings Settings;
				Settings.ShadowDepthTexture = TranslucentBasePass_Shared_Forward_DirectionalLightShadowmapAtlas;
				Settings.ShadowDepthTextureSampler = TranslucentBasePass_Shared_Forward_ShadowmapSampler;
				Settings.ShadowBufferSize = TranslucentBasePass.Shared_Forward_DirectionalLightShadowmapAtlasBufferSize;
				Settings.SceneDepth = 1 - HomogeneousShadowPosition.z;
				Settings.TransitionScale = 4000;
				Settings.bSubsurface = false;
				Settings.bTreatMaxDepthUnshadowed = false;
				Settings.DensityMulConstant = 0;
				Settings.ProjectionDepthBiasParameters = float2(0, 0);
				ShadowFactor = Manual1x1PCF(ShadowUVs, Settings);
				bShadowingFromValidUVArea = true;
			}
		}
	}
	return ShadowFactor;
}
bool IsSinglePageVirtualShadowMap(int VirtualShadowMapId)
{
	return VirtualShadowMapId < (1024U * 8U);
}
uint CalcLog2LevelDimsPages(uint Level)
{
	return 7 - Level;	
}
uint CalcLevelDimsTexels(uint Level)
{
	return uint(16384) >> Level;
}
uint CalcLevelOffsets(uint Level)
{
	uint NumBits = Level << 1;
	uint StartBit = (2 * 7 + 2) - NumBits;
	uint Mask = ((1u << NumBits) - 1u) << StartBit;
	return 0x55555555u & Mask;
}
struct FVirtualSMLevelOffset
{
	bool bIsSinglePageSM;
	uint LevelOffset;
};
uint CalcFullPageTableLevelOffset(uint VirtualShadowMapId, uint Level)
{
	 { };
	return (1024U * 8U) + (VirtualShadowMapId - (1024U * 8U)) * 21845 + CalcLevelOffsets(Level);
}
uint CalcPageOffsetInFullLevel(uint Level, uint2 PageAddress)
{
	return PageAddress.x + (PageAddress.y << CalcLog2LevelDimsPages(Level));
}
uint CalcPageOffset(FVirtualSMLevelOffset LevelOffset, uint Level, uint2 PageAddress)
{
	 { };
	uint Result = LevelOffset.LevelOffset;
	if (!LevelOffset.bIsSinglePageSM)
	{
		Result += CalcPageOffsetInFullLevel(Level, PageAddress);
	}
	return Result;
}
uint CalcPageOffset(uint VirtualShadowMapId, uint Level, uint2 PageAddress)
{
	if (IsSinglePageVirtualShadowMap(VirtualShadowMapId))
	{
		return VirtualShadowMapId;
	}
	return CalcFullPageTableLevelOffset(VirtualShadowMapId, Level) + CalcPageOffsetInFullLevel(Level, PageAddress);
}
struct FShadowPhysicalPage
{
	uint2 PhysicalAddress;	
	uint LODOffset;			
	bool bAnyLODValid;		
	bool bThisLODValid;		
};
FShadowPhysicalPage ShadowDecodePageTable(uint Value)
{
	FShadowPhysicalPage Result;
	Result.PhysicalAddress = uint2(Value & 0x3FF, (Value >> 10) & 0x3FF);
	Result.LODOffset = (Value >> 20) & 0x3F;
	Result.bAnyLODValid = (Value & 0x80000000) != 0;
	Result.bThisLODValid = Result.bAnyLODValid && Result.LODOffset == 0;
	return Result;
}
FShadowPhysicalPage ShadowGetPhysicalPage(uint PageOffset)
{
	return ShadowDecodePageTable(VirtualShadowMap_PageTable[PageOffset]);
}
struct FVirtualShadowMapProjectionShaderData
{
	float4x4 ShadowViewToClipMatrix;
	float4x4 TranslatedWorldToShadowUVMatrix;
	float4x4 TranslatedWorldToShadowUVNormalMatrix;
	float3 LightDirection;
	uint LightType;		
	FDFVector3 PreViewTranslation;
	float LightRadius;
	float ResolutionLodBias;
	float3 ClipmapWorldOriginOffset; 
	int2 ClipmapCornerRelativeOffset;
	int ClipmapLevel;					
	int ClipmapLevelCountRemaining;		
	uint Flags;
	float ClipmapLevelWPODistanceDisabledThresholdSquared;
	float LightSourceRadius;
	int VirtualShadowMapId;
	bool bUnCached; 
	bool bUnreferenced; 
	float TexelDitherScale; 
};
FVirtualShadowMapProjectionShaderData DecodeVirtualShadowMapProjectionData(ByteAddressBuffer ProjectionData, int VirtualShadowMapId)
{
	FVirtualShadowMapProjectionShaderData Result;
	Result.VirtualShadowMapId = VirtualShadowMapId;
	const uint Stride = 16 * 18;
	const uint Base = VirtualShadowMapId * Stride;
	Result.ShadowViewToClipMatrix[0]				= asfloat(ProjectionData.Load4(Base + 16*0));
	Result.ShadowViewToClipMatrix[1]				= asfloat(ProjectionData.Load4(Base + 16*1));
	Result.ShadowViewToClipMatrix[2]				= asfloat(ProjectionData.Load4(Base + 16*2));
	Result.ShadowViewToClipMatrix[3]				= asfloat(ProjectionData.Load4(Base + 16*3));
	Result.TranslatedWorldToShadowUVMatrix[0]		= asfloat(ProjectionData.Load4(Base + 16*4));
	Result.TranslatedWorldToShadowUVMatrix[1]		= asfloat(ProjectionData.Load4(Base + 16*5));
	Result.TranslatedWorldToShadowUVMatrix[2]		= asfloat(ProjectionData.Load4(Base + 16*6));
	Result.TranslatedWorldToShadowUVMatrix[3]		= asfloat(ProjectionData.Load4(Base + 16*7));
	Result.TranslatedWorldToShadowUVNormalMatrix[0]	= asfloat(ProjectionData.Load4(Base + 16*8));
	Result.TranslatedWorldToShadowUVNormalMatrix[1]	= asfloat(ProjectionData.Load4(Base + 16*9));
	Result.TranslatedWorldToShadowUVNormalMatrix[2]	= asfloat(ProjectionData.Load4(Base + 16*10));
	Result.TranslatedWorldToShadowUVNormalMatrix[3]	= asfloat(ProjectionData.Load4(Base + 16*11));
	Result.LightDirection					= asfloat(ProjectionData.Load3(Base + (16*12 + 4*0)));
	Result.LightType						=		 (ProjectionData.Load (Base + (16*12 + 4*3)));
	float3 PreViewTranslationHigh			= asfloat(ProjectionData.Load3(Base + (16*13 + 4*0)));
	Result.LightRadius						= asfloat(ProjectionData.Load (Base + (16*13 + 4*3)));
	float3 PreViewTranslationLow			= asfloat(ProjectionData.Load3(Base + (16*14 + 4*0)));
	Result.ResolutionLodBias				= asfloat(ProjectionData.Load (Base + (16*14 + 4*3)));
	float3 NegativeClipmapWorldOriginOffset = asfloat(ProjectionData.Load3(Base + (16*15 + 4*0)));
	Result.LightSourceRadius				= asfloat(ProjectionData.Load (Base + (16*15 + 4*3)));
	Result.ClipmapCornerRelativeOffset		= asint  (ProjectionData.Load2(Base + (16*16 + 4*0)));
	Result.ClipmapLevel						= asint  (ProjectionData.Load (Base + (16*16 + 4*2)));
	Result.ClipmapLevelCountRemaining		= asint  (ProjectionData.Load (Base + (16*16 + 4*3)));
	Result.Flags 							=		 (ProjectionData.Load (Base + (16*17 + 4*0)));
	Result.ClipmapLevelWPODistanceDisabledThresholdSquared
		                                    = asfloat(ProjectionData.Load (Base + (16*17 + 4*1)));
	Result.TexelDitherScale					= asfloat(ProjectionData.Load (Base + (16*17 + 4*2)));
	Result.PreViewTranslation				= MakeDFVector3(PreViewTranslationHigh, PreViewTranslationLow);
	Result.ClipmapWorldOriginOffset			= -NegativeClipmapWorldOriginOffset;
	Result.bUnCached = (Result.Flags & (1U << 1)) != 0U;
	Result.bUnreferenced = (Result.Flags & (1U << 2)) != 0U;
	return Result;
}
FVirtualShadowMapProjectionShaderData GetVirtualShadowMapProjectionData(int VirtualShadowMapId)
{
	return DecodeVirtualShadowMapProjectionData(VirtualShadowMap_ProjectionData, VirtualShadowMapId);
}
float CalcAbsoluteClipmapLevel(FVirtualShadowMapProjectionShaderData BaseProjectionData, float3 TranslatedWorldPosition)
{
	float3 ViewToShadowTranslation = DFFastLocalSubtractDemote(BaseProjectionData.PreViewTranslation, GetPrimaryView().PreViewTranslation);
	float3 TranslatedWorldOrigin = -BaseProjectionData.ClipmapWorldOriginOffset + ViewToShadowTranslation;
	float DistanceToClipmapOrigin = length(TranslatedWorldPosition + TranslatedWorldOrigin);
	return log2(DistanceToClipmapOrigin);
}
float CalcBiasedAbsoluteClipmapLevelForSampling(FVirtualShadowMapProjectionShaderData BaseProjectionData, float3 TranslatedWorldPosition)
{
	float AbsoluteLevel = CalcAbsoluteClipmapLevel(BaseProjectionData, TranslatedWorldPosition);
	AbsoluteLevel += VirtualShadowMap.bClipmapGreedyLevelSelection ? 0.0f : BaseProjectionData.ResolutionLodBias;
	return AbsoluteLevel;
}
struct FVirtualShadowMapSample
{
	float Depth;
	uint MipLevel;
	int VirtualShadowMapId;		
	bool bValid;
	uint2 VirtualTexelAddress;
	float2 VirtualTexelAddressFloat;
	uint2 PhysicalTexelAddress;
};
FVirtualShadowMapSample InitVirtualShadowMapSample()
{
	FVirtualShadowMapSample Result;
	Result.Depth = 0.0f;
	Result.MipLevel = 0;
	Result.VirtualShadowMapId = -1; 
	Result.bValid = false;
	Result.VirtualTexelAddress = Result.PhysicalTexelAddress = uint2(0U, 0U);
	Result.VirtualTexelAddressFloat = float2(0.0f, 0.0f);
	return Result;
}
float SampleVirtualShadowMapPhysicalDepth(uint2 PhysicalTexelAddress)
{
	return asfloat(VirtualShadowMap_PhysicalPagePool.Load(uint4(PhysicalTexelAddress, 0, 0)));
}
struct FVirtualShadowMapClipmapRelativeTransform
{
	float Scale;
	float3 Bias;
};
FVirtualShadowMapClipmapRelativeTransform CalcClipmapRelativeTransform(int ClipmapId, int LevelOffset)
{
	const FVirtualShadowMapProjectionShaderData ProjectionDataA = GetVirtualShadowMapProjectionData(ClipmapId);
	const FVirtualShadowMapProjectionShaderData ProjectionDataB = GetVirtualShadowMapProjectionData(ClipmapId + LevelOffset);
	float2 OffsetA = float2(ProjectionDataA.ClipmapCornerRelativeOffset);
	float2 OffsetB = float2(ProjectionDataB.ClipmapCornerRelativeOffset);
	FVirtualShadowMapClipmapRelativeTransform Result;
	Result.Scale = LevelOffset >= 0 ? rcp(float(1U << LevelOffset)) : float(1U << (-LevelOffset));
	Result.Bias.xy = 0.25f * (OffsetB - Result.Scale * OffsetA);
	float OffsetZA = ProjectionDataA.ShadowViewToClipMatrix[3][2];
	float OffsetZB = ProjectionDataB.ShadowViewToClipMatrix[3][2];
	Result.Bias.z = OffsetZB - Result.Scale * OffsetZA;
	return Result;
}
uint2 CalcClipmapOffsetLevelPage(uint2 BasePage, int ClipmapId, uint LevelOffset)
{
	const FVirtualShadowMapProjectionShaderData ProjectionDataA = GetVirtualShadowMapProjectionData(ClipmapId);
	const FVirtualShadowMapProjectionShaderData ProjectionDataB = GetVirtualShadowMapProjectionData(ClipmapId + LevelOffset);
	const int OffsetScale = (128 >> 2);
	int2 BasePageOffset  = OffsetScale * ProjectionDataA.ClipmapCornerRelativeOffset;
	int2 LevelPageOffset = OffsetScale * ProjectionDataB.ClipmapCornerRelativeOffset;
	return (BasePage - BasePageOffset + (LevelPageOffset << LevelOffset)) >> LevelOffset;
}
FVirtualShadowMapSample SampleVirtualShadowMapClipmap(int VirtualShadowMapId, float2 ShadowMapUV)
{
	FVirtualShadowMapSample Result = InitVirtualShadowMapSample();
	uint2 BasePage = uint2(ShadowMapUV * 128);
	FShadowPhysicalPage PhysicalPageEntry = ShadowGetPhysicalPage(CalcPageOffset(VirtualShadowMapId, 0, BasePage));
	if (PhysicalPageEntry.bAnyLODValid)
	{	
		uint ClipmapLevelOffset = PhysicalPageEntry.LODOffset;
		int ClipmapLevelId = VirtualShadowMapId + ClipmapLevelOffset;
		Result.VirtualTexelAddressFloat = ShadowMapUV * float(CalcLevelDimsTexels(0));
		Result.VirtualTexelAddress = uint2(Result.VirtualTexelAddressFloat);
		float DepthLevelScale = 1.0f;
		float DepthLevelBias = 0.0f;
		if (ClipmapLevelOffset > 0)
		{
			uint2 vPage = CalcClipmapOffsetLevelPage(BasePage, VirtualShadowMapId, ClipmapLevelOffset);
			uint2 VirtualTexelAddressMin = vPage * 128;
			uint2 VirtualTexelAddressMax = VirtualTexelAddressMin + (128 - 1);
			FVirtualShadowMapClipmapRelativeTransform Transform = CalcClipmapRelativeTransform(VirtualShadowMapId, ClipmapLevelOffset);
			float2 ClipmapUV = ShadowMapUV * Transform.Scale + Transform.Bias.xy;
			DepthLevelScale = Transform.Scale;
			DepthLevelBias = Transform.Bias.z;
			Result.VirtualTexelAddressFloat = ClipmapUV * float(CalcLevelDimsTexels(0));
			Result.VirtualTexelAddress = clamp(uint2(Result.VirtualTexelAddressFloat), VirtualTexelAddressMin, VirtualTexelAddressMax);
			PhysicalPageEntry = ShadowGetPhysicalPage(CalcPageOffset(ClipmapLevelId, 0, vPage));
		}
		if (PhysicalPageEntry.bThisLODValid)
		{
			Result.PhysicalTexelAddress = 
				PhysicalPageEntry.PhysicalAddress * 128 +
				(Result.VirtualTexelAddress & 127);
			Result.Depth = (SampleVirtualShadowMapPhysicalDepth(Result.PhysicalTexelAddress) - DepthLevelBias) / DepthLevelScale;
			Result.MipLevel = 0;
			Result.VirtualShadowMapId = ClipmapLevelId;
			Result.bValid = true;
		}
	}
	return Result;
}
float ComputeVirtualShadowMapOptimalSlopeBias(
	int RequestedVirtualShadowMapId,
	FVirtualShadowMapSample SmSample,
	float3 TranslatedWorldPosition,
	float3 EstimatedGeoWorldNormal,
	bool bClamp = true)
{
	FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(SmSample.VirtualShadowMapId);
	float4 NormalPlaneTranslatedWorld = float4(EstimatedGeoWorldNormal, -dot(EstimatedGeoWorldNormal, TranslatedWorldPosition));
	float4 NormalPlaneUV = mul(NormalPlaneTranslatedWorld, ProjectionData.TranslatedWorldToShadowUVNormalMatrix);
	float2 DepthSlopeUV = -NormalPlaneUV.xy / NormalPlaneUV.z;
	float MipLevelDim = float(CalcLevelDimsTexels(SmSample.MipLevel));
	float2 TexelCenter = float2(SmSample.VirtualTexelAddress) + 0.5f;
	float2 TexelCenterOffset = TexelCenter - SmSample.VirtualTexelAddressFloat;
	float2 TexelCenterOffsetUV = TexelCenterOffset / MipLevelDim;
	float OptimalSlopeBias = 2.0f * max(0.0f, dot(DepthSlopeUV, TexelCenterOffsetUV));
	OptimalSlopeBias = bClamp ? min(OptimalSlopeBias, abs(100.0f * ProjectionData.ShadowViewToClipMatrix._33)) : OptimalSlopeBias;
	OptimalSlopeBias *= float(1u << (SmSample.VirtualShadowMapId - RequestedVirtualShadowMapId));
	return OptimalSlopeBias;
}
float ComputeOccluderDistanceOrtho(float4x4 ShadowViewToClip, float OccluderDepth, float ReceiverDepth)
{
	float OccluderViewZ = (OccluderDepth - ShadowViewToClip._43) / ShadowViewToClip._33;
	float ReceiverViewZ = (ReceiverDepth - ShadowViewToClip._43) / ShadowViewToClip._33;
	float Result = ReceiverViewZ - OccluderViewZ;
	return max(1e-6f, Result);
}
struct FVirtualShadowMapSampleResult
{
	bool bValid;
	float ShadowFactor;	
	float OccluderDistance;
	int ClipmapOrMipLevel;		
	uint RayCount;
	uint2 VirtualTexelAddress;
	uint2 PhysicalTexelAddress;
	float3 GeneralDebug;		
};
FVirtualShadowMapSampleResult InitVirtualShadowMapSampleResult()
{
	FVirtualShadowMapSampleResult Result;
	Result.bValid = false;
	Result.ShadowFactor = 1.0f;
	Result.OccluderDistance = -1.0f;
	Result.ClipmapOrMipLevel = 0;
	Result.VirtualTexelAddress = uint2(0xFFFFFFFF, 0xFFFFFFFF);
	Result.PhysicalTexelAddress = uint2(0xFFFFFFFF, 0xFFFFFFFF);
	Result.RayCount = 0;
	Result.GeneralDebug = float3(0, 0, 0);
	return Result;
}
FVirtualShadowMapSampleResult SampleVirtualShadowMapDirectional(
	int VirtualShadowMapId,
	float3 TranslatedWorldPosition,
	float RayStartDistance,
	float3 EstimatedGeoWorldNormal,
	bool bUseOptimalBias = true)
{
	RayStartDistance = max(RayStartDistance, 0.0f);
	FVirtualShadowMapProjectionShaderData BaseProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapId);
	 { };
	const int ClipmapLevel = int(floor(CalcBiasedAbsoluteClipmapLevelForSampling(BaseProjectionData, TranslatedWorldPosition)));
	int ClipmapIndex = max(0, ClipmapLevel - BaseProjectionData.ClipmapLevel);
	if (ClipmapIndex < BaseProjectionData.ClipmapLevelCountRemaining)
	{
		int ClipmapLevelVirtualShadowMapId = VirtualShadowMapId + ClipmapIndex;
		FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(ClipmapLevelVirtualShadowMapId);
		float3 ViewToShadowTranslation = DFFastLocalSubtractDemote(ProjectionData.PreViewTranslation, GetPrimaryView().PreViewTranslation);
		float3 ShadowTranslatedWorldPosition = TranslatedWorldPosition + ViewToShadowTranslation;
		float4 ShadowUVz = mul(float4(ShadowTranslatedWorldPosition, 1.0f), ProjectionData.TranslatedWorldToShadowUVMatrix);
		FVirtualShadowMapSample SmSample;
		SmSample = SampleVirtualShadowMapClipmap(ClipmapLevelVirtualShadowMapId, ShadowUVz.xy);
		if (SmSample.bValid)
		{
			int SampledClipmapIndex = SmSample.VirtualShadowMapId - VirtualShadowMapId;
			FVirtualShadowMapSampleResult Result = InitVirtualShadowMapSampleResult();
			Result.bValid = true;
			Result.ShadowFactor = 1.0f;
			Result.OccluderDistance = -1.0f;
			Result.ClipmapOrMipLevel = GetVirtualShadowMapProjectionData(SmSample.VirtualShadowMapId).ClipmapLevel;
			Result.VirtualTexelAddress = SmSample.VirtualTexelAddress;
			Result.PhysicalTexelAddress = SmSample.PhysicalTexelAddress;
			Result.RayCount = 1;
			float OptimalSlopeBias = 0.0f;
			[branch]
			if (bUseOptimalBias)
			{
				OptimalSlopeBias = ComputeVirtualShadowMapOptimalSlopeBias(ClipmapLevelVirtualShadowMapId, SmSample, ShadowTranslatedWorldPosition, EstimatedGeoWorldNormal);
			}
			float RayStartBias = -RayStartDistance * ProjectionData.ShadowViewToClipMatrix._33;
			float BiasedDepth = SmSample.Depth - OptimalSlopeBias - RayStartBias;
			if (BiasedDepth > ShadowUVz.z)
			{
				Result.ShadowFactor = 0.0f;
				Result.OccluderDistance = ComputeOccluderDistanceOrtho(
					ProjectionData.ShadowViewToClipMatrix,
					SmSample.Depth,
					ShadowUVz.z);
			}
			return Result;
		}
	}
	return InitVirtualShadowMapSampleResult();
}
FVirtualShadowMapSampleResult SampleVirtualShadowMapDirectional(int VirtualShadowMapId, float3 TranslatedWorldPosition, float RayStartDistance = 0.0f)
{
	return SampleVirtualShadowMapDirectional(VirtualShadowMapId, TranslatedWorldPosition, RayStartDistance, float3(0, 0, 0), false);
}
float PrevSceneColorPreExposureInv;
FDeferredLightingSplit GetForwardDirectLightingSplit(
	uint2 PixelPos,
	uint GridIndex, float3 TranslatedWorldPosition, float3 CameraVector, FGBufferData GBufferData, float2 ScreenUV, uint PrimitiveId, uint EyeIndex, float Dither, 
	float InDirectionalLightCloudShadow, float3 InDirectionalLightAtmosphereTransmittance, inout float OutDirectionalLightShadow,
	bool bSeparateMainDirLightLuminance, inout float3 SeparatedMainDirLightLuminance, bool bSkipDirLightVirtualShadowMapEvaluation)
{
	float3 WorldPosition = TranslatedWorldPosition - DFDemote(GetPrimaryView().PreViewTranslation);
	float4 DynamicShadowFactors = 1;
	FDeferredLightingSplit DirectLighting;
	DirectLighting.DiffuseLighting = 0;
	DirectLighting.SpecularLighting = 0;
	float SpecularScale = 1;
	uint LightingChannelMask = GetPrimitive_LightingChannelMask(PrimitiveId);
	const FDirectionalLightData DirectionalLightData = GetDirectionalLightData(EyeIndex);
	[branch]
	if (DirectionalLightData.HasDirectionalLight)
	{
		float4 PreviewShadowMapChannelMask = 1;
		uint  DirLightingChannelMask = 0x7;
		FDeferredLightData LightData = ConvertToDeferredLight(DirectionalLightData, SpecularScale, PreviewShadowMapChannelMask, DirLightingChannelMask);
			LightData.ShadowedBits = 1;
			LightData.ShadowMapChannelMask.x = 1;
				GBufferData.PrecomputedShadowFactors.x = ComputeDirectionalLightStaticShadowing(TranslatedWorldPosition).x;
			bool bUnused = false;
			float DynamicShadowFactor = ComputeDirectionalLightDynamicShadowing(TranslatedWorldPosition, GBufferData.Depth, bUnused);
			[branch]
			if ( !bSkipDirLightVirtualShadowMapEvaluation && TranslucentBasePass.Shared_Forward_DirectionalLightVSM != -1 )
			{
				{
					FVirtualShadowMapSampleResult VirtualShadowMapSample = SampleVirtualShadowMapDirectional( TranslucentBasePass.Shared_Forward_DirectionalLightVSM, TranslatedWorldPosition );
					DynamicShadowFactor *= VirtualShadowMapSample.ShadowFactor;
				}
			}
			float4 LightAttenuation = float4(DynamicShadowFactor.x, DynamicShadowFactor.x, 1, 1);
		FDeferredLightingSplit NewLighting = GetDynamicLightingSplit(TranslatedWorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, Dither, uint2(0,0), OutDirectionalLightShadow);
		[flatten]
		if (DirLightingChannelMask & LightingChannelMask)
		{
			NewLighting.DiffuseLighting.rgb *= InDirectionalLightAtmosphereTransmittance;
			NewLighting.SpecularLighting.rgb *= InDirectionalLightAtmosphereTransmittance;
			if (bSeparateMainDirLightLuminance)
			{
				SeparatedMainDirLightLuminance += NewLighting.DiffuseLighting.rgb;
				SeparatedMainDirLightLuminance += NewLighting.SpecularLighting.rgb;
			}
			else
			{
				DirectLighting.DiffuseLighting += NewLighting.DiffuseLighting;
				DirectLighting.SpecularLighting += NewLighting.SpecularLighting;
			}
		}
	}
	const FCulledLightsGridData CulledLightsGrid = GetCulledLightsGrid(GridIndex, EyeIndex);
	const uint NumLightsInGridCell = min(CulledLightsGrid.NumLights, GetMaxLightsPerCell(EyeIndex));
	[loop]
	for (uint GridLightListIndex = 0; GridLightListIndex < NumLightsInGridCell; GridLightListIndex++)
	{
		float4 PreviewShadowMapChannelMask = 1;
		uint  LocalLightingChannelMask = 0x7;
		const FLocalLightData LocalLight = GetLocalLightData(CulledLightsGrid.DataStartIndex + GridLightListIndex, EyeIndex);
		FDeferredLightData LightData = ConvertToDeferredLight(LocalLight, SpecularScale, PreviewShadowMapChannelMask, LocalLightingChannelMask);
		LightData.bRectLight = LightData.bRectLight && 0;
		float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);
		float4 LightAttenuation = float4(1, 1, DynamicShadowing.x, DynamicShadowing.x);
		float SurfaceShadow = 1.0f;
		FDeferredLightingSplit NewLighting = GetDynamicLightingSplit(TranslatedWorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, Dither, uint2(0,0), SurfaceShadow);
		[flatten]
		if (LocalLightingChannelMask & LightingChannelMask)
		{
			DirectLighting.DiffuseLighting += NewLighting.DiffuseLighting;
			DirectLighting.SpecularLighting += NewLighting.SpecularLighting;
		}
	}
	if (TranslucentBasePass.Shared_Forward_DirectLightingShowFlag == 0)
	{
		DirectLighting.DiffuseLighting = 0.0f;
		DirectLighting.SpecularLighting = 0.0f;
	}
	return DirectLighting;
}
float3 CompositeReflectionCapturesAndSkylightTWS(
	float CompositeAlpha, 
	float3 TranslatedWorldPosition, 
	float3 RayDirection, 
	float Roughness, 
	float IndirectIrradiance, 
	float IndirectSpecularOcclusion,
	float3 ExtraIndirectSpecular,
	uint NumCapturesAffectingTile,
	uint CaptureDataStartIndex, 
	int SingleCaptureIndex,
	bool bCompositeSkylight,
	uint EyeIndex)
{
	float Mip = ComputeReflectionCaptureMipFromRoughness(Roughness, View.ReflectionCubemapMaxMip);
	float4 ImageBasedReflections = float4(0, 0, 0, CompositeAlpha);
	float2 CompositedAverageBrightness = float2(0.0f, 1.0f);
	[loop]
	for (uint TileCaptureIndex = 0; TileCaptureIndex < NumCapturesAffectingTile; TileCaptureIndex++) 
	{
		[branch]
		if (ImageBasedReflections.a < 0.001)
		{
			break;
		}
		uint CaptureIndex = 0;
			CaptureIndex = GetCulledLightDataGrid(CaptureDataStartIndex + TileCaptureIndex);
		FDFVector3 CaptureWorldPosition = MakeDFVector3( ReflectionCaptureSM5.PositionHighAndRadius[ CaptureIndex ].xyz,  ReflectionCaptureSM5.PositionLow[ CaptureIndex ].xyz);
		float3 CaptureTranslatedWorldPosition = DFFastAddDemote(CaptureWorldPosition, ResolvedView.PreViewTranslation);
		float CaptureRadius =  ReflectionCaptureSM5.PositionHighAndRadius[ CaptureIndex ].w;
		float4 CaptureProperties =  ReflectionCaptureSM5.CaptureProperties[ CaptureIndex ];
		float3 CaptureVector = TranslatedWorldPosition - CaptureTranslatedWorldPosition;
		float CaptureVectorLength = sqrt(dot(CaptureVector, CaptureVector));		
		float NormalizedDistanceToCapture = saturate(CaptureVectorLength / CaptureRadius);
		[branch]
		if (CaptureVectorLength < CaptureRadius)
		{
			float3 ProjectedCaptureVector = RayDirection;
			float4 CaptureOffsetAndAverageBrightness =  ReflectionCaptureSM5.CaptureOffsetAndAverageBrightness[ CaptureIndex ];
			float DistanceAlpha = 0;
					[branch] if (CaptureProperties.b > 0)
					{
						ProjectedCaptureVector = GetLookupVectorForBoxCapture(RayDirection, TranslatedWorldPosition, float4(CaptureTranslatedWorldPosition, CaptureRadius),
																			  ReflectionCaptureSM5.BoxTransform[ CaptureIndex ],  ReflectionCaptureSM5.BoxScales[ CaptureIndex ], CaptureOffsetAndAverageBrightness.xyz, DistanceAlpha);
					}
					else
					{
						ProjectedCaptureVector = GetLookupVectorForSphereCapture(RayDirection, TranslatedWorldPosition, float4(CaptureTranslatedWorldPosition, CaptureRadius), NormalizedDistanceToCapture, CaptureOffsetAndAverageBrightness.xyz, DistanceAlpha);
					}
			float CaptureArrayIndex = CaptureProperties.g;
			{
				float4 Sample = TranslucentBasePass_Shared_Reflection_ReflectionCubemap.SampleLevel(TranslucentBasePass_Shared_Reflection_ReflectionCubemapSampler, float4(ProjectedCaptureVector, CaptureArrayIndex), Mip);
				Sample.rgb *= CaptureProperties.r;
				Sample *= DistanceAlpha;
				ImageBasedReflections.rgb += Sample.rgb * ImageBasedReflections.a * IndirectSpecularOcclusion;
				ImageBasedReflections.a *= 1 - Sample.a;
				float AverageBrightness = CaptureOffsetAndAverageBrightness.w;
				CompositedAverageBrightness.x += AverageBrightness * DistanceAlpha * CompositedAverageBrightness.y;
				CompositedAverageBrightness.y *= 1 - DistanceAlpha;
			}
		}
	}
	ImageBasedReflections.rgb *= View.PrecomputedIndirectSpecularColorScale;
	CompositedAverageBrightness.x *= Luminance( View.PrecomputedIndirectSpecularColorScale );
	[branch]  
	if (TranslucentBasePass.Shared_Reflection_SkyLightParameters.y > 0 && bCompositeSkylight)
	{
		float SkyAverageBrightness = 1.0f;
			float3 SkyLighting = GetSkyLightReflection(RayDirection, Roughness, SkyAverageBrightness);
		bool bNormalize = TranslucentBasePass.Shared_Reflection_SkyLightParameters.z < 1 && 1;
		[flatten]
		if (bNormalize)
		{
			ImageBasedReflections.rgb += ImageBasedReflections.a * SkyLighting * IndirectSpecularOcclusion;
			CompositedAverageBrightness.x += SkyAverageBrightness * CompositedAverageBrightness.y;
		}
		else
		{
			ExtraIndirectSpecular += SkyLighting * IndirectSpecularOcclusion;
		}
	}
	ImageBasedReflections.rgb *= ComputeMixingWeight(IndirectIrradiance, CompositedAverageBrightness.x, Roughness);
	ImageBasedReflections.rgb += ImageBasedReflections.a * ExtraIndirectSpecular;
	return ImageBasedReflections.rgb;
}
float3 CompositeReflectionCapturesAndSkylightTWS(
	float CompositeAlpha, 
	float3 TranslatedWorldPosition, 
	float3 RayDirection, 
	float Roughness, 
	float IndirectIrradiance, 
	float IndirectSpecularOcclusion,
	float3 ExtraIndirectSpecular,
	uint NumCapturesAffectingTile,
	uint CaptureDataStartIndex,
	int SingleCaptureIndex,
	bool bCompositeSkylight)
{
	return CompositeReflectionCapturesAndSkylightTWS(
		CompositeAlpha, 
		TranslatedWorldPosition, 
		RayDirection, 
		Roughness, 
		IndirectIrradiance, 
		IndirectSpecularOcclusion, 
		ExtraIndirectSpecular, 
		NumCapturesAffectingTile, 
		CaptureDataStartIndex,
		SingleCaptureIndex,
		bCompositeSkylight,
		0);
}
float3 GetImageBasedReflectionSpecular(FMaterialPixelParameters MaterialParameters, float3 RayDirection, float Roughness, float IndirectIrradiance, uint GridIndex, int SingleCaptureIndex, uint EyeIndex)
{
	float3 SpecularIBL;
	bool bUseLumenFrontLayerReflection = false;
	bUseLumenFrontLayerReflection = UseFrontLayerReflection(MaterialParameters.ViewBufferUV, MaterialParameters.ScreenPosition.w) && !0;
	FRadianceCacheCoverage LumenRadianceCacheCoverage = InitRadianceCacheCoverage();
	LumenRadianceCacheCoverage.bValid = false;
	if (TranslucentBasePass.FinalProbeResolution > 0 && !bUseLumenFrontLayerReflection)
	{
		float ClipmapDitherRandom = InterleavedGradientNoise(MaterialParameters.SvPosition.xy, View.StateFrameIndexMod8);
		LumenRadianceCacheCoverage = GetRadianceCacheCoverage(LWCToFloat(GetWorldPosition(MaterialParameters)), RayDirection, ClipmapDitherRandom);
	}
	if (bUseLumenFrontLayerReflection)
	{
		SpecularIBL = SampleFrontLayerReflection(MaterialParameters.ViewBufferUV);
	}
	else if (LumenRadianceCacheCoverage.bValid)
	{
		float ConeHalfAngle = 0;
		SpecularIBL = SampleRadianceCacheInterpolated(LumenRadianceCacheCoverage, LWCToFloat(GetWorldPosition(MaterialParameters)), RayDirection, ConeHalfAngle);
	}
	else
	{
		uint NumLocalReflectionCaptures = 0;
		uint DataStartIndex = 0;
				uint NumCulledEntryIndex = (TranslucentBasePass.Shared_Forward_NumGridCells + GridIndex) * 2;
				NumLocalReflectionCaptures = min(TranslucentBasePass_Shared_Forward_NumCulledLightsGrid[NumCulledEntryIndex + 0], TranslucentBasePass.Shared_Forward_NumReflectionCaptures);
				DataStartIndex = TranslucentBasePass_Shared_Forward_NumCulledLightsGrid[NumCulledEntryIndex + 1];
		const bool bCompositeSkylight = true;
		SpecularIBL = CompositeReflectionCapturesAndSkylightTWS(
			1.0f, 
			MaterialParameters.WorldPosition_CamRelative, 
			RayDirection, 
			Roughness, 
			IndirectIrradiance, 
			1.0f, 
			0.0f, 
			NumLocalReflectionCaptures, 
			DataStartIndex, 
			SingleCaptureIndex,
			bCompositeSkylight,
			EyeIndex);
	}
	if( View.CameraCut == 0 && TranslucentBasePass.SSRQuality > 0 && !bUseLumenFrontLayerReflection)
	{
		float StepOffset = InterleavedGradientNoise( MaterialParameters.SvPosition.xy, View.StateFrameIndexMod8 );
		StepOffset -= 0.5;
		bool bDebugPrint = false;
		float3 HitUVz;
		float Level = 0;
		bool bHit = RayCast(
			TranslucentBasePass_HZBTexture, TranslucentBasePass_HZBSampler,
			MaterialParameters.WorldPosition_CamRelative, RayDirection, Roughness, MaterialParameters.ScreenPosition.w,
			12, StepOffset,
			TranslucentBasePass.HZBUvFactorAndInvFactor,
			bDebugPrint,
			HitUVz,
			Level
		);
		[branch] if( bHit )
		{
			float2 SampleUV;
			float Vignette;
			ReprojectHit(TranslucentBasePass.PrevScreenPositionScaleBias, HitUVz, SampleUV, Vignette);
			SampleUV = clamp(SampleUV, TranslucentBasePass.PrevSceneColorBilinearUVMin, TranslucentBasePass.PrevSceneColorBilinearUVMax);
			float4 SSR = SampleScreenColor( 
				TranslucentBasePass_PrevSceneColor, 
				TranslucentBasePass_PrevSceneColorSampler,  
				SampleUV);
			SSR *= Vignette * saturate( 2 - 6.6 * Roughness );
			SSR.rgb *= TranslucentBasePass.PrevSceneColorPreExposureInv;
			SpecularIBL.rgb = SpecularIBL.rgb * (1 - SSR.a) + SSR.rgb;
		}
	}
	float3 SpecularLighting = SpecularIBL.rgb;
	[branch]
	if (abs(dot(TranslucentBasePass.Shared_PlanarReflection_ReflectionPlane.xyz, 1)) > .0001f)
	{
		float4 PlanarReflection = ComputePlanarReflections(MaterialParameters.WorldPosition_CamRelative, MaterialParameters.WorldNormal, Roughness, TranslucentBasePass_Shared_Reflection_ReflectionCubemapSampler);
		SpecularLighting = PlanarReflection.rgb + (1 - PlanarReflection.a) * SpecularLighting;
	}
	return SpecularLighting;
}
float3 GetImageBasedReflectionLighting(FMaterialPixelParameters MaterialParameters, float Roughness, float3 SpecularColor, float IndirectIrradiance, uint GridIndex, int SingleCaptureIndex, uint EyeIndex)
{
	float3 N = MaterialParameters.WorldNormal;
	float3 V = MaterialParameters.CameraVector;
	float3 RayDirection = 2 * dot(V, N) * N - V;
	float NoV = saturate(dot(N, V));
	const float3 SpecularLighting = GetImageBasedReflectionSpecular(MaterialParameters, RayDirection, Roughness, IndirectIrradiance, GridIndex, SingleCaptureIndex, EyeIndex);
	SpecularColor = EnvBRDFApprox(SpecularColor, Roughness, NoV);
	return SpecularLighting * SpecularColor;
}
float3 GetImageBasedReflectionLighting(FMaterialPixelParameters MaterialParameters, float Roughness, float3 SpecularColor, float IndirectIrradiance, uint GridIndex, int SingleCaptureIndex)
{
	return GetImageBasedReflectionLighting(MaterialParameters, Roughness, SpecularColor, IndirectIrradiance, GridIndex, SingleCaptureIndex, 0);
}
void GetSkyLighting(FMaterialPixelParameters MaterialParameters, float LightmapVTPageTableResult, bool bEvaluateBackface, float3 WorldNormal, float2 LightmapUV, uint LightmapDataIndex, float3 SkyOcclusionUV3D, out float3 OutDiffuseLighting, out float3 OutSubsurfaceLighting)
{
	OutDiffuseLighting = 0;
	OutSubsurfaceLighting = 0;
	if (IsLumenTranslucencyGIEnabled())
	{
		FTwoBandSHVectorRGB TranslucencyGISH = GetTranslucencyGIVolumeLighting(MaterialParameters.AbsoluteWorldPosition, ResolvedView.WorldToClip, true);
			FTwoBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH(WorldNormal, 1);
			OutDiffuseLighting += max(float3(0,0,0), DotSH(TranslucencyGISH, DiffuseTransferSH)) / PI;
	}
	else
	if (TranslucentBasePass.Shared_UseBasePassSkylight > 0)
	{
		float SkyVisibility = 1;
		float GeometryTerm = 1;
		float3 SkyLightingNormal = WorldNormal;
		float3 DiffuseLookup = GetSkySHDiffuse(SkyLightingNormal) * ResolvedView.SkyLightColor.rgb;
		OutDiffuseLighting += DiffuseLookup * (SkyVisibility * GeometryTerm);
	}
}
void GetPrecomputedIndirectLightingAndSkyLight(
	FMaterialPixelParameters MaterialParameters, 
	FVertexFactoryInterpolantsVSToPS Interpolants,
	FSharedBasePassInterpolants BasePassInterpolants,
	float LightmapVTPageTableResult,
	bool bEvaluateBackface,
	float3 DiffuseDir,
	float3 VolumetricLightmapBrickTextureUVs,
	out float3 OutDiffuseLighting,
	out float3 OutSubsurfaceLighting,
	out float OutIndirectIrradiance)
{
	OutIndirectIrradiance = 0;
	OutDiffuseLighting = 0;
	OutSubsurfaceLighting = 0;
	float2 SkyOcclusionUV = (float2)0;
	uint SkyOcclusionDataIndex = 0u;
	OutDiffuseLighting *= View.PrecomputedIndirectLightingColorScale;
	OutSubsurfaceLighting *= View.PrecomputedIndirectLightingColorScale;
	float3 SkyDiffuseLighting;
	float3 SkySubsurfaceLighting;
	GetSkyLighting(MaterialParameters, LightmapVTPageTableResult, bEvaluateBackface, DiffuseDir, SkyOcclusionUV, SkyOcclusionDataIndex, VolumetricLightmapBrickTextureUVs, SkyDiffuseLighting, SkySubsurfaceLighting);
	OutSubsurfaceLighting += SkySubsurfaceLighting;
	OutDiffuseLighting += SkyDiffuseLighting;
}
uint GetDiffuseIndirectSampleOcclusion(FGBufferData GBuffer, float3 V, float3 WorldNormal, float3 WorldBentNormal, float2 SvPosition, float MaterialAO)
{
	uint DiffuseIndirectSampleOcclusion = 0;
	return DiffuseIndirectSampleOcclusion;
}
void FPixelShaderInOut_MainPS(
	FVertexFactoryInterpolantsVSToPS Interpolants,
	FSharedBasePassInterpolants BasePassInterpolants,
	in FPixelShaderIn In,
	inout FPixelShaderOut Out)
{
	const uint EyeIndex = 0;
	ResolvedView = ResolveView();
	float4 OutVelocity = 0;
	float4 OutGBufferD = 0;
	float4 OutGBufferE = 0;
	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(Interpolants, In.SvPosition);
	FPixelMaterialInputs PixelMaterialInputs;
	float LightmapVTPageTableResult = (float)0.0f;
	{
		float4 ScreenPosition = SvPositionToResolvedScreenPosition(In.SvPosition);
		float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(In.SvPosition);
		CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, In.SvPosition, ScreenPosition, In.bIsFrontFace, TranslatedWorldPosition, BasePassInterpolants.PixelPositionExcludingWPO);
	}
	const bool bEditorWeightedZBuffering = false;
	if (!bEditorWeightedZBuffering)
	{
		GetMaterialCoverageAndClipping(MaterialParameters, PixelMaterialInputs);
	}
	const float Dither = InterleavedGradientNoise(MaterialParameters.SvPosition.xy, View.StateFrameIndexMod8);
	float3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
	float  Metallic = GetMaterialMetallic(PixelMaterialInputs);
	float  Specular = GetMaterialSpecular(PixelMaterialInputs);
	float Roughness = GetMaterialRoughness(PixelMaterialInputs);
	float Anisotropy = GetMaterialAnisotropy(PixelMaterialInputs);
	uint ShadingModel = GetMaterialShadingModel(PixelMaterialInputs);
	float Opacity = GetMaterialOpacity(PixelMaterialInputs);
	float MaterialAO = GetMaterialAmbientOcclusion(PixelMaterialInputs);
	float3 SubsurfaceColor = 0;
	float SubsurfaceProfile = 0;
	float DBufferOpacity = 1.0f;
	const float BaseMaterialCoverageOverWater = Opacity;
	const float WaterVisibility = 1.0 - BaseMaterialCoverageOverWater;
	float3 VolumetricLightmapBrickTextureUVs;
	FGBufferData GBuffer = (FGBufferData)0;
	GBuffer.GBufferAO = MaterialAO;
	GBuffer.PerObjectGBufferData = GetPrimitive_PerObjectGBufferData(MaterialParameters.PrimitiveId);
	GBuffer.Depth = MaterialParameters.ScreenPosition.w;
	GBuffer.PrecomputedShadowFactors = GetPrecomputedShadowMasks(LightmapVTPageTableResult, Interpolants, MaterialParameters, VolumetricLightmapBrickTextureUVs);
	SetGBufferForShadingModel(
		GBuffer,
		MaterialParameters,
		Opacity,
		BaseColor,
		Metallic,
		Specular,
		Roughness,
		Anisotropy,
		SubsurfaceColor,
		SubsurfaceProfile,
		Dither,
		ShadingModel
		);
	const bool bChecker = CheckerFromPixelPos(MaterialParameters.SvPosition.xy);
	GBuffer.SpecularColor = ComputeF0(Specular, BaseColor, Metallic);
	GBuffer.DiffuseColor = BaseColor - BaseColor * Metallic;
	{
		GBuffer.DiffuseColor = GBuffer.DiffuseColor * View.DiffuseOverrideParameter.w + View.DiffuseOverrideParameter.xyz;
		GBuffer.SpecularColor = GBuffer.SpecularColor * View.SpecularOverrideParameter.w + View.SpecularOverrideParameter.xyz;
	}
	if (View.RenderingReflectionCaptureMask) 
	{
		EnvBRDFApproxFullyRough(GBuffer.DiffuseColor, GBuffer.SpecularColor);
	}
	float3 InputBentNormal = MaterialParameters.WorldNormal;
	[branch] if( GBuffer.ShadingModelID == 4 && 0)
	{
		const float2 oct1 = ((float2(GBuffer.CustomData.a, GBuffer.CustomData.z) * 4) - (512.0/255.0)) + UnitVectorToOctahedron(GBuffer.WorldNormal);
		InputBentNormal = OctahedronToUnitVector(oct1);
	}
	const FShadingOcclusion ShadingOcclusion = ApplyBentNormal(MaterialParameters.CameraVector, InputBentNormal, GetWorldBentNormalZero(MaterialParameters), GBuffer.Roughness, MaterialAO);
	GBuffer.GBufferAO = AOMultiBounce( Luminance( GBuffer.SpecularColor ), ShadingOcclusion.SpecOcclusion ).g;
	GBuffer.DiffuseIndirectSampleOcclusion = GetDiffuseIndirectSampleOcclusion(GBuffer, MaterialParameters.CameraVector, MaterialParameters.WorldNormal, GetWorldBentNormalZero(MaterialParameters), In.SvPosition.xy, MaterialAO);
	float3 DiffuseColor = 0;
	float3 Color = 0;
	float IndirectIrradiance = 0;
	float3 ColorSeparateSpecular = 0;
	float3 ColorSeparateEmissive = 0;
	float3 DiffuseIndirectLighting = 0;
	float3 SubsurfaceIndirectLighting = 0;
	float3 SeparatedWaterMainDirLightLuminance = float3(0, 0, 0); 
		float3 DiffuseDir = ShadingOcclusion.BentNormal;
		float3 DiffuseColorForIndirect = GBuffer.DiffuseColor;
		const bool bEvaluateBackface = GetShadingModelRequiresBackfaceLighting(GBuffer.ShadingModelID);
		GetPrecomputedIndirectLightingAndSkyLight(MaterialParameters, Interpolants, BasePassInterpolants, LightmapVTPageTableResult, bEvaluateBackface, DiffuseDir, VolumetricLightmapBrickTextureUVs, DiffuseIndirectLighting, SubsurfaceIndirectLighting, IndirectIrradiance);
		float IndirectOcclusion = 1.0f;
		float2 NearestResolvedDepthScreenUV = 0;
		float DirectionalLightShadow = 1.0f;
		float DirectionalLightCloudShadow = 1.0f;
		DiffuseColor += (DiffuseIndirectLighting * DiffuseColorForIndirect + SubsurfaceIndirectLighting * SubsurfaceColor) * AOMultiBounce( GBuffer.BaseColor, ShadingOcclusion.DiffOcclusion );
			uint GridIndex = 0;
				GridIndex = ComputeLightGridCellIndex((uint2)((MaterialParameters.SvPosition.xy - ResolvedView.ViewRectMin.xy) * View.LightProbeSizeRatioAndInvSizeRatio.zw), MaterialParameters.SvPosition.w, EyeIndex);
					float3 DirectionalLightAtmosphereTransmittance = 1.0f;
					const bool bSkipMainDirLightVirtualShadowMapEvaluation = false;
					const bool bSeparateWaterMainDirLightLuminance = false;
					FDeferredLightingSplit ForwardDirectLighting = GetForwardDirectLightingSplit(
						In.SvPosition.xy,
						GridIndex, MaterialParameters.WorldPosition_CamRelative, MaterialParameters.CameraVector, GBuffer, NearestResolvedDepthScreenUV, MaterialParameters.PrimitiveId, EyeIndex, Dither, 
						DirectionalLightCloudShadow, DirectionalLightAtmosphereTransmittance, DirectionalLightShadow,
						bSeparateWaterMainDirLightLuminance, SeparatedWaterMainDirLightLuminance,
						bSkipMainDirLightVirtualShadowMapEvaluation);
						DiffuseColor += ForwardDirectLighting.DiffuseLighting.rgb;
						ColorSeparateSpecular += ForwardDirectLighting.SpecularLighting.rgb;
				if (GBuffer.ShadingModelID != 7)
				{
					int SingleCaptureIndex = GetPrimitiveData(MaterialParameters).SingleCaptureIndex;
					float3 ReflectionColor = GetImageBasedReflectionLighting(MaterialParameters, GBuffer.Roughness, GBuffer.SpecularColor, IndirectIrradiance, GridIndex, SingleCaptureIndex, EyeIndex) 
						* IndirectOcclusion
						* AOMultiBounce(GBuffer.SpecularColor, ShadingOcclusion.SpecOcclusion);
						ColorSeparateSpecular += ReflectionColor;
				}
		float4 HeightFogging = BasePassInterpolants.VertexFog;
	float4 Fogging = HeightFogging;
	if (TranslucentBasePass.Shared_Fog_ApplyVolumetricFog > 0) 
	{
		float3 VolumeUV = ComputeVolumeUV(MaterialParameters.AbsoluteWorldPosition, ResolvedView.WorldToClip);
		Fogging = CombineVolumetricFog(HeightFogging, VolumeUV, EyeIndex, GBuffer.Depth);
	}
	float3 Emissive = 0;
		float3 GBufferDiffuseColor = GBuffer.DiffuseColor;
		float3 GBufferSpecularColor = GBuffer.SpecularColor;
		EnvBRDFApproxFullyRough(GBufferDiffuseColor, GBufferSpecularColor);
		Color = lerp(Color, GBufferDiffuseColor, View.UnlitViewmodeMask);
	Emissive = GetMaterialEmissive(PixelMaterialInputs);
	float3 OutOfBoundsMaskLuminance = 0;
		[branch]
		if (View.OutOfBoundsMask > 0)
		{
			FPrimitiveSceneData PrimitiveData = GetPrimitiveData(MaterialParameters);
			float3 ObjectBounds =
				float3(
					PrimitiveData.ObjectBoundsX,
					PrimitiveData.ObjectBoundsY,
					PrimitiveData.ObjectBoundsZ
				);
			if (any(abs(DFFastLocalSubtractDemote(MaterialParameters.AbsoluteWorldPosition, PrimitiveData.ObjectWorldPosition)) > ObjectBounds + 1))
			{
				float3 WorldPosModulo = DFFmodByPow2Demote(MaterialParameters.AbsoluteWorldPosition, 65536.0);
				float Gradient = frac(dot(WorldPosModulo, float3(.577f, .577f, .577f) / 500.0f));
				OutOfBoundsMaskLuminance = lerp(float3(1,1,0), float3(0,1,1), Gradient.xxx > .5f);
				Emissive = OutOfBoundsMaskLuminance;
				Opacity = 1;
			}
			else if (PrimitiveData.MaxWPOExtent > 0.0f)
			{
				const float3 OffsetAmt = abs(MaterialParameters.WorldPosition_CamRelative - MaterialParameters.WorldPosition_NoOffsets_CamRelative);
				const float MaxOffsetDim = max3(OffsetAmt.x, OffsetAmt.y, OffsetAmt.z);
				const float Proximity = 1.0f - saturate(abs(MaxOffsetDim - PrimitiveData.MaxWPOExtent) / 0.05f);
				Emissive = Proximity * float3(1, 0 ,1);
				Opacity = sign(Proximity);
			}
		}
	float3 DualBlendSurfaceLuminancePostCoverage	= 0.0f;
	float3 DualBlendSurfaceTransmittancePreCoverage = 1.0f;
	float DualBlendSurfaceCoverage					= 1.0f;
	{
		AccumulateThinTranslucentModel(
								DualBlendSurfaceLuminancePostCoverage,
								DualBlendSurfaceTransmittancePreCoverage,
								DualBlendSurfaceCoverage,
								MaterialParameters,
								GBuffer,
								DiffuseColor,
								ColorSeparateSpecular,
								Emissive,
								Opacity);
		Color = 0;
		Opacity = 1.0f;
	}
	bool bSubstrateSubsurfaceEnable = false;
		float3 AdjustedDualBlendAdd = DualBlendSurfaceCoverage * Fogging.rgb + Fogging.a * DualBlendSurfaceLuminancePostCoverage;
		float3 AdjustedDualBlendMul = lerp(1.0f, Fogging.a * DualBlendSurfaceTransmittancePreCoverage, DualBlendSurfaceCoverage);
			Out.MRT[0] = float4(AdjustedDualBlendAdd,0.0);
			Out.MRT[1] = float4(AdjustedDualBlendMul,1.0);
	if(bEditorWeightedZBuffering)
	{
		Out.MRT[0].a = 1;
			clip(Out.MRT[0].a - GetMaterialOpacityMaskClipValue());
	}
	const float ViewPreExposure = View.PreExposure;
		Out.MRT[0].rgb  *= ViewPreExposure;
	Out.MRT[0].xyz = min(Out.MRT[0].xyz, Max10BitsFloat.xxx * 0.5f);
}
void MainPS
	(
		FVertexFactoryInterpolantsVSToPS Interpolants,
		FSharedBasePassInterpolants BasePassInterpolants,
		in   float4 SvPosition : SV_Position		
		, in bool bIsFrontFace : SV_IsFrontFace
		, out float4 OutTarget0   : SV_Target0
		, out float4 OutTarget1   : SV_Target1
		 
	)
{
	FPixelShaderIn PixelShaderIn = (FPixelShaderIn)0;
	FPixelShaderOut PixelShaderOut = (FPixelShaderOut)0;
	PixelShaderIn.SvPosition = SvPosition;
	PixelShaderIn.bIsFrontFace = bIsFrontFace;
	FPixelShaderInOut_MainPS(Interpolants, BasePassInterpolants, PixelShaderIn, PixelShaderOut);
	OutTarget0 = PixelShaderOut.MRT[0];
	OutTarget1 = PixelShaderOut.MRT[1];
}

/* BASE64_ENV
CQAAABkAAABWSUVXX0hBU19USUxFT0ZGU0VUX0RBVEEAAAEAAAAeAAAAUFJJTUlUSVZFX0hBU19USUxFT0ZGU0VUX0RBVEEAAAEAAAARAAAASU5TVEFOQ0VEX1NURVJFTwAAAAAAAAsAAABNVUxUSV9WSUVXAAAAAAAAEgAAAE1PQklMRV9NVUxUSV9WSUVXAAAAAAAAGwAAAFVTRVNfV09STERfUE9TSVRJT05fT0ZGU0VUAAAAAAAAEgAAAFVTRVNfRElTUExBQ0VNRU5UAAAAAAAAHQAAAE1BVEVSSUFMQkxFTkRJTkdfVFJBTlNMVUNFTlQAAAEAAAAcAAAAVVNJTkdfVkFSSUFCTEVfUkFURV9TSEFESU5HAAABAAAAABAQAAQAAAAAAAAALAIAAAkJAAAJCQEACQkCAAkJAwAJEAQACRAFAAQIAAAECAEABAUCAAQFAwAEBQQABAUFAAQFBgAEBQcABAUIAAQFCQAEBQoABAULAAQIDAAECA0ABAgOAAQIDwAECBAABAgRAAQIEgAECBMABAgUAAQFFQAEBRYABAUXAAQFGAAECBkABAgaAAQIGwAEBRwABAgdAAQFHgAECB8ABAUgAAQIIQAEBSIABAgjAAQFJAAECCUABAUmAAQIJwAECCgABAgpAAQIKgAECCsABAgsAAQILQAEBS4ABAgvAAQGMAAEBTEABAgyAAQFMwAECDQABAU1AAQINgAEBTcABAg4AAQFOQAECDoABAU7AAQIPAAEBT0ABAg+AAQFPwAECEAABAVBAAQIQgAEBUMABAhEAAQFRQAEBUYABAVHAAQFSAAECEkABAVKAAQISwAEBUwABAhNAAQFTgAECE8ABAVQAAQIUQAECFIABAVTAAQIVAAEBVUABAhWAAQGVwAEBlgABAVZAAQIWgAEBVsABAhcAAQIXQAEBl4ABAZfAAQHYAAEBmEABBAAAAQQAQAEEAIADQUAAAoGAAAKBgEACgYCAAoGAwAXBQAAFwgBABcFAgAXCAMAEwkAABMJAQATCQIAEwkDABMJBAATCQUAEwkGABMJBwATCQgAEwkJABMJCgATCQsAEwwMABMIDQAQCQAAEAgBABAJAgAQCAMAEAkEABAMBQAQCAYAEAkHABAICAAQBQkAEAUKABMJAAATCAEAEwkCABMJAwATCAQAEwkFABMIBgATCQcAEwgIABMMCQATCQoAEwgLABMJDAATCQ0AEwkOABMJDwATCRAAEwkRABMJEgATCRMAEwgUABMIFQATCBYAEwgXABMIGAAPEAAADxABAAUQAAAFEAEABRACAAUQAwAFEAQABRAFAAUQBgAFDAcABQwIAAUICQAQEAAACQUAAAkFAQAICQAACAgBAAgFAgAICAMACBAEAAgQBQAIEAYACBAHAAgJCAAICAkACAUKAAgICwAIEAwACBANAAgQDgAIEA8ACAkQAAgIEQAIBRIACAgTAAgFFAAICBUACAUWAAgIFwAIBRgACAgZAAgFGgAICBsACAkcAAgIHQAIBR4ACAgfAAgJIAAICCEACBAiAAgMIwAICSQACBAlAAgIJgAOCQAADggBAA4FAgAOCAMADhAEAA4QBQAOEAYADhAHAA4JCAAOCAkADgUKAA4ICwAOEAwADhANAA4QDgAOEA8ADgkQAA4IEQAOBRIADggTAA4FFAAOCBUADgUWAA4IFwAOBRgADggZAA4FGgAOCBsADgkcAA4IHQAOBR4ADggfAA4JIAAOCCEADhAiAA4MIwAOCSQADhAlAA4IJgAODScADg0oAA4JKQAOCSoADgkrAA4JLAAOCS0ADgkuAA4JLwAOCDAADggxAA4IMgAOBTMADgg0AA4QNQATCQAAEwgBABMFAgATCAMAExAEABMQBQATEAYAExAHABMJCAATCAkAEwUKABMICwATEAwAExANABMQDgATEA8AEwkQABMIEQATBRIAEwgTABMFFAATCBUAEwUWABMIFwATBRgAEwgZABMFGgATCBsAEwkcABMIHQATBR4AEwgfABMJIAATCCEAExAiABMMIwATCSQAExAlABMIJgATCScAEwkoABMJKQATCSoAEwkrABMJLAATCS0AEwkuABMJLwATCTAAEwkxABMJMgATDDMAEwg0ABMJNQATCTYAEwk3ABMIOAATDTkAEw06ABMJOwATCDwAEww9ABMIPgATCT8AEwhAABMJQQATCEIAEwlDABMJRAATCUUAEwlGABMJRwATCUgAEwlJABMJSgATCUsAExBMABMJTQATCU4AEwlPABMJUAATCVEAEwlSABMJUwATCFQAEwVVABMIVgATEFcAEwlYABMIWQATBVoAEwVbABMQXAATEF0AExBeABUFAAAVBQEAFQUCABUIAwAVCAQAFQgFABcFAAAXBQEAFwUCABcFAwAXBgQAFwYFABcGBgAXBgcAFwYIABcICQAXCAoAFwgLABcIDAAXCA0AFwUOABcFDwAWBQAAFggBABAJAAAQCAEAEAUCABAIAwAQBQQAEAgFABAFBgAQCAcACQUAAAkIAQAJCQIACQgDABMJAAATCQEAEwkCABMJAwATCQQAExAFABMJBgATCQcAEwkIABMJCQATCQoAEwkLABMJDAATCA0AFQUAABUFAQAVCAIAFQgDABAJAAAQCAEAEAUCABAIAwAQEAQAEBAFABAQBgAQEAcAEgkAABIQAQASCAIADAkAAAwIAQAMCQIADAkDAAwIBAAMBQUADAgGAAwJAAAMCAEADAkCAAwJAwAMCAQADAUFAAwIBgAOBQAADggBAA4JAgAOCAMADhAEAA4MBQAOCQYADggHAA4FCAAOCAkADhAKAA4QCwAOEAwADhANAA4JDgAOCA8ADgUQAA4IEQAOEBIADhATAA4QFAAOEBUADgUWAA4IFwAOCRgADggZAA4JGgAOCRsADggcAA4JHQAOCB4ADgkfAA4IIAAODCEADgkiAA4IIwAOCSQADgklAA4JJgAOCScADgkoAA4JKQAOCSoADgkrAA4ILAAOCC0ADgguAA4ILwAOCDAADg0xAA4JMgAOCDMADgU0AA4INQAOBTYADgg3AA4FOAAOCDkADgU6AA4IOwAOEDwADhE9AA4JPgAOCD8ADglAAA4IQQAOCUIADglDAA4JRAAOCUUADghGAA4IRwAOCEgAEBAAABAQAQAQEAIAEBADABAJBAAQEAUAEBAGABAQBwAGEAAABhABAAYQAgAGEAMABgYEAAYJBQAGCQYABgkHAAYJCAAGEAkABhAKAAYQCwAGEAwABhANABAGAAAQBgEAEAYCAAcGAAAHBgEABwYCAAcGAwAHBgQAFgYAABYGAQAWBgIACAgAAAgIAQAvAAAAGAAAAERyYXdSZWN0YW5nbGVQYXJhbWV0ZXJzAAAAAAAAATAAAQAAAAAAAAAACgAAAFN1YnN0cmF0ZQAAAAAAQRFwCQEAAAAAvAAAAFMAdQBiAHMAdAByAGEAdABlAF8ATQBhAHQAZQByAGkAYQBsAFQAZQB4AHQAdQByAGUAQQByAHIAYQB5AAAAUwB1AGIAcwB0AHIAYQB0AGUAXwBUAG8AcABMAGEAeQBlAHIAVABlAHgAdAB1AHIAZQAAAFMAdQBiAHMAdAByAGEAdABlAF8ATwBwAGEAcQB1AGUAUgBvAHUAZwBoAFIAZQBmAHIAYQBjAHQAaQBvAG4AVABlAHgAdAB1AHIAZQAAAFMAdQBiAHMAdAByAGEAdABlAF8AQwBsAG8AcwB1AHIAZQBPAGYAZgBzAGUAdABUAGUAeAB0AHUAcgBlAAAAUwB1AGIAcwB0AHIAYQB0AGUAXwBDAGwAbwBzAHUAcgBlAFQAaQBsAGUAQgB1AGYAZgBlAHIAAABTAHUAYgBzAHQAcgBhAHQAZQBfAEMAbABvAHMAdQByAGUAVABpAGwAZQBDAG8AdQBuAHQAQgB1AGYAZgBlAHIAAAAFAAAAVmlldwAFAAAAVmlldwAaAmgVAwAAAADwDAAAVgBpAGUAdwBfAE0AYQB0AGUAcgBpAGEAbABUAGUAeAB0AHUAcgBlAEIAaQBsAGkAbgBlAGEAcgBXAHIAYQBwAGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAE0AYQB0AGUAcgBpAGEAbABUAGUAeAB0AHUAcgBlAEIAaQBsAGkAbgBlAGEAcgBDAGwAYQBtAHAAZQBkAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAASQBuAGQAaQByAGUAYwB0AGkAbwBuAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAQgByAGkAYwBrAEEAbQBiAGkAZQBuAHQAVgBlAGMAdABvAHIAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAQgByAGkAYwBrAFMASABDAG8AZQBmAGYAaQBjAGkAZQBuAHQAcwAwAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAEIAcgBpAGMAawBTAEgAQwBvAGUAZgBmAGkAYwBpAGUAbgB0AHMAMQAAAFYAaQBlAHcAXwBWAG8AbAB1AG0AZQB0AHIAaQBjAEwAaQBnAGgAdABtAGEAcABCAHIAaQBjAGsAUwBIAEMAbwBlAGYAZgBpAGMAaQBlAG4AdABzADIAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAQgByAGkAYwBrAFMASABDAG8AZQBmAGYAaQBjAGkAZQBuAHQAcwAzAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAEIAcgBpAGMAawBTAEgAQwBvAGUAZgBmAGkAYwBpAGUAbgB0AHMANAAAAFYAaQBlAHcAXwBWAG8AbAB1AG0AZQB0AHIAaQBjAEwAaQBnAGgAdABtAGEAcABCAHIAaQBjAGsAUwBIAEMAbwBlAGYAZgBpAGMAaQBlAG4AdABzADUAAABWAGkAZQB3AF8AUwBrAHkAQgBlAG4AdABOAG8AcgBtAGEAbABCAHIAaQBjAGsAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBEAGkAcgBlAGMAdABpAG8AbgBhAGwATABpAGcAaAB0AFMAaABhAGQAbwB3AGkAbgBnAEIAcgBpAGMAawBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAEIAcgBpAGMAawBBAG0AYgBpAGUAbgB0AFYAZQBjAHQAbwByAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADAAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADEAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADIAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADMAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADQAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADUAAABWAGkAZQB3AF8AUwBrAHkAQgBlAG4AdABOAG8AcgBtAGEAbABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAGgAYQBkAG8AdwBpAG4AZwBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8ARwBsAG8AYgBhAGwARABpAHMAdABhAG4AYwBlAEYAaQBlAGwAZABQAGEAZwBlAEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEcAbABvAGIAYQBsAEQAaQBzAHQAYQBuAGMAZQBGAGkAZQBsAGQAQwBvAHYAZQByAGEAZwBlAEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEcAbABvAGIAYQBsAEQAaQBzAHQAYQBuAGMAZQBGAGkAZQBsAGQAUABhAGcAZQBUAGEAYgBsAGUAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBHAGwAbwBiAGEAbABEAGkAcwB0AGEAbgBjAGUARgBpAGUAbABkAE0AaQBwAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8ARwBsAG8AYgBhAGwARABpAHMAdABhAG4AYwBlAEYAaQBlAGwAZABQAGEAZwBlAEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8ARwBsAG8AYgBhAGwARABpAHMAdABhAG4AYwBlAEYAaQBlAGwAZABDAG8AdgBlAHIAYQBnAGUAQQB0AGwAYQBzAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBHAGwAbwBiAGEAbABEAGkAcwB0AGEAbgBjAGUARgBpAGUAbABkAE0AaQBwAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBBAHQAbQBvAHMAcABoAGUAcgBlAFQAcgBhAG4AcwBtAGkAdAB0AGEAbgBjAGUAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBBAHQAbQBvAHMAcABoAGUAcgBlAFQAcgBhAG4AcwBtAGkAdAB0AGEAbgBjAGUAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEEAdABtAG8AcwBwAGgAZQByAGUASQByAHIAYQBkAGkAYQBuAGMAZQBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEEAdABtAG8AcwBwAGgAZQByAGUASQByAHIAYQBkAGkAYQBuAGMAZQBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AQQB0AG0AbwBzAHAAaABlAHIAZQBJAG4AcwBjAGEAdAB0AGUAcgBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEEAdABtAG8AcwBwAGgAZQByAGUASQBuAHMAYwBhAHQAdABlAHIAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFAAZQByAGwAaQBuAE4AbwBpAHMAZQBHAHIAYQBkAGkAZQBuAHQAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBQAGUAcgBsAGkAbgBOAG8AaQBzAGUARwByAGEAZABpAGUAbgB0AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBQAGUAcgBsAGkAbgBOAG8AaQBzAGUAMwBEAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUABlAHIAbABpAG4ATgBvAGkAcwBlADMARABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBvAGIAbwBsAFMAYQBtAHAAbABpAG4AZwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFMAaABhAHIAZQBkAFAAbwBpAG4AdABXAHIAYQBwAHAAZQBkAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBoAGEAcgBlAGQAUABvAGkAbgB0AEMAbABhAG0AcABlAGQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBTAGgAYQByAGUAZABCAGkAbABpAG4AZQBhAHIAVwByAGEAcABwAGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaABhAHIAZQBkAEIAaQBsAGkAbgBlAGEAcgBDAGwAYQBtAHAAZQBkAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBoAGEAcgBlAGQAQgBpAGwAaQBuAGUAYQByAEEAbgBpAHMAbwBDAGwAYQBtAHAAZQBkAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBoAGEAcgBlAGQAVAByAGkAbABpAG4AZQBhAHIAVwByAGEAcABwAGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaABhAHIAZQBkAFQAcgBpAGwAaQBuAGUAYQByAEMAbABhAG0AcABlAGQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBQAHIAZQBJAG4AdABlAGcAcgBhAHQAZQBkAEIAUgBEAEYAAABWAGkAZQB3AF8AUAByAGUASQBuAHQAZQBnAHIAYQB0AGUAZABCAFIARABGAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBrAHkASQByAHIAYQBkAGkAYQBuAGMAZQBFAG4AdgBpAHIAbwBuAG0AZQBuAHQATQBhAHAAAABWAGkAZQB3AF8AVAByAGEAbgBzAG0AaQB0AHQAYQBuAGMAZQBMAHUAdABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFQAcgBhAG4AcwBtAGkAdAB0AGEAbgBjAGUATAB1AHQAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAawB5AFYAaQBlAHcATAB1AHQAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBTAGsAeQBWAGkAZQB3AEwAdQB0AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBEAGkAcwB0AGEAbgB0AFMAawB5AEwAaQBnAGgAdABMAHUAdABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEQAaQBzAHQAYQBuAHQAUwBrAHkATABpAGcAaAB0AEwAdQB0AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBDAGEAbQBlAHIAYQBBAGUAcgBpAGEAbABQAGUAcgBzAHAAZQBjAHQAaQB2AGUAVgBvAGwAdQBtAGUAAABWAGkAZQB3AF8AQwBhAG0AZQByAGEAQQBlAHIAaQBhAGwAUABlAHIAcwBwAGUAYwB0AGkAdgBlAFYAbwBsAHUAbQBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AQwBhAG0AZQByAGEAQQBlAHIAaQBhAGwAUABlAHIAcwBwAGUAYwB0AGkAdgBlAFYAbwBsAHUAbQBlAE0AaQBlAE8AbgBsAHkAAABWAGkAZQB3AF8AQwBhAG0AZQByAGEAQQBlAHIAaQBhAGwAUABlAHIAcwBwAGUAYwB0AGkAdgBlAFYAbwBsAHUAbQBlAE0AaQBlAE8AbgBsAHkAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBDAGEAbQBlAHIAYQBBAGUAcgBpAGEAbABQAGUAcgBzAHAAZQBjAHQAaQB2AGUAVgBvAGwAdQBtAGUAUgBhAHkATwBuAGwAeQAAAFYAaQBlAHcAXwBDAGEAbQBlAHIAYQBBAGUAcgBpAGEAbABQAGUAcgBzAHAAZQBjAHQAaQB2AGUAVgBvAGwAdQBtAGUAUgBhAHkATwBuAGwAeQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEgAYQBpAHIAUwBjAGEAdAB0AGUAcgBpAG4AZwBMAFUAVABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEgAYQBpAHIAUwBjAGEAdAB0AGUAcgBpAG4AZwBMAFUAVABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEcARwBYAEwAVABDAE0AYQB0AFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8ARwBHAFgATABUAEMATQBhAHQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBHAEcAWABMAFQAQwBBAG0AcABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEcARwBYAEwAVABDAEEAbQBwAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBoAGUAZQBuAEwAVABDAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBoAGUAZQBuAEwAVABDAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBoAGEAZABpAG4AZwBFAG4AZQByAGcAeQBHAEcAWABTAHAAZQBjAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBoAGEAZABpAG4AZwBFAG4AZQByAGcAeQBHAEcAWABHAGwAYQBzAHMAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBTAGgAYQBkAGkAbgBnAEUAbgBlAHIAZwB5AEMAbABvAHQAaABTAHAAZQBjAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBoAGEAZABpAG4AZwBFAG4AZQByAGcAeQBEAGkAZgBmAHUAcwBlAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBoAGEAZABpAG4AZwBFAG4AZQByAGcAeQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEcAbABpAG4AdABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEcAbABpAG4AdABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaQBtAHAAbABlAFYAbwBsAHUAbQBlAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBpAG0AcABsAGUAVgBvAGwAdQBtAGUAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaQBtAHAAbABlAFYAbwBsAHUAbQBlAEUAbgB2AFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBpAG0AcABsAGUAVgBvAGwAdQBtAGUARQBuAHYAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAUwBQAHIAbwBmAGkAbABlAHMAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBTAFMAUAByAG8AZgBpAGwAZQBzAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBTAFAAcgBvAGYAaQBsAGUAcwBUAHIAYQBuAHMAbQBpAHMAcwBpAG8AbgBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAUwBQAHIAbwBmAGkAbABlAHMAUAByAGUASQBuAHQAZQBnAHIAYQB0AGUAZABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFMAUwBQAHIAbwBmAGkAbABlAHMAUAByAGUASQBuAHQAZQBnAHIAYQB0AGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAcABlAGMAdQBsAGEAcgBQAHIAbwBmAGkAbABlAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBwAGUAYwB1AGwAYQByAFAAcgBvAGYAaQBsAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBXAGEAdABlAHIASQBuAGQAaQByAGUAYwB0AGkAbwBuAAAAVgBpAGUAdwBfAFcAYQB0AGUAcgBEAGEAdABhAAAAVgBpAGUAdwBfAFIAZQBjAHQATABpAGcAaAB0AEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFIAZQBjAHQATABpAGcAaAB0AEEAdABsAGEAcwBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEkARQBTAEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEkARQBTAEEAdABsAGEAcwBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEwAYQBuAGQAcwBjAGEAcABlAFcAZQBpAGcAaAB0AG0AYQBwAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8ATABhAG4AZABzAGMAYQBwAGUASQBuAGQAaQByAGUAYwB0AGkAbwBuAAAAVgBpAGUAdwBfAEwAYQBuAGQAcwBjAGEAcABlAFAAZQByAEMAbwBtAHAAbwBuAGUAbgB0AEQAYQB0AGEAAABWAGkAZQB3AF8AVgBUAEYAZQBlAGQAYgBhAGMAawBCAHUAZgBmAGUAcgAAAFYAaQBlAHcAXwBQAGgAeQBzAGkAYwBzAEYAaQBlAGwAZABDAGwAaQBwAG0AYQBwAEIAdQBmAGYAZQByAAAADgAAAEluc3RhbmNlZFZpZXcADgAAAEluc3RhbmNlZFZpZXcAAQOwHAMAAAAAAAAAAAUAAABBVlNNAAAAAACwAMABAQAAAAA/AAAAQQBWAFMATQBfAEwAaQBuAGsAZQBkAEwAaQBzAHQAQgB1AGYAZgBlAHIAAABBAFYAUwBNAF8ASQBuAGQAaQByAGUAYwB0AGkAbwBuAEIAdQBmAGYAZQByAAAAQQBWAFMATQBfAFMAYQBtAHAAbABlAEIAdQBmAGYAZQByAAAADgAAAERlZmVycmVkRGVjYWwADwAAAERlZmVycmVkRGVjYWxzAAQCIAACAAAAACIAAABEAGUAZgBlAHIAcgBlAGQARABlAGMAYQBsAF8AUAByAGUAdgBpAG8AdQBzAEYAcgBhAG0AZQBOAG8AcgBtAGEAbAAAAAsAAABJbnN0YW5jZVZGAAAAAAAGBzYGAQAAAACtAAAASQBuAHMAdABhAG4AYwBlAFYARgBfAFYAZQByAHQAZQB4AEYAZQB0AGMAaABfAEkAbgBzAHQAYQBuAGMAZQBPAHIAaQBnAGkAbgBCAHUAZgBmAGUAcgAAAEkAbgBzAHQAYQBuAGMAZQBWAEYAXwBWAGUAcgB0AGUAeABGAGUAdABjAGgAXwBJAG4AcwB0AGEAbgBjAGUAVAByAGEAbgBzAGYAbwByAG0AQgB1AGYAZgBlAHIAAABJAG4AcwB0AGEAbgBjAGUAVgBGAF8AVgBlAHIAdABlAHgARgBlAHQAYwBoAF8ASQBuAHMAdABhAG4AYwBlAEwAaQBnAGgAdABtAGEAcABCAHUAZgBmAGUAcgAAAEkAbgBzAHQAYQBuAGMAZQBWAEYAXwBJAG4AcwB0AGEAbgBjAGUAQwB1AHMAdABvAG0ARABhAHQAYQBCAHUAZgBmAGUAcgAAABgAAABNb2JpbGVSZWZsZWN0aW9uQ2FwdHVyZQAAAAAACAQ4BQEAAAAAmAAAAE0AbwBiAGkAbABlAFIAZQBmAGwAZQBjAHQAaQBvAG4AQwBhAHAAdAB1AHIAZQBfAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBSAGUAZgBsAGUAYwB0AGkAbwBuAEMAYQBwAHQAdQByAGUAXwBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBSAGUAZgBsAGUAYwB0AGkAbwBuAEMAYQBwAHQAdQByAGUAXwBUAGUAeAB0AHUAcgBlAEIAbABlAG4AZAAAAE0AbwBiAGkAbABlAFIAZQBmAGwAZQBjAHQAaQBvAG4AQwBhAHAAdAB1AHIAZQBfAFQAZQB4AHQAdQByAGUAQgBsAGUAbgBkAFMAYQBtAHAAbABlAHIAAAAQAAAAUHJpbWl0aXZlRGl0aGVyAAAAAAAAARAAAQAAAAAAAAAADgAAAFByaW1pdGl2ZUZhZGUAAAAAAAABEAABAAAAAAAAAAAUAAAAU2NlbmVUZXh0dXJlc1N0cnVjdAAOAAAAU2NlbmVUZXh0dXJlcwAIDnAJAgAAAAAbAgAAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBTAHQAcgB1AGMAdABfAFMAYwBlAG4AZQBDAG8AbABvAHIAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBTAGMAZQBuAGUARABlAHAAdABoAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8AUwBjAGUAbgBlAFAAYQByAHQAaQBhAGwARABlAHAAdABoAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8ARwBCAHUAZgBmAGUAcgBBAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8ARwBCAHUAZgBmAGUAcgBCAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8ARwBCAHUAZgBmAGUAcgBDAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8ARwBCAHUAZgBmAGUAcgBEAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8ARwBCAHUAZgBmAGUAcgBFAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8ARwBCAHUAZgBmAGUAcgBGAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8ARwBCAHUAZgBmAGUAcgBWAGUAbABvAGMAaQB0AHkAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBTAGMAcgBlAGUAbgBTAHAAYQBjAGUAQQBPAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8AQwB1AHMAdABvAG0ARABlAHAAdABoAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8AQwB1AHMAdABvAG0AUwB0AGUAbgBjAGkAbABUAGUAeAB0AHUAcgBlAAAAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBTAHQAcgB1AGMAdABfAFAAbwBpAG4AdABDAGwAYQBtAHAAUwBhAG0AcABsAGUAcgAAABEAAABTaW5nbGVMYXllcldhdGVyAA8AAABEZWZlcnJlZERlY2FscwAkCxkAAgAAAAAqAgAAUwBpAG4AZwBsAGUATABhAHkAZQByAFcAYQB0AGUAcgBfAFMAYwBlAG4AZQBDAG8AbABvAHIAVwBpAHQAaABvAHUAdABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAFQAZQB4AHQAdQByAGUAAABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAF8AUwBjAGUAbgBlAEMAbwBsAG8AcgBXAGkAdABoAG8AdQB0AFMAaQBuAGcAbABlAEwAYQB5AGUAcgBXAGEAdABlAHIAUwBhAG0AcABsAGUAcgAAAFMAaQBuAGcAbABlAEwAYQB5AGUAcgBXAGEAdABlAHIAXwBTAGMAZQBuAGUARABlAHAAdABoAFcAaQB0AGgAbwB1AHQAUwBpAG4AZwBsAGUATABhAHkAZQByAFcAYQB0AGUAcgBUAGUAeAB0AHUAcgBlAAAAUwBpAG4AZwBsAGUATABhAHkAZQByAFcAYQB0AGUAcgBfAFMAYwBlAG4AZQBEAGUAcAB0AGgAVwBpAHQAaABvAHUAdABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAFMAYQBtAHAAbABlAHIAAABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAF8AQwB1AHMAdABvAG0ARABlAHAAdABoAFQAZQB4AHQAdQByAGUAAABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAF8AQwB1AHMAdABvAG0AUwB0AGUAbgBjAGkAbABUAGUAeAB0AHUAcgBlAAAAUwBpAG4AZwBsAGUATABhAHkAZQByAFcAYQB0AGUAcgBfAEMAdQBzAHQAbwBtAEQAZQBwAHQAaABTAGEAbQBwAGwAZQByAAAAUwBpAG4AZwBsAGUATABhAHkAZQByAFcAYQB0AGUAcgBfAEYAbwByAHcAYQByAGQARABpAHIATABpAGcAaAB0AEMAbABvAHUAZABTAGgAYQBkAG8AdwBfAEMAbABvAHUAZABTAGgAYQBkAG8AdwBtAGEAcABUAGUAeAB0AHUAcgBlAAAAUwBpAG4AZwBsAGUATABhAHkAZQByAFcAYQB0AGUAcgBfAEYAbwByAHcAYQByAGQARABpAHIATABpAGcAaAB0AEMAbABvAHUAZABTAGgAYQBkAG8AdwBfAEMAbABvAHUAZABTAGgAYQBkAG8AdwBtAGEAcABTAGEAbQBwAGwAZQByAAAAUwBpAG4AZwBsAGUATABhAHkAZQByAFcAYQB0AGUAcgBfAEIAbAB1AGUATgBvAGkAcwBlAF8AUwBjAGEAbABhAHIAVABlAHgAdAB1AHIAZQAAAFMAaQBuAGcAbABlAEwAYQB5AGUAcgBXAGEAdABlAHIAXwBCAGwAdQBlAE4AbwBpAHMAZQBfAFYAZQBjADIAVABlAHgAdAB1AHIAZQAAABQAAABNb2JpbGVTY2VuZVRleHR1cmVzAA4AAABTY2VuZVRleHR1cmVzAMgC0AUCAAAAABoEAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEMAbwBsAG8AcgBUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBDAG8AbABvAHIAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUARABlAHAAdABoAFQAZQB4AHQAdQByAGUAQQByAHIAYQB5AAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBQAGEAcgB0AGkAYQBsAEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBQAGEAcgB0AGkAYQBsAEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AQwB1AHMAdABvAG0ARABlAHAAdABoAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AQwB1AHMAdABvAG0ARABlAHAAdABoAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBDAHUAcwB0AG8AbQBTAHQAZQBuAGMAaQBsAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAFYAZQBsAG8AYwBpAHQAeQBUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBWAGUAbABvAGMAaQB0AHkAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEcAQgB1AGYAZgBlAHIAQQBUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEcAQgB1AGYAZgBlAHIAQgBUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEcAQgB1AGYAZgBlAHIAQwBUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEcAQgB1AGYAZgBlAHIARABUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBEAGUAcAB0AGgAQQB1AHgAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUARABlAHAAdABoAEEAdQB4AFQAZQB4AHQAdQByAGUAQQByAHIAYQB5AAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEwAbwBjAGEAbABMAGkAZwBoAHQAVABlAHgAdAB1AHIAZQBBAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEwAbwBjAGEAbABMAGkAZwBoAHQAVABlAHgAdAB1AHIAZQBCAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEcAQgB1AGYAZgBlAHIAQQBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBCAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAEMAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEcAQgB1AGYAZgBlAHIARABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEQAZQBwAHQAaABBAHUAeABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAAAQAAAASW5zdGFuY2VDdWxsaW5nABYAAABJbnN0YW5jZUN1bGxpbmdVYlNsb3QAGQIwAAIAAAAAQQAAAEkAbgBzAHQAYQBuAGMAZQBDAHUAbABsAGkAbgBnAF8ASQBuAHMAdABhAG4AYwBlAEkAZABzAEIAdQBmAGYAZQByAAAASQBuAHMAdABhAG4AYwBlAEMAdQBsAGwAaQBuAGcAXwBQAGEAZwBlAEkAbgBmAG8AQgB1AGYAZgBlAHIAAAAKAAAAUHJpbWl0aXZlAAAAAAAAAQADAQAAAAAAAAAABgAAAFNjZW5lAAYAAABTY2VuZQBRH4wAAwAAAAB1AQAAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAEkAbgBzAHQAYQBuAGMAZQBTAGMAZQBuAGUARABhAHQAYQAAAFMAYwBlAG4AZQBfAEcAUABVAFMAYwBlAG4AZQBfAEcAUABVAFMAYwBlAG4AZQBJAG4AcwB0AGEAbgBjAGUAUABhAHkAbABvAGEAZABEAGEAdABhAAAAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAFAAcgBpAG0AaQB0AGkAdgBlAFMAYwBlAG4AZQBEAGEAdABhAAAAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAEwAaQBnAGgAdABtAGEAcABEAGEAdABhAAAAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAEwAaQBnAGgAdABEAGEAdABhAAAAUwBjAGUAbgBlAF8ATgBhAG4AaQB0AGUATQBhAHQAZQByAGkAYQBsAHMAXwBQAHIAaQBtAGkAdABpAHYAZQBNAGEAdABlAHIAaQBhAGwARABhAHQAYQAAAFMAYwBlAG4AZQBfAE4AYQBuAGkAdABlAE0AYQB0AGUAcgBpAGEAbABzAF8ATQBhAHQAZQByAGkAYQBsAEQAYQB0AGEAAABTAGMAZQBuAGUAXwBTAHAAbABpAG4AZQBNAGUAcwBoAF8AUwBwAGwAaQBuAGUAUABvAHMAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBfAFMAcABsAGkAbgBlAE0AZQBzAGgAXwBTAHAAbABpAG4AZQBSAG8AdABUAGUAeAB0AHUAcgBlAAAAUwBjAGUAbgBlAF8AUwBwAGwAaQBuAGUATQBlAHMAaABfAFMAcABsAGkAbgBlAFMAYQBtAHAAbABlAHIAAAARAAAAQmF0Y2hlZFByaW1pdGl2ZQARAAAAQmF0Y2hlZFByaW1pdGl2ZQARAxAAAwEAAAAWAAAAQgBhAHQAYwBoAGUAZABQAHIAaQBtAGkAdABpAHYAZQBfAEQAYQB0AGEAAAAOAAAAU3BlZWRUcmVlRGF0YQAAAAAAAAFgAgEAAAAAAAAAAAsAAABBdG1vc3BoZXJlAAAAAAAAAbAAAQAAAAAAAAAACgAAAEJsdWVOb2lzZQAAAAAADQE1AAEAAAAALgAAAEIAbAB1AGUATgBvAGkAcwBlAF8AUwBjAGEAbABhAHIAVABlAHgAdAB1AHIAZQAAAEIAbAB1AGUATgBvAGkAcwBlAF8AVgBlAGMAMgBUAGUAeAB0AHUAcgBlAAAACQAAAEJhc2VQYXNzAAAAAABRFoEFAQAAAAC8BgAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABfAEQAaQByAGUAYwB0AGkAbwBuAGEAbABMAGkAZwBoAHQAUwBoAGEAZABvAHcAbQBhAHAAQQB0AGwAYQBzAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABfAFMAaABhAGQAbwB3AG0AYQBwAFMAYQBtAHAAbABlAHIAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBtAGEAcAAAAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQAXwBTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBtAGEAcABTAGEAbQBwAGwAZQByAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABfAEYAbwByAHcAYQByAGQATABvAGMAYQBsAEwAaQBnAGgAdABCAHUAZgBmAGUAcgAAAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQAXwBOAHUAbQBDAHUAbABsAGUAZABMAGkAZwBoAHQAcwBHAHIAaQBkAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABfAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABEAGEAdABhAEcAcgBpAGQAMwAyAEIAaQB0AAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABfAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABEAGEAdABhAEcAcgBpAGQAMQA2AEIAaQB0AAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAEQAaQByAGUAYwB0AGkAbwBuAGEAbABMAGkAZwBoAHQAUwBoAGEAZABvAHcAbQBhAHAAQQB0AGwAYQBzAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAFMAaABhAGQAbwB3AG0AYQBwAFMAYQBtAHAAbABlAHIAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAEkAUwBSAF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBtAGEAcAAAAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQASQBTAFIAXwBTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBtAGEAcABTAGEAbQBwAGwAZQByAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAEYAbwByAHcAYQByAGQATABvAGMAYQBsAEwAaQBnAGgAdABCAHUAZgBmAGUAcgAAAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQASQBTAFIAXwBOAHUAbQBDAHUAbABsAGUAZABMAGkAZwBoAHQAcwBHAHIAaQBkAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABEAGEAdABhAEcAcgBpAGQAMwAyAEIAaQB0AAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABEAGEAdABhAEcAcgBpAGQAMQA2AEIAaQB0AAAAQgBhAHMAZQBQAGEAcwBzAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFMAawB5AEwAaQBnAGgAdABDAHUAYgBlAG0AYQBwAAAAQgBhAHMAZQBQAGEAcwBzAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFMAawB5AEwAaQBnAGgAdABDAHUAYgBlAG0AYQBwAFMAYQBtAHAAbABlAHIAAABCAGEAcwBlAFAAYQBzAHMAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUwBrAHkATABpAGcAaAB0AEIAbABlAG4AZABEAGUAcwB0AGkAbgBhAHQAaQBvAG4AQwB1AGIAZQBtAGEAcAAAAEIAYQBzAGUAUABhAHMAcwBfAFIAZQBmAGwAZQBjAHQAaQBvAG4AXwBTAGsAeQBMAGkAZwBoAHQAQgBsAGUAbgBkAEQAZQBzAHQAaQBuAGEAdABpAG8AbgBDAHUAYgBlAG0AYQBwAFMAYQBtAHAAbABlAHIAAABCAGEAcwBlAFAAYQBzAHMAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUgBlAGYAbABlAGMAdABpAG8AbgBDAHUAYgBlAG0AYQBwAAAAQgBhAHMAZQBQAGEAcwBzAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFIAZQBmAGwAZQBjAHQAaQBvAG4AQwB1AGIAZQBtAGEAcABTAGEAbQBwAGwAZQByAAAAQgBhAHMAZQBQAGEAcwBzAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQARwBGAAAAQgBhAHMAZQBQAGEAcwBzAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQARwBGAFMAYQBtAHAAbABlAHIAAABCAGEAcwBlAFAAYQBzAHMAXwBQAGwAYQBuAGEAcgBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUABsAGEAbgBhAHIAUgBlAGYAbABlAGMAdABpAG8AbgBUAGUAeAB0AHUAcgBlAAAAQgBhAHMAZQBQAGEAcwBzAF8AUABsAGEAbgBhAHIAUgBlAGYAbABlAGMAdABpAG8AbgBfAFAAbABhAG4AYQByAFIAZQBmAGwAZQBjAHQAaQBvAG4AUwBhAG0AcABsAGUAcgAAAEIAYQBzAGUAUABhAHMAcwBfAEYAbwBnAF8ARgBvAGcASQBuAHMAYwBhAHQAdABlAHIAaQBuAGcAQwBvAGwAbwByAEMAdQBiAGUAbQBhAHAAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AZwBfAEYAbwBnAEkAbgBzAGMAYQB0AHQAZQByAGkAbgBnAEMAbwBsAG8AcgBTAGEAbQBwAGwAZQByAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAGcAXwBJAG4AdABlAGcAcgBhAHQAZQBkAEwAaQBnAGgAdABTAGMAYQB0AHQAZQByAGkAbgBnAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAGcAXwBJAG4AdABlAGcAcgBhAHQAZQBkAEwAaQBnAGgAdABTAGMAYQB0AHQAZQByAGkAbgBnAFMAYQBtAHAAbABlAHIAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AZwBJAFMAUgBfAEYAbwBnAEkAbgBzAGMAYQB0AHQAZQByAGkAbgBnAEMAbwBsAG8AcgBDAHUAYgBlAG0AYQBwAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAGcASQBTAFIAXwBGAG8AZwBJAG4AcwBjAGEAdAB0AGUAcgBpAG4AZwBDAG8AbABvAHIAUwBhAG0AcABsAGUAcgAAAEIAYQBzAGUAUABhAHMAcwBfAEYAbwBnAEkAUwBSAF8ASQBuAHQAZQBnAHIAYQB0AGUAZABMAGkAZwBoAHQAUwBjAGEAdAB0AGUAcgBpAG4AZwAAAEIAYQBzAGUAUABhAHMAcwBfAEYAbwBnAEkAUwBSAF8ASQBuAHQAZQBnAHIAYQB0AGUAZABMAGkAZwBoAHQAUwBjAGEAdAB0AGUAcgBpAG4AZwBTAGEAbQBwAGwAZQByAAAAQgBhAHMAZQBQAGEAcwBzAF8ATABGAFYAXwBMAG8AYwBhAGwARgBvAGcAVgBvAGwAdQBtAGUASQBuAHMAdABhAG4AYwBlAHMAAABCAGEAcwBlAFAAYQBzAHMAXwBMAEYAVgBfAEwAbwBjAGEAbABGAG8AZwBWAG8AbAB1AG0AZQBUAGkAbABlAEQAYQB0AGEAVABlAHgAdAB1AHIAZQAAAEIAYQBzAGUAUABhAHMAcwBfAEwAaQBnAGgAdABGAHUAbgBjAHQAaQBvAG4AQQB0AGwAYQBzAF8ATABpAGcAaAB0AEYAdQBuAGMAdABpAG8AbgBBAHQAbABhAHMAVABlAHgAdAB1AHIAZQAAAEIAYQBzAGUAUABhAHMAcwBfAEwAaQBnAGgAdABGAHUAbgBjAHQAaQBvAG4AQQB0AGwAYQBzAF8ATABpAGcAaAB0AEkAbgBmAG8ARABhAHQAYQBCAHUAZgBmAGUAcgAAAEIAYQBzAGUAUABhAHMAcwBfAEwAaQBnAGgAdABGAHUAbgBjAHQAaQBvAG4AQQB0AGwAYQBzAF8ATABpAGcAaAB0AEYAdQBuAGMAdABpAG8AbgBBAHQAbABhAHMAUwBhAG0AcABsAGUAcgAAAA8AAABPcGFxdWVCYXNlUGFzcwAOAAAAU2NlbmVUZXh0dXJlcwCxAU0aAgAAAAAOCwAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBGAG8AcgB3AGEAcgBkAF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAGgAYQBkAG8AdwBtAGEAcABBAHQAbABhAHMAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwByAHcAYQByAGQAXwBTAGgAYQBkAG8AdwBtAGEAcABTAGEAbQBwAGwAZQByAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBGAG8AcgB3AGEAcgBkAF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBtAGEAcAAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABfAFMAdABhAHQAaQBjAFMAaABhAGQAbwB3AG0AYQBwAFMAYQBtAHAAbABlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwByAHcAYQByAGQAXwBGAG8AcgB3AGEAcgBkAEwAbwBjAGEAbABMAGkAZwBoAHQAQgB1AGYAZgBlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwByAHcAYQByAGQAXwBOAHUAbQBDAHUAbABsAGUAZABMAGkAZwBoAHQAcwBHAHIAaQBkAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBGAG8AcgB3AGEAcgBkAF8AQwB1AGwAbABlAGQATABpAGcAaAB0AEQAYQB0AGEARwByAGkAZAAzADIAQgBpAHQAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwByAHcAYQByAGQAXwBDAHUAbABsAGUAZABMAGkAZwBoAHQARABhAHQAYQBHAHIAaQBkADEANgBCAGkAdAAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAEQAaQByAGUAYwB0AGkAbwBuAGEAbABMAGkAZwBoAHQAUwBoAGEAZABvAHcAbQBhAHAAQQB0AGwAYQBzAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBGAG8AcgB3AGEAcgBkAEkAUwBSAF8AUwBoAGEAZABvAHcAbQBhAHAAUwBhAG0AcABsAGUAcgAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAEQAaQByAGUAYwB0AGkAbwBuAGEAbABMAGkAZwBoAHQAUwB0AGEAdABpAGMAUwBoAGEAZABvAHcAbQBhAHAAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwByAHcAYQByAGQASQBTAFIAXwBTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBtAGEAcABTAGEAbQBwAGwAZQByAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBGAG8AcgB3AGEAcgBkAEkAUwBSAF8ARgBvAHIAdwBhAHIAZABMAG8AYwBhAGwATABpAGcAaAB0AEIAdQBmAGYAZQByAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBGAG8AcgB3AGEAcgBkAEkAUwBSAF8ATgB1AG0AQwB1AGwAbABlAGQATABpAGcAaAB0AHMARwByAGkAZAAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABEAGEAdABhAEcAcgBpAGQAMwAyAEIAaQB0AAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBGAG8AcgB3AGEAcgBkAEkAUwBSAF8AQwB1AGwAbABlAGQATABpAGcAaAB0AEQAYQB0AGEARwByAGkAZAAxADYAQgBpAHQAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAFIAZQBmAGwAZQBjAHQAaQBvAG4AXwBTAGsAeQBMAGkAZwBoAHQAQwB1AGIAZQBtAGEAcAAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFMAawB5AEwAaQBnAGgAdABDAHUAYgBlAG0AYQBwAFMAYQBtAHAAbABlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAFIAZQBmAGwAZQBjAHQAaQBvAG4AXwBTAGsAeQBMAGkAZwBoAHQAQgBsAGUAbgBkAEQAZQBzAHQAaQBuAGEAdABpAG8AbgBDAHUAYgBlAG0AYQBwAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUwBrAHkATABpAGcAaAB0AEIAbABlAG4AZABEAGUAcwB0AGkAbgBhAHQAaQBvAG4AQwB1AGIAZQBtAGEAcABTAGEAbQBwAGwAZQByAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUgBlAGYAbABlAGMAdABpAG8AbgBDAHUAYgBlAG0AYQBwAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUgBlAGYAbABlAGMAdABpAG8AbgBDAHUAYgBlAG0AYQBwAFMAYQBtAHAAbABlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAFIAZQBmAGwAZQBjAHQAaQBvAG4AXwBQAHIAZQBJAG4AdABlAGcAcgBhAHQAZQBkAEcARgAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQARwBGAFMAYQBtAHAAbABlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAFAAbABhAG4AYQByAFIAZQBmAGwAZQBjAHQAaQBvAG4AXwBQAGwAYQBuAGEAcgBSAGUAZgBsAGUAYwB0AGkAbwBuAFQAZQB4AHQAdQByAGUAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAFAAbABhAG4AYQByAFIAZQBmAGwAZQBjAHQAaQBvAG4AXwBQAGwAYQBuAGEAcgBSAGUAZgBsAGUAYwB0AGkAbwBuAFMAYQBtAHAAbABlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwBnAF8ARgBvAGcASQBuAHMAYwBhAHQAdABlAHIAaQBuAGcAQwBvAGwAbwByAEMAdQBiAGUAbQBhAHAAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwBnAF8ARgBvAGcASQBuAHMAYwBhAHQAdABlAHIAaQBuAGcAQwBvAGwAbwByAFMAYQBtAHAAbABlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwBnAF8ASQBuAHQAZQBnAHIAYQB0AGUAZABMAGkAZwBoAHQAUwBjAGEAdAB0AGUAcgBpAG4AZwAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAGcAXwBJAG4AdABlAGcAcgBhAHQAZQBkAEwAaQBnAGgAdABTAGMAYQB0AHQAZQByAGkAbgBnAFMAYQBtAHAAbABlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwBnAEkAUwBSAF8ARgBvAGcASQBuAHMAYwBhAHQAdABlAHIAaQBuAGcAQwBvAGwAbwByAEMAdQBiAGUAbQBhAHAAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwBnAEkAUwBSAF8ARgBvAGcASQBuAHMAYwBhAHQAdABlAHIAaQBuAGcAQwBvAGwAbwByAFMAYQBtAHAAbABlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwBnAEkAUwBSAF8ASQBuAHQAZQBnAHIAYQB0AGUAZABMAGkAZwBoAHQAUwBjAGEAdAB0AGUAcgBpAG4AZwAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAGcASQBTAFIAXwBJAG4AdABlAGcAcgBhAHQAZQBkAEwAaQBnAGgAdABTAGMAYQB0AHQAZQByAGkAbgBnAFMAYQBtAHAAbABlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEwARgBWAF8ATABvAGMAYQBsAEYAbwBnAFYAbwBsAHUAbQBlAEkAbgBzAHQAYQBuAGMAZQBzAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBMAEYAVgBfAEwAbwBjAGEAbABGAG8AZwBWAG8AbAB1AG0AZQBUAGkAbABlAEQAYQB0AGEAVABlAHgAdAB1AHIAZQAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ATABpAGcAaAB0AEYAdQBuAGMAdABpAG8AbgBBAHQAbABhAHMAXwBMAGkAZwBoAHQARgB1AG4AYwB0AGkAbwBuAEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBMAGkAZwBoAHQARgB1AG4AYwB0AGkAbwBuAEEAdABsAGEAcwBfAEwAaQBnAGgAdABJAG4AZgBvAEQAYQB0AGEAQgB1AGYAZgBlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEwAaQBnAGgAdABGAHUAbgBjAHQAaQBvAG4AQQB0AGwAYQBzAF8ATABpAGcAaAB0AEYAdQBuAGMAdABpAG8AbgBBAHQAbABhAHMAUwBhAG0AcABsAGUAcgAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAFMAdQBiAHMAdAByAGEAdABlAF8ATQBhAHQAZQByAGkAYQBsAFQAZQB4AHQAdQByAGUAQQByAHIAYQB5AFUAQQBWAFcAaQB0AGgAbwB1AHQAUgBUAHMAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAHUAYgBzAHQAcgBhAHQAZQBfAE8AcABhAHEAdQBlAFIAbwB1AGcAaABSAGUAZgByAGEAYwB0AGkAbwBuAFQAZQB4AHQAdQByAGUAVQBBAFYAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAFMAYwByAGUAZQBuAFMAcABhAGMAZQBTAGgAYQBkAG8AdwBNAGEAcwBrAFQAZQB4AHQAdQByAGUAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBJAG4AZABpAHIAZQBjAHQATwBjAGMAbAB1AHMAaQBvAG4AVABlAHgAdAB1AHIAZQAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAFIAZQBzAG8AbAB2AGUAZABTAGMAZQBuAGUARABlAHAAdABoAFQAZQB4AHQAdQByAGUAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBEAEIAdQBmAGYAZQByAEEAVABlAHgAdAB1AHIAZQAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAEQAQgB1AGYAZgBlAHIAQgBUAGUAeAB0AHUAcgBlAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8ARABCAHUAZgBmAGUAcgBDAFQAZQB4AHQAdQByAGUAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBEAEIAdQBmAGYAZQByAFIAZQBuAGQAZQByAE0AYQBzAGsAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBEAEIAdQBmAGYAZQByAEEAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8ARABCAHUAZgBmAGUAcgBCAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAEQAQgB1AGYAZgBlAHIAQwBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABPAHAAYQBxAHUAZQBCAGEAcwBlAFAAYQBzAHMAXwBQAHIAZQBJAG4AdABlAGcAcgBhAHQAZQBkAEcARgBUAGUAeAB0AHUAcgBlAAAATwBwAGEAcQB1AGUAQgBhAHMAZQBQAGEAcwBzAF8AUAByAGUASQBuAHQAZQBnAHIAYQB0AGUAZABHAEYAUwBhAG0AcABsAGUAcgAAAE8AcABhAHEAdQBlAEIAYQBzAGUAUABhAHMAcwBfAEUAeQBlAEEAZABhAHAAdABhAHQAaQBvAG4AQgB1AGYAZgBlAHIAAAAUAAAAVHJhbnNsdWNlbnRCYXNlUGFzcwAOAAAAU2NlbmVUZXh0dXJlcwBoA9ATAgAAAADMEwAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABfAEQAaQByAGUAYwB0AGkAbwBuAGEAbABMAGkAZwBoAHQAUwBoAGEAZABvAHcAbQBhAHAAQQB0AGwAYQBzAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABfAFMAaABhAGQAbwB3AG0AYQBwAFMAYQBtAHAAbABlAHIAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBGAG8AcgB3AGEAcgBkAF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBtAGEAcAAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwByAHcAYQByAGQAXwBTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBtAGEAcABTAGEAbQBwAGwAZQByAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABfAEYAbwByAHcAYQByAGQATABvAGMAYQBsAEwAaQBnAGgAdABCAHUAZgBmAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwByAHcAYQByAGQAXwBOAHUAbQBDAHUAbABsAGUAZABMAGkAZwBoAHQAcwBHAHIAaQBkAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABfAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABEAGEAdABhAEcAcgBpAGQAMwAyAEIAaQB0AAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABfAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABEAGEAdABhAEcAcgBpAGQAMQA2AEIAaQB0AAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAEQAaQByAGUAYwB0AGkAbwBuAGEAbABMAGkAZwBoAHQAUwBoAGEAZABvAHcAbQBhAHAAQQB0AGwAYQBzAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAFMAaABhAGQAbwB3AG0AYQBwAFMAYQBtAHAAbABlAHIAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBGAG8AcgB3AGEAcgBkAEkAUwBSAF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBtAGEAcAAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwByAHcAYQByAGQASQBTAFIAXwBTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBtAGEAcABTAGEAbQBwAGwAZQByAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAEYAbwByAHcAYQByAGQATABvAGMAYQBsAEwAaQBnAGgAdABCAHUAZgBmAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwByAHcAYQByAGQASQBTAFIAXwBOAHUAbQBDAHUAbABsAGUAZABMAGkAZwBoAHQAcwBHAHIAaQBkAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABEAGEAdABhAEcAcgBpAGQAMwAyAEIAaQB0AAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABEAGEAdABhAEcAcgBpAGQAMQA2AEIAaQB0AAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFMAawB5AEwAaQBnAGgAdABDAHUAYgBlAG0AYQBwAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFMAawB5AEwAaQBnAGgAdABDAHUAYgBlAG0AYQBwAFMAYQBtAHAAbABlAHIAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUwBrAHkATABpAGcAaAB0AEIAbABlAG4AZABEAGUAcwB0AGkAbgBhAHQAaQBvAG4AQwB1AGIAZQBtAGEAcAAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAFIAZQBmAGwAZQBjAHQAaQBvAG4AXwBTAGsAeQBMAGkAZwBoAHQAQgBsAGUAbgBkAEQAZQBzAHQAaQBuAGEAdABpAG8AbgBDAHUAYgBlAG0AYQBwAFMAYQBtAHAAbABlAHIAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUgBlAGYAbABlAGMAdABpAG8AbgBDAHUAYgBlAG0AYQBwAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFIAZQBmAGwAZQBjAHQAaQBvAG4AQwB1AGIAZQBtAGEAcABTAGEAbQBwAGwAZQByAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQARwBGAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQARwBGAFMAYQBtAHAAbABlAHIAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBQAGwAYQBuAGEAcgBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUABsAGEAbgBhAHIAUgBlAGYAbABlAGMAdABpAG8AbgBUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8AUABsAGEAbgBhAHIAUgBlAGYAbABlAGMAdABpAG8AbgBfAFAAbABhAG4AYQByAFIAZQBmAGwAZQBjAHQAaQBvAG4AUwBhAG0AcABsAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwBnAF8ARgBvAGcASQBuAHMAYwBhAHQAdABlAHIAaQBuAGcAQwBvAGwAbwByAEMAdQBiAGUAbQBhAHAAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBGAG8AZwBfAEYAbwBnAEkAbgBzAGMAYQB0AHQAZQByAGkAbgBnAEMAbwBsAG8AcgBTAGEAbQBwAGwAZQByAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAGcAXwBJAG4AdABlAGcAcgBhAHQAZQBkAEwAaQBnAGgAdABTAGMAYQB0AHQAZQByAGkAbgBnAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAGcAXwBJAG4AdABlAGcAcgBhAHQAZQBkAEwAaQBnAGgAdABTAGMAYQB0AHQAZQByAGkAbgBnAFMAYQBtAHAAbABlAHIAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBGAG8AZwBJAFMAUgBfAEYAbwBnAEkAbgBzAGMAYQB0AHQAZQByAGkAbgBnAEMAbwBsAG8AcgBDAHUAYgBlAG0AYQBwAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ARgBvAGcASQBTAFIAXwBGAG8AZwBJAG4AcwBjAGEAdAB0AGUAcgBpAG4AZwBDAG8AbABvAHIAUwBhAG0AcABsAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwBnAEkAUwBSAF8ASQBuAHQAZQBnAHIAYQB0AGUAZABMAGkAZwBoAHQAUwBjAGEAdAB0AGUAcgBpAG4AZwAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEYAbwBnAEkAUwBSAF8ASQBuAHQAZQBnAHIAYQB0AGUAZABMAGkAZwBoAHQAUwBjAGEAdAB0AGUAcgBpAG4AZwBTAGEAbQBwAGwAZQByAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAaABhAHIAZQBkAF8ATABGAFYAXwBMAG8AYwBhAGwARgBvAGcAVgBvAGwAdQBtAGUASQBuAHMAdABhAG4AYwBlAHMAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBoAGEAcgBlAGQAXwBMAEYAVgBfAEwAbwBjAGEAbABGAG8AZwBWAG8AbAB1AG0AZQBUAGkAbABlAEQAYQB0AGEAVABlAHgAdAB1AHIAZQAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEwAaQBnAGgAdABGAHUAbgBjAHQAaQBvAG4AQQB0AGwAYQBzAF8ATABpAGcAaAB0AEYAdQBuAGMAdABpAG8AbgBBAHQAbABhAHMAVABlAHgAdAB1AHIAZQAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEwAaQBnAGgAdABGAHUAbgBjAHQAaQBvAG4AQQB0AGwAYQBzAF8ATABpAGcAaAB0AEkAbgBmAG8ARABhAHQAYQBCAHUAZgBmAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGgAYQByAGUAZABfAEwAaQBnAGgAdABGAHUAbgBjAHQAaQBvAG4AQQB0AGwAYQBzAF8ATABpAGcAaAB0AEYAdQBuAGMAdABpAG8AbgBBAHQAbABhAHMAUwBhAG0AcABsAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEMAbwBsAG8AcgBUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUARABlAHAAdABoAFQAZQB4AHQAdQByAGUAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBQAGEAcgB0AGkAYQBsAEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAEEAVABlAHgAdAB1AHIAZQAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBCAFQAZQB4AHQAdQByAGUAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEcAQgB1AGYAZgBlAHIAQwBUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAEQAVABlAHgAdAB1AHIAZQAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBFAFQAZQB4AHQAdQByAGUAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEcAQgB1AGYAZgBlAHIARgBUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAFYAZQBsAG8AYwBpAHQAeQBUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAcgBlAGUAbgBTAHAAYQBjAGUAQQBPAFQAZQB4AHQAdQByAGUAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEMAdQBzAHQAbwBtAEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBDAHUAcwB0AG8AbQBTAHQAZQBuAGMAaQBsAFQAZQB4AHQAdQByAGUAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFAAbwBpAG4AdABDAGwAYQBtAHAAUwBhAG0AcABsAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAHUAYgBzAHQAcgBhAHQAZQBfAE0AYQB0AGUAcgBpAGEAbABUAGUAeAB0AHUAcgBlAEEAcgByAGEAeQAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAHUAYgBzAHQAcgBhAHQAZQBfAFQAbwBwAEwAYQB5AGUAcgBUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQARABpAHIATABpAGcAaAB0AEMAbABvAHUAZABTAGgAYQBkAG8AdwBfAEMAbABvAHUAZABTAGgAYQBkAG8AdwBtAGEAcABUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQARABpAHIATABpAGcAaAB0AEMAbABvAHUAZABTAGgAYQBkAG8AdwBfAEMAbABvAHUAZABTAGgAYQBkAG8AdwBtAGEAcABTAGEAbQBwAGwAZQByAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAE8ASQBUAF8ATwB1AHQATwBJAFQAUwBhAG0AcABsAGUAQwBvAHUAbgB0AAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAE8ASQBUAF8ATwB1AHQATwBJAFQAUwBhAG0AcABsAGUARABhAHQAYQAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBIAFoAQgBUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAEgAWgBCAFMAYQBtAHAAbABlAHIAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUAByAGUAdgBTAGMAZQBuAGUAQwBvAGwAbwByAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFAAcgBlAHYAUwBjAGUAbgBlAEMAbwBsAG8AcgBTAGEAbQBwAGwAZQByAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMAQwBsAG8AdQBkAEMAbwBsAG8AcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBWAG8AbAB1AG0AZQB0AHIAaQBjAEMAbABvAHUAZABDAG8AbABvAHIAUwBhAG0AcABsAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBWAG8AbAB1AG0AZQB0AHIAaQBjAEMAbABvAHUAZABEAGUAcAB0AGgAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AVgBvAGwAdQBtAGUAdAByAGkAYwBDAGwAbwB1AGQARABlAHAAdABoAFMAYQBtAHAAbABlAHIAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AVAByAGEAbgBzAGwAdQBjAGUAbgBjAHkATABpAGcAaAB0AGkAbgBnAFYAbwBsAHUAbQBlAEEAbQBiAGkAZQBuAHQASQBuAG4AZQByAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFQAcgBhAG4AcwBsAHUAYwBlAG4AYwB5AEwAaQBnAGgAdABpAG4AZwBWAG8AbAB1AG0AZQBBAG0AYgBpAGUAbgB0AE8AdQB0AGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBUAHIAYQBuAHMAbAB1AGMAZQBuAGMAeQBMAGkAZwBoAHQAaQBuAGcAVgBvAGwAdQBtAGUARABpAHIAZQBjAHQAaQBvAG4AYQBsAEkAbgBuAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBUAHIAYQBuAHMAbAB1AGMAZQBuAGMAeQBMAGkAZwBoAHQAaQBuAGcAVgBvAGwAdQBtAGUARABpAHIAZQBjAHQAaQBvAG4AYQBsAE8AdQB0AGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBSAGEAZABpAGEAbgBjAGUAUAByAG8AYgBlAEkAbgBkAGkAcgBlAGMAdABpAG8AbgBUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFIAYQBkAGkAYQBuAGMAZQBDAGEAYwBoAGUARgBpAG4AYQBsAFIAYQBkAGkAYQBuAGMAZQBBAHQAbABhAHMAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUgBhAGQAaQBhAG4AYwBlAEMAYQBjAGgAZQBGAGkAbgBhAGwASQByAHIAYQBkAGkAYQBuAGMAZQBBAHQAbABhAHMAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AUgBhAGQAaQBhAG4AYwBlAEMAYQBjAGgAZQBQAHIAbwBiAGUATwBjAGMAbAB1AHMAaQBvAG4AQQB0AGwAYQBzAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFIAYQBkAGkAYQBuAGMAZQBDAGEAYwBoAGUARABlAHAAdABoAEEAdABsAGEAcwAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBQAHIAbwBiAGUAVwBvAHIAbABkAE8AZgBmAHMAZQB0AAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFIAYQBkAGkAYQBuAGMAZQAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBOAG8AcgBtAGEAbAAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGMAZQBuAGUARABlAHAAdABoAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFQAcgBhAG4AcwBsAHUAYwBlAG4AYwB5AEcASQBWAG8AbAB1AG0AZQAwAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFQAcgBhAG4AcwBsAHUAYwBlAG4AYwB5AEcASQBWAG8AbAB1AG0AZQAxAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFQAcgBhAG4AcwBsAHUAYwBlAG4AYwB5AEcASQBWAG8AbAB1AG0AZQBIAGkAcwB0AG8AcgB5ADAAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AVAByAGEAbgBzAGwAdQBjAGUAbgBjAHkARwBJAFYAbwBsAHUAbQBlAEgAaQBzAHQAbwByAHkAMQAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBUAHIAYQBuAHMAbAB1AGMAZQBuAGMAeQBHAEkAVgBvAGwAdQBtAGUAUwBhAG0AcABsAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBQAHIAZQBJAG4AdABlAGcAcgBhAHQAZQBkAEcARgBUAGUAeAB0AHUAcgBlAAAAVAByAGEAbgBzAGwAdQBjAGUAbgB0AEIAYQBzAGUAUABhAHMAcwBfAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQARwBGAFMAYQBtAHAAbABlAHIAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8ARQB5AGUAQQBkAGEAcAB0AGEAdABpAG8AbgBCAHUAZgBmAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGMAZQBuAGUAQwBvAGwAbwByAEMAbwBwAHkAVABlAHgAdAB1AHIAZQAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBTAGMAZQBuAGUAQwBvAGwAbwByAEMAbwBwAHkAUwBhAG0AcABsAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBCAGwAdQBlAE4AbwBpAHMAZQBfAFMAYwBhAGwAYQByAFQAZQB4AHQAdQByAGUAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AQgBsAHUAZQBOAG8AaQBzAGUAXwBWAGUAYwAyAFQAZQB4AHQAdQByAGUAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AQQBWAFMATQBfAEwAaQBuAGsAZQBkAEwAaQBzAHQAQgB1AGYAZgBlAHIAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAQgBhAHMAZQBQAGEAcwBzAF8AQQBWAFMATQBfAEkAbgBkAGkAcgBlAGMAdABpAG8AbgBCAHUAZgBmAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABCAGEAcwBlAFAAYQBzAHMAXwBBAFYAUwBNAF8AUwBhAG0AcABsAGUAQgB1AGYAZgBlAHIAAAAWAAAASW5kaXJlY3RMaWdodGluZ0NhY2hlAAAAAAAFCR0EAQAAAABNAQAASQBuAGQAaQByAGUAYwB0AEwAaQBnAGgAdABpAG4AZwBDAGEAYwBoAGUAXwBJAG4AZABpAHIAZQBjAHQATABpAGcAaAB0AGkAbgBnAEMAYQBjAGgAZQBUAGUAeAB0AHUAcgBlADAAAABJAG4AZABpAHIAZQBjAHQATABpAGcAaAB0AGkAbgBnAEMAYQBjAGgAZQBfAEkAbgBkAGkAcgBlAGMAdABMAGkAZwBoAHQAaQBuAGcAQwBhAGMAaABlAFQAZQB4AHQAdQByAGUAMQAAAEkAbgBkAGkAcgBlAGMAdABMAGkAZwBoAHQAaQBuAGcAQwBhAGMAaABlAF8ASQBuAGQAaQByAGUAYwB0AEwAaQBnAGgAdABpAG4AZwBDAGEAYwBoAGUAVABlAHgAdAB1AHIAZQAyAAAASQBuAGQAaQByAGUAYwB0AEwAaQBnAGgAdABpAG4AZwBDAGEAYwBoAGUAXwBJAG4AZABpAHIAZQBjAHQATABpAGcAaAB0AGkAbgBnAEMAYQBjAGgAZQBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAMAAAAEkAbgBkAGkAcgBlAGMAdABMAGkAZwBoAHQAaQBuAGcAQwBhAGMAaABlAF8ASQBuAGQAaQByAGUAYwB0AEwAaQBnAGgAdABpAG4AZwBDAGEAYwBoAGUAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByADEAAABJAG4AZABpAHIAZQBjAHQATABpAGcAaAB0AGkAbgBnAEMAYQBjAGgAZQBfAEkAbgBkAGkAcgBlAGMAdABMAGkAZwBoAHQAaQBuAGcAQwBhAGMAaABlAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAyAAAAGAAAAExpZ2h0bWFwUmVzb3VyY2VDbHVzdGVyAAAAAAAOD4MNAQAAAADhAgAATABpAGcAaAB0AG0AYQBwAFIAZQBzAG8AdQByAGMAZQBDAGwAdQBzAHQAZQByAF8ATABpAGcAaAB0AE0AYQBwAFQAZQB4AHQAdQByAGUAAABMAGkAZwBoAHQAbQBhAHAAUgBlAHMAbwB1AHIAYwBlAEMAbAB1AHMAdABlAHIAXwBTAGsAeQBPAGMAYwBsAHUAcwBpAG8AbgBUAGUAeAB0AHUAcgBlAAAATABpAGcAaAB0AG0AYQBwAFIAZQBzAG8AdQByAGMAZQBDAGwAdQBzAHQAZQByAF8AQQBPAE0AYQB0AGUAcgBpAGEAbABNAGEAcwBrAFQAZQB4AHQAdQByAGUAAABMAGkAZwBoAHQAbQBhAHAAUgBlAHMAbwB1AHIAYwBlAEMAbAB1AHMAdABlAHIAXwBTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBUAGUAeAB0AHUAcgBlAAAATABpAGcAaAB0AG0AYQBwAFIAZQBzAG8AdQByAGMAZQBDAGwAdQBzAHQAZQByAF8AVgBUAEwAaQBnAGgAdABNAGEAcABUAGUAeAB0AHUAcgBlAAAATABpAGcAaAB0AG0AYQBwAFIAZQBzAG8AdQByAGMAZQBDAGwAdQBzAHQAZQByAF8AVgBUAEwAaQBnAGgAdABNAGEAcABUAGUAeAB0AHUAcgBlAF8AMQAAAEwAaQBnAGgAdABtAGEAcABSAGUAcwBvAHUAcgBjAGUAQwBsAHUAcwB0AGUAcgBfAFYAVABTAGsAeQBPAGMAYwBsAHUAcwBpAG8AbgBUAGUAeAB0AHUAcgBlAAAATABpAGcAaAB0AG0AYQBwAFIAZQBzAG8AdQByAGMAZQBDAGwAdQBzAHQAZQByAF8AVgBUAEEATwBNAGEAdABlAHIAaQBhAGwATQBhAHMAawBUAGUAeAB0AHUAcgBlAAAATABpAGcAaAB0AG0AYQBwAFIAZQBzAG8AdQByAGMAZQBDAGwAdQBzAHQAZQByAF8AVgBUAFMAdABhAHQAaQBjAFMAaABhAGQAbwB3AFQAZQB4AHQAdQByAGUAAABMAGkAZwBoAHQAbQBhAHAAUgBlAHMAbwB1AHIAYwBlAEMAbAB1AHMAdABlAHIAXwBMAGkAZwBoAHQATQBhAHAAUwBhAG0AcABsAGUAcgAAAEwAaQBnAGgAdABtAGEAcABSAGUAcwBvAHUAcgBjAGUAQwBsAHUAcwB0AGUAcgBfAEwAaQBnAGgAdABNAGEAcABTAGEAbQBwAGwAZQByAF8AMQAAAEwAaQBnAGgAdABtAGEAcABSAGUAcwBvAHUAcgBjAGUAQwBsAHUAcwB0AGUAcgBfAFMAawB5AE8AYwBjAGwAdQBzAGkAbwBuAFMAYQBtAHAAbABlAHIAAABMAGkAZwBoAHQAbQBhAHAAUgBlAHMAbwB1AHIAYwBlAEMAbAB1AHMAdABlAHIAXwBBAE8ATQBhAHQAZQByAGkAYQBsAE0AYQBzAGsAUwBhAG0AcABsAGUAcgAAAEwAaQBnAGgAdABtAGEAcABSAGUAcwBvAHUAcgBjAGUAQwBsAHUAcwB0AGUAcgBfAFMAdABhAHQAaQBjAFMAaABhAGQAbwB3AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAEwAaQBnAGgAdABtAGEAcABSAGUAcwBvAHUAcgBjAGUAQwBsAHUAcwB0AGUAcgBfAEwAaQBnAGgAdABtAGEAcABWAGkAcgB0AHUAYQBsAFQAZQB4AHQAdQByAGUAUABhAGcAZQBUAGEAYgBsAGUAMAAAAEwAaQBnAGgAdABtAGEAcABSAGUAcwBvAHUAcgBjAGUAQwBsAHUAcwB0AGUAcgBfAEwAaQBnAGgAdABtAGEAcABWAGkAcgB0AHUAYQBsAFQAZQB4AHQAdQByAGUAUABhAGcAZQBUAGEAYgBsAGUAMQAAABoAAABQcmVjb21wdXRlZExpZ2h0aW5nQnVmZmVyAAAAAAAAAfAAAQAAAAAAAAAAFwAAAFBsYW5hclJlZmxlY3Rpb25TdHJ1Y3QAAAAAAAABVQEBAAAAAF4AAABQAGwAYQBuAGEAcgBSAGUAZgBsAGUAYwB0AGkAbwBuAFMAdAByAHUAYwB0AF8AUABsAGEAbgBhAHIAUgBlAGYAbABlAGMAdABpAG8AbgBUAGUAeAB0AHUAcgBlAAAAUABsAGEAbgBhAHIAUgBlAGYAbABlAGMAdABpAG8AbgBTAHQAcgB1AGMAdABfAFAAbABhAG4AYQByAFIAZQBmAGwAZQBjAHQAaQBvAG4AUwBhAG0AcABsAGUAcgAAABEAAABSZWZsZWN0aW9uU3RydWN0AAAAAAAAAVAMAQAAAABIAQAAUgBlAGYAbABlAGMAdABpAG8AbgBTAHQAcgB1AGMAdABfAFMAawB5AEwAaQBnAGgAdABDAHUAYgBlAG0AYQBwAAAAUgBlAGYAbABlAGMAdABpAG8AbgBTAHQAcgB1AGMAdABfAFMAawB5AEwAaQBnAGgAdABDAHUAYgBlAG0AYQBwAFMAYQBtAHAAbABlAHIAAABSAGUAZgBsAGUAYwB0AGkAbwBuAFMAdAByAHUAYwB0AF8AUwBrAHkATABpAGcAaAB0AEIAbABlAG4AZABEAGUAcwB0AGkAbgBhAHQAaQBvAG4AQwB1AGIAZQBtAGEAcAAAAFIAZQBmAGwAZQBjAHQAaQBvAG4AUwB0AHIAdQBjAHQAXwBTAGsAeQBMAGkAZwBoAHQAQgBsAGUAbgBkAEQAZQBzAHQAaQBuAGEAdABpAG8AbgBDAHUAYgBlAG0AYQBwAFMAYQBtAHAAbABlAHIAAABSAGUAZgBsAGUAYwB0AGkAbwBuAFMAdAByAHUAYwB0AF8AUgBlAGYAbABlAGMAdABpAG8AbgBDAHUAYgBlAG0AYQBwAAAAUgBlAGYAbABlAGMAdABpAG8AbgBTAHQAcgB1AGMAdABfAFIAZQBmAGwAZQBjAHQAaQBvAG4AQwB1AGIAZQBtAGEAcABTAGEAbQBwAGwAZQByAAAAUgBlAGYAbABlAGMAdABpAG8AbgBTAHQAcgB1AGMAdABfAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQARwBGAAAAUgBlAGYAbABlAGMAdABpAG8AbgBTAHQAcgB1AGMAdABfAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQARwBGAFMAYQBtAHAAbABlAHIAAAAKAAAARm9nU3RydWN0AAAAAAAoCMgFAQAAAACbAAAARgBvAGcAUwB0AHIAdQBjAHQAXwBGAG8AZwBJAG4AcwBjAGEAdAB0AGUAcgBpAG4AZwBDAG8AbABvAHIAQwB1AGIAZQBtAGEAcAAAAEYAbwBnAFMAdAByAHUAYwB0AF8ARgBvAGcASQBuAHMAYwBhAHQAdABlAHIAaQBuAGcAQwBvAGwAbwByAFMAYQBtAHAAbABlAHIAAABGAG8AZwBTAHQAcgB1AGMAdABfAEkAbgB0AGUAZwByAGEAdABlAGQATABpAGcAaAB0AFMAYwBhAHQAdABlAHIAaQBuAGcAAABGAG8AZwBTAHQAcgB1AGMAdABfAEkAbgB0AGUAZwByAGEAdABlAGQATABpAGcAaAB0AFMAYwBhAHQAdABlAHIAaQBuAGcAUwBhAG0AcABsAGUAcgAAABYAAABSZWZsZWN0aW9uQ2FwdHVyZUVTMzEAEgAAAFJlZmxlY3Rpb25DYXB0dXJlAAEDQDgDAQAAAAAAAAAVAAAAUmVmbGVjdGlvbkNhcHR1cmVTTTUAEgAAAFJlZmxlY3Rpb25DYXB0dXJlAAED0L8DAAAAAAAAAAAUAAAATHVtZW5HSVZvbHVtZVN0cnVjdAAAAAAA2AtACwEAAAAAYQIAAEwAdQBtAGUAbgBHAEkAVgBvAGwAdQBtAGUAUwB0AHIAdQBjAHQAXwBSAGEAZABpAGEAbgBjAGUAUAByAG8AYgBlAEkAbgBkAGkAcgBlAGMAdABpAG8AbgBUAGUAeAB0AHUAcgBlAAAATAB1AG0AZQBuAEcASQBWAG8AbAB1AG0AZQBTAHQAcgB1AGMAdABfAFIAYQBkAGkAYQBuAGMAZQBDAGEAYwBoAGUARgBpAG4AYQBsAFIAYQBkAGkAYQBuAGMAZQBBAHQAbABhAHMAAABMAHUAbQBlAG4ARwBJAFYAbwBsAHUAbQBlAFMAdAByAHUAYwB0AF8AUgBhAGQAaQBhAG4AYwBlAEMAYQBjAGgAZQBGAGkAbgBhAGwASQByAHIAYQBkAGkAYQBuAGMAZQBBAHQAbABhAHMAAABMAHUAbQBlAG4ARwBJAFYAbwBsAHUAbQBlAFMAdAByAHUAYwB0AF8AUgBhAGQAaQBhAG4AYwBlAEMAYQBjAGgAZQBQAHIAbwBiAGUATwBjAGMAbAB1AHMAaQBvAG4AQQB0AGwAYQBzAAAATAB1AG0AZQBuAEcASQBWAG8AbAB1AG0AZQBTAHQAcgB1AGMAdABfAFIAYQBkAGkAYQBuAGMAZQBDAGEAYwBoAGUARABlAHAAdABoAEEAdABsAGEAcwAAAEwAdQBtAGUAbgBHAEkAVgBvAGwAdQBtAGUAUwB0AHIAdQBjAHQAXwBQAHIAbwBiAGUAVwBvAHIAbABkAE8AZgBmAHMAZQB0AAAATAB1AG0AZQBuAEcASQBWAG8AbAB1AG0AZQBTAHQAcgB1AGMAdABfAFIAYQBkAGkAYQBuAGMAZQAAAEwAdQBtAGUAbgBHAEkAVgBvAGwAdQBtAGUAUwB0AHIAdQBjAHQAXwBOAG8AcgBtAGEAbAAAAEwAdQBtAGUAbgBHAEkAVgBvAGwAdQBtAGUAUwB0AHIAdQBjAHQAXwBTAGMAZQBuAGUARABlAHAAdABoAAAATAB1AG0AZQBuAEcASQBWAG8AbAB1AG0AZQBTAHQAcgB1AGMAdABfAFQAcgBhAG4AcwBsAHUAYwBlAG4AYwB5AEcASQBWAG8AbAB1AG0AZQAwAAAATAB1AG0AZQBuAEcASQBWAG8AbAB1AG0AZQBTAHQAcgB1AGMAdABfAFQAcgBhAG4AcwBsAHUAYwBlAG4AYwB5AEcASQBWAG8AbAB1AG0AZQAxAAAATAB1AG0AZQBuAEcASQBWAG8AbAB1AG0AZQBTAHQAcgB1AGMAdABfAFQAcgBhAG4AcwBsAHUAYwBlAG4AYwB5AEcASQBWAG8AbAB1AG0AZQBIAGkAcwB0AG8AcgB5ADAAAABMAHUAbQBlAG4ARwBJAFYAbwBsAHUAbQBlAFMAdAByAHUAYwB0AF8AVAByAGEAbgBzAGwAdQBjAGUAbgBjAHkARwBJAFYAbwBsAHUAbQBlAEgAaQBzAHQAbwByAHkAMQAAAEwAdQBtAGUAbgBHAEkAVgBvAGwAdQBtAGUAUwB0AHIAdQBjAHQAXwBUAHIAYQBuAHMAbAB1AGMAZQBuAGMAeQBHAEkAVgBvAGwAdQBtAGUAUwBhAG0AcABsAGUAcgAAABYAAABUcmFuc2x1Y2VudFNlbGZTaGFkb3cAAAAAAAgJlQUBAAAAAJ4AAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAUwBlAGwAZgBTAGgAYQBkAG8AdwBfAFQAcgBhAG4AcwBtAGkAcwBzAGkAbwBuADAAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAUwBlAGwAZgBTAGgAYQBkAG8AdwBfAFQAcgBhAG4AcwBtAGkAcwBzAGkAbwBuADEAAABUAHIAYQBuAHMAbAB1AGMAZQBuAHQAUwBlAGwAZgBTAGgAYQBkAG8AdwBfAFQAcgBhAG4AcwBtAGkAcwBzAGkAbwBuADAAUwBhAG0AcABsAGUAcgAAAFQAcgBhAG4AcwBsAHUAYwBlAG4AdABTAGUAbABmAFMAaABhAGQAbwB3AF8AVAByAGEAbgBzAG0AaQBzAHMAaQBvAG4AMQBTAGEAbQBwAGwAZQByAAAAEQAAAEZvcndhcmRMaWdodERhdGEAAAAAABgU+BsBAAAAAE0BAABGAG8AcgB3AGEAcgBkAEwAaQBnAGgAdABEAGEAdABhAF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAGgAYQBkAG8AdwBtAGEAcABBAHQAbABhAHMAAABGAG8AcgB3AGEAcgBkAEwAaQBnAGgAdABEAGEAdABhAF8AUwBoAGEAZABvAHcAbQBhAHAAUwBhAG0AcABsAGUAcgAAAEYAbwByAHcAYQByAGQATABpAGcAaAB0AEQAYQB0AGEAXwBEAGkAcgBlAGMAdABpAG8AbgBhAGwATABpAGcAaAB0AFMAdABhAHQAaQBjAFMAaABhAGQAbwB3AG0AYQBwAAAARgBvAHIAdwBhAHIAZABMAGkAZwBoAHQARABhAHQAYQBfAFMAdABhAHQAaQBjAFMAaABhAGQAbwB3AG0AYQBwAFMAYQBtAHAAbABlAHIAAABGAG8AcgB3AGEAcgBkAEwAaQBnAGgAdABEAGEAdABhAF8ARgBvAHIAdwBhAHIAZABMAG8AYwBhAGwATABpAGcAaAB0AEIAdQBmAGYAZQByAAAARgBvAHIAdwBhAHIAZABMAGkAZwBoAHQARABhAHQAYQBfAE4AdQBtAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABzAEcAcgBpAGQAAABGAG8AcgB3AGEAcgBkAEwAaQBnAGgAdABEAGEAdABhAF8AQwB1AGwAbABlAGQATABpAGcAaAB0AEQAYQB0AGEARwByAGkAZAAzADIAQgBpAHQAAABGAG8AcgB3AGEAcgBkAEwAaQBnAGgAdABEAGEAdABhAF8AQwB1AGwAbABlAGQATABpAGcAaAB0AEQAYQB0AGEARwByAGkAZAAxADYAQgBpAHQAAAAWAAAARGVmZXJyZWRMaWdodFVuaWZvcm1zAAAAAAAAAbAAAQAAAAAAAAAAEwAAAExpZ2h0RnVuY3Rpb25BdGxhcwAAAAAAGQEwAAEAAAAAgQAAAEwAaQBnAGgAdABGAHUAbgBjAHQAaQBvAG4AQQB0AGwAYQBzAF8ATABpAGcAaAB0AEYAdQBuAGMAdABpAG8AbgBBAHQAbABhAHMAVABlAHgAdAB1AHIAZQAAAEwAaQBnAGgAdABGAHUAbgBjAHQAaQBvAG4AQQB0AGwAYQBzAF8ATABpAGcAaAB0AEkAbgBmAG8ARABhAHQAYQBCAHUAZgBmAGUAcgAAAEwAaQBnAGgAdABGAHUAbgBjAHQAaQBvAG4AQQB0AGwAYQBzAF8ATABpAGcAaAB0AEYAdQBuAGMAdABpAG8AbgBBAHQAbABhAHMAUwBhAG0AcABsAGUAcgAAAA0AAABMaWdodDBTaGFkb3cAAAAAANAE0AsBAAAAAA4BAABMAGkAZwBoAHQAMABTAGgAYQBkAG8AdwBfAFMAaABhAGQAbwB3AEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAAAATABpAGcAaAB0ADAAUwBoAGEAZABvAHcAXwBTAGgAYQBkAG8AdwBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATABpAGcAaAB0ADAAUwBoAGEAZABvAHcAXwBTAGgAYQBkAG8AdwBEAGUAcAB0AGgAQwB1AGIAZQBUAGUAeAB0AHUAcgBlAAAATABpAGcAaAB0ADAAUwBoAGEAZABvAHcAXwBTAGgAYQBkAG8AdwBEAGUAcAB0AGgAQwB1AGIAZQBUAGUAeAB0AHUAcgBlADIAAABMAGkAZwBoAHQAMABTAGgAYQBkAG8AdwBfAFMAaABhAGQAbwB3AEQAZQBwAHQAaABDAHUAYgBlAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAEwAaQBnAGgAdAAwAFMAaABhAGQAbwB3AF8AUwB0AGEAdABpAGMAUwBoAGEAZABvAHcARABlAHAAdABoAFQAZQB4AHQAdQByAGUAAABMAGkAZwBoAHQAMABTAGgAYQBkAG8AdwBfAFMAdABhAHQAaQBjAFMAaABhAGQAbwB3AEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAAANAAAATGlnaHQxU2hhZG93AAAAAADQBNALAQAAAAAOAQAATABpAGcAaAB0ADEAUwBoAGEAZABvAHcAXwBTAGgAYQBkAG8AdwBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAEwAaQBnAGgAdAAxAFMAaABhAGQAbwB3AF8AUwBoAGEAZABvAHcARABlAHAAdABoAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAEwAaQBnAGgAdAAxAFMAaABhAGQAbwB3AF8AUwBoAGEAZABvAHcARABlAHAAdABoAEMAdQBiAGUAVABlAHgAdAB1AHIAZQAAAEwAaQBnAGgAdAAxAFMAaABhAGQAbwB3AF8AUwBoAGEAZABvAHcARABlAHAAdABoAEMAdQBiAGUAVABlAHgAdAB1AHIAZQAyAAAATABpAGcAaAB0ADEAUwBoAGEAZABvAHcAXwBTAGgAYQBkAG8AdwBEAGUAcAB0AGgAQwB1AGIAZQBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABMAGkAZwBoAHQAMQBTAGgAYQBkAG8AdwBfAFMAdABhAHQAaQBjAFMAaABhAGQAbwB3AEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAAAATABpAGcAaAB0ADEAUwBoAGEAZABvAHcAXwBTAHQAYQB0AGkAYwBTAGgAYQBkAG8AdwBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAADwAAAE1vYmlsZUJhc2VQYXNzAA4AAABTY2VuZVRleHR1cmVzAGUL/RYCAAAAAMUNAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBGAG8AZwBfAEYAbwBnAEkAbgBzAGMAYQB0AHQAZQByAGkAbgBnAEMAbwBsAG8AcgBDAHUAYgBlAG0AYQBwAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAGcAXwBGAG8AZwBJAG4AcwBjAGEAdAB0AGUAcgBpAG4AZwBDAG8AbABvAHIAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwBnAF8ASQBuAHQAZQBnAHIAYQB0AGUAZABMAGkAZwBoAHQAUwBjAGEAdAB0AGUAcgBpAG4AZwAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwBnAF8ASQBuAHQAZQBnAHIAYQB0AGUAZABMAGkAZwBoAHQAUwBjAGEAdAB0AGUAcgBpAG4AZwBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8ATABGAFYAXwBMAG8AYwBhAGwARgBvAGcAVgBvAGwAdQBtAGUASQBuAHMAdABhAG4AYwBlAHMAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBMAEYAVgBfAEwAbwBjAGEAbABGAG8AZwBWAG8AbAB1AG0AZQBUAGkAbABlAEQAYQB0AGEAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQAXwBEAGkAcgBlAGMAdABpAG8AbgBhAGwATABpAGcAaAB0AFMAaABhAGQAbwB3AG0AYQBwAEEAdABsAGEAcwAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQAXwBTAGgAYQBkAG8AdwBtAGEAcABTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABfAEQAaQByAGUAYwB0AGkAbwBuAGEAbABMAGkAZwBoAHQAUwB0AGEAdABpAGMAUwBoAGEAZABvAHcAbQBhAHAAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAF8AUwB0AGEAdABpAGMAUwBoAGEAZABvAHcAbQBhAHAAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQAXwBGAG8AcgB3AGEAcgBkAEwAbwBjAGEAbABMAGkAZwBoAHQAQgB1AGYAZgBlAHIAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAF8ATgB1AG0AQwB1AGwAbABlAGQATABpAGcAaAB0AHMARwByAGkAZAAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQAXwBDAHUAbABsAGUAZABMAGkAZwBoAHQARABhAHQAYQBHAHIAaQBkADMAMgBCAGkAdAAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQAXwBDAHUAbABsAGUAZABMAGkAZwBoAHQARABhAHQAYQBHAHIAaQBkADEANgBCAGkAdAAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQATQBNAFYAXwBEAGkAcgBlAGMAdABpAG8AbgBhAGwATABpAGcAaAB0AFMAaABhAGQAbwB3AG0AYQBwAEEAdABsAGEAcwAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQATQBNAFYAXwBTAGgAYQBkAG8AdwBtAGEAcABTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABNAE0AVgBfAEQAaQByAGUAYwB0AGkAbwBuAGEAbABMAGkAZwBoAHQAUwB0AGEAdABpAGMAUwBoAGEAZABvAHcAbQBhAHAAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAE0ATQBWAF8AUwB0AGEAdABpAGMAUwBoAGEAZABvAHcAbQBhAHAAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQATQBNAFYAXwBGAG8AcgB3AGEAcgBkAEwAbwBjAGEAbABMAGkAZwBoAHQAQgB1AGYAZgBlAHIAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAE0ATQBWAF8ATgB1AG0AQwB1AGwAbABlAGQATABpAGcAaAB0AHMARwByAGkAZAAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQATQBNAFYAXwBDAHUAbABsAGUAZABMAGkAZwBoAHQARABhAHQAYQBHAHIAaQBkADMAMgBCAGkAdAAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQATQBNAFYAXwBDAHUAbABsAGUAZABMAGkAZwBoAHQARABhAHQAYQBHAHIAaQBkADEANgBCAGkAdAAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFAAbABhAG4AYQByAFIAZQBmAGwAZQBjAHQAaQBvAG4AXwBQAGwAYQBuAGEAcgBSAGUAZgBsAGUAYwB0AGkAbwBuAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBQAGwAYQBuAGEAcgBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUABsAGEAbgBhAHIAUgBlAGYAbABlAGMAdABpAG8AbgBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBDAG8AbABvAHIAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUAQwBvAGwAbwByAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUARABlAHAAdABoAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAEEAcgByAGEAeQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUARABlAHAAdABoAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUAUABhAHIAdABpAGEAbABEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUAUABhAHIAdABpAGEAbABEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEMAdQBzAHQAbwBtAEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEMAdQBzAHQAbwBtAEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AQwB1AHMAdABvAG0AUwB0AGUAbgBjAGkAbABUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBWAGUAbABvAGMAaQB0AHkAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUAVgBlAGwAbwBjAGkAdAB5AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAEEAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAEIAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAEMAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAEQAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUARABlAHAAdABoAEEAdQB4AFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEQAZQBwAHQAaABBAHUAeABUAGUAeAB0AHUAcgBlAEEAcgByAGEAeQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBMAG8AYwBhAGwATABpAGcAaAB0AFQAZQB4AHQAdQByAGUAQQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBMAG8AYwBhAGwATABpAGcAaAB0AFQAZQB4AHQAdQByAGUAQgAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAEEAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEcAQgB1AGYAZgBlAHIAQgBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBDAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAEQAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBEAGUAcAB0AGgAQQB1AHgAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUQB1AGEAZABPAHYAZQByAGQAcgBhAHcAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAHMAUABhAHIAYQBtAGUAdABlAHIAcwBfAFMAawB5AEwAaQBnAGgAdABDAHUAYgBlAG0AYQBwAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUgBlAGYAbABlAGMAdABpAG8AbgBzAFAAYQByAGEAbQBlAHQAZQByAHMAXwBTAGsAeQBMAGkAZwBoAHQAQwB1AGIAZQBtAGEAcABTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUgBlAGYAbABlAGMAdABpAG8AbgBzAFAAYQByAGEAbQBlAHQAZQByAHMAXwBTAGsAeQBMAGkAZwBoAHQAQgBsAGUAbgBkAEQAZQBzAHQAaQBuAGEAdABpAG8AbgBDAHUAYgBlAG0AYQBwAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUgBlAGYAbABlAGMAdABpAG8AbgBzAFAAYQByAGEAbQBlAHQAZQByAHMAXwBTAGsAeQBMAGkAZwBoAHQAQgBsAGUAbgBkAEQAZQBzAHQAaQBuAGEAdABpAG8AbgBDAHUAYgBlAG0AYQBwAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAHMAUABhAHIAYQBtAGUAdABlAHIAcwBfAFIAZQBmAGwAZQBjAHQAaQBvAG4AQwB1AGIAZQBtAGEAcAAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFIAZQBmAGwAZQBjAHQAaQBvAG4AcwBQAGEAcgBhAG0AZQB0AGUAcgBzAF8AUgBlAGYAbABlAGMAdABpAG8AbgBDAHUAYgBlAG0AYQBwAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAHMAUABhAHIAYQBtAGUAdABlAHIAcwBfAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQARwBGAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUgBlAGYAbABlAGMAdABpAG8AbgBzAFAAYQByAGEAbQBlAHQAZQByAHMAXwBQAHIAZQBJAG4AdABlAGcAcgBhAHQAZQBkAEcARgBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUAByAGUASQBuAHQAZQBnAHIAYQB0AGUAZABHAEYAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQARwBGAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBFAHkAZQBBAGQAYQBwAHQAYQB0AGkAbwBuAEIAdQBmAGYAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUgBXAE8AYwBjAGwAdQBzAGkAbwBuAEIAdQBmAGYAZQByAFUAQQBWAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AQQBtAGIAaQBlAG4AdABPAGMAYwBsAHUAcwBpAG8AbgBUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AQQBtAGIAaQBlAG4AdABPAGMAYwBsAHUAcwBpAG8AbgBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8AUwBjAHIAZQBlAG4AUwBwAGEAYwBlAFMAaABhAGQAbwB3AE0AYQBzAGsAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAFMAYwByAGUAZQBuAFMAcABhAGMAZQBTAGgAYQBkAG8AdwBNAGEAcwBrAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBEAEIAdQBmAGYAZQByAEEAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEQAQgB1AGYAZgBlAHIAQgBUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8ARABCAHUAZgBmAGUAcgBDAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBEAEIAdQBmAGYAZQByAFIAZQBuAGQAZQByAE0AYQBzAGsAAABNAG8AYgBpAGwAZQBCAGEAcwBlAFAAYQBzAHMAXwBEAEIAdQBmAGYAZQByAEEAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAQgBhAHMAZQBQAGEAcwBzAF8ARABCAHUAZgBmAGUAcgBCAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAEIAYQBzAGUAUABhAHMAcwBfAEQAQgB1AGYAZgBlAHIAQwBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAAARAAAAVmlydHVhbFNoYWRvd01hcAAXAAAAVmlydHVhbFNoYWRvd01hcFViU2xvdAABAqAZAgAAAAAFAQAAVgBpAHIAdAB1AGEAbABTAGgAYQBkAG8AdwBNAGEAcABfAFAAcgBvAGoAZQBjAHQAaQBvAG4ARABhAHQAYQAAAFYAaQByAHQAdQBhAGwAUwBoAGEAZABvAHcATQBhAHAAXwBQAGEAZwBlAFQAYQBiAGwAZQAAAFYAaQByAHQAdQBhAGwAUwBoAGEAZABvAHcATQBhAHAAXwBQAGEAZwBlAEYAbABhAGcAcwAAAFYAaQByAHQAdQBhAGwAUwBoAGEAZABvAHcATQBhAHAAXwBQAGEAZwBlAFIAZQBjAHQAQgBvAHUAbgBkAHMAAABWAGkAcgB0AHUAYQBsAFMAaABhAGQAbwB3AE0AYQBwAF8AUABoAHkAcwBpAGMAYQBsAFAAYQBnAGUAUABvAG8AbAAAAFYAaQByAHQAdQBhAGwAUwBoAGEAZABvAHcATQBhAHAAXwBDAGEAYwBoAGUAUAByAGkAbQBpAHQAaQB2AGUAQQBzAEQAeQBuAGEAbQBpAGMAAABWAGkAcgB0AHUAYQBsAFMAaABhAGQAbwB3AE0AYQBwAF8ATABpAGcAaAB0AEcAcgBpAGQARABhAHQAYQAAAFYAaQByAHQAdQBhAGwAUwBoAGEAZABvAHcATQBhAHAAXwBOAHUAbQBDAHUAbABsAGUAZABMAGkAZwBoAHQAcwBHAHIAaQBkAAAABwAAAE5hbml0ZQAHAAAATmFuaXRlADgd2QkCAAAAAEIBAABOAGEAbgBpAHQAZQBfAEMAbAB1AHMAdABlAHIAUABhAGcAZQBEAGEAdABhAAAATgBhAG4AaQB0AGUAXwBWAGkAcwBpAGIAbABlAEMAbAB1AHMAdABlAHIAcwBTAFcASABXAAAATgBhAG4AaQB0AGUAXwBIAGkAZQByAGEAcgBjAGgAeQBCAHUAZgBmAGUAcgAAAE4AYQBuAGkAdABlAF8ATQBhAHQAZQByAGkAYQBsAFQAaQBsAGUAUgBlAG0AYQBwAAAATgBhAG4AaQB0AGUAXwBNAGEAdABlAHIAaQBhAGwARABlAHAAdABoAFQAYQBiAGwAZQAAAE4AYQBuAGkAdABlAF8AUwBoAGEAZABpAG4AZwBNAGEAcwBrAAAATgBhAG4AaQB0AGUAXwBWAGkAcwBCAHUAZgBmAGUAcgA2ADQAAABOAGEAbgBpAHQAZQBfAEQAYgBnAEIAdQBmAGYAZQByADYANAAAAE4AYQBuAGkAdABlAF8ARABiAGcAQgB1AGYAZgBlAHIAMwAyAAAATgBhAG4AaQB0AGUAXwBSAGEAeQBUAHIAYQBjAGkAbgBnAEQAYQB0AGEAQgB1AGYAZgBlAHIAAABOAGEAbgBpAHQAZQBfAFMAaABhAGQAaQBuAGcAQgBpAG4ARABhAHQAYQAAAE4AYQBuAGkAdABlAF8ATQB1AGwAdABpAFYAaQBlAHcASQBuAGQAaQBjAGUAcwAAAE4AYQBuAGkAdABlAF8ATQB1AGwAdABpAFYAaQBlAHcAUgBlAGMAdABTAGMAYQBsAGUATwBmAGYAcwBlAHQAcwAAAE4AYQBuAGkAdABlAF8ASQBuAFYAaQBlAHcAcwAAABEAAABOYW5pdGVSYXlUcmFjaW5nABEAAABOYW5pdGVSYXlUcmFjaW5nADkDRgADAAAAAGgAAABOAGEAbgBpAHQAZQBSAGEAeQBUAHIAYQBjAGkAbgBnAF8AQwBsAHUAcwB0AGUAcgBQAGEAZwBlAEQAYQB0AGEAAABOAGEAbgBpAHQAZQBSAGEAeQBUAHIAYQBjAGkAbgBnAF8ASABpAGUAcgBhAHIAYwBoAHkAQgB1AGYAZgBlAHIAAABOAGEAbgBpAHQAZQBSAGEAeQBUAHIAYQBjAGkAbgBnAF8AUgBhAHkAVAByAGEAYwBpAG4AZwBEAGEAdABhAEIAdQBmAGYAZQByAAAAEAAAAFNoYWRlclByaW50RGF0YQAAAAAAAAFQAAEAAAAAAAAAABsAAABJbnN0YW5jZWRWRkxvb3NlUGFyYW1ldGVycwAAAAAAAAFgAAEAAAAAAAAAAAgAAABMb2NhbFZGAAAAAAAYB0YGAQAAAADDAAAATABvAGMAYQBsAFYARgBfAFYAZQByAHQAZQB4AEYAZQB0AGMAaABfAFQAZQB4AEMAbwBvAHIAZABCAHUAZgBmAGUAcgAAAEwAbwBjAGEAbABWAEYAXwBWAGUAcgB0AGUAeABGAGUAdABjAGgAXwBQAG8AcwBpAHQAaQBvAG4AQgB1AGYAZgBlAHIAAABMAG8AYwBhAGwAVgBGAF8AVgBlAHIAdABlAHgARgBlAHQAYwBoAF8AUAByAGUAUwBrAGkAbgBQAG8AcwBpAHQAaQBvAG4AQgB1AGYAZgBlAHIAAABMAG8AYwBhAGwAVgBGAF8AVgBlAHIAdABlAHgARgBlAHQAYwBoAF8AUABhAGMAawBlAGQAVABhAG4AZwBlAG4AdABzAEIAdQBmAGYAZQByAAAATABvAGMAYQBsAFYARgBfAFYAZQByAHQAZQB4AEYAZQB0AGMAaABfAEMAbwBsAG8AcgBDAG8AbQBwAG8AbgBlAG4AdABzAEIAdQBmAGYAZQByAAAAFwAAAExvY2FsVkZMb29zZVBhcmFtZXRlcnMAAAAAAAABJgABAAAAALkAAABMAG8AYwBhAGwAVgBGAEwAbwBvAHMAZQBQAGEAcgBhAG0AZQB0AGUAcgBzAF8ARwBQAFUAUwBrAGkAbgBQAGEAcwBzAFQAaAByAG8AdQBnAGgAUABvAHMAaQB0AGkAbwBuAEIAdQBmAGYAZQByAAAATABvAGMAYQBsAFYARgBMAG8AbwBzAGUAUABhAHIAYQBtAGUAdABlAHIAcwBfAEcAUABVAFMAawBpAG4AUABhAHMAcwBUAGgAcgBvAHUAZwBoAFAAcgBlAHYAaQBvAHUAcwBQAG8AcwBpAHQAaQBvAG4AQgB1AGYAZgBlAHIAAABMAG8AYwBhAGwAVgBGAEwAbwBvAHMAZQBQAGEAcgBhAG0AZQB0AGUAcgBzAF8ARwBQAFUAUwBrAGkAbgBQAGEAcwBzAFQAaAByAG8AdQBnAGgAUAByAGUAUwBrAGkAbgBuAGUAZABUAGEAbgBnAGUAbgB0AEIAdQBmAGYAZQByAAAACQAAAE1hdGVyaWFsAAAAAAAAATgAAQAAAABDAAAATQBhAHQAZQByAGkAYQBsAF8AVwByAGEAcABfAFcAbwByAGwAZABHAHIAbwB1AHAAUwBlAHQAdABpAG4AZwBzAAAATQBhAHQAZQByAGkAYQBsAF8AQwBsAGEAbQBwAF8AVwBvAHIAbABkAEcAcgBvAHUAcABTAGUAdAB0AGkAbgBnAHMAAAAAAAAA
BASE64_ENV */
/* DIRECT COMPILE
-directcompile -format=PCD3D_SM6 -entry="MainPS" -shaderPlatformName=PCD3D_SM6 -supportedHardwareMask=0 -ps C:/Users/gibsonj5097/OneDrive - University of Wisconsin-Stout/Documents/Classes/4th Fall/Shader Programming + Procedural Modeling/Unreal Project/ShaderProject/Saved/ShaderDebugInfo/PCD3D_SM6/CrystalBall_ffea2946357c9295/Default/FLocalVertexFactory/TBasePassPSFNoLightMapPolicySkylight/0/BasePassPixelShader.usf -nocrashreports
DIRECT COMPILE */
